** First version PERL**

INIT -> BLOCKCODE INIT | FUNCTION INIT | BLOCKCODE | FUNCTION

BLOCKCODE -> COMMAND | COMMAND BLOCKCODE  
COMMAND -> INTERATIONS | IF | EXP_ASSIGNMENT | CALL |  return RETURN; | break; | continue;

EXP_ASSIGNMENT -> IDENTIFIER_SC = ARITHMETIC | IDENTIFIER_LI = ARITHMETIC |
                IDENTIFIER_SC | IDENTIFIER_LI |
                | ++IDENTIFIER_SC | --IDENTIFIER_SC | IDENTIFIER_SC++ | IDENTIFIER_SC--

IDENTIFIER_SC -> $[a-zA-Z][a-zA-Z0-9]*
IDENTIFIER_LI -> @[a-zA-Z][a-zA-Z0-9]*
IDENTIFIER -> [a-zA-Z][a-zA-Z0-9]*


IF -> if (EXP_CONDITION) IF_STATEMENT
   | COMMAND if(EXP_CONDITION) /* essa regra aqui talvez n possa pq command vai pra if ai da SHIFT/REDUCE*/

IF_STATEMENT -> {BLOCKCODE}
    | {BLOCKCODE}else{BLOCKCODE}
    | {BLOCKCODE} ELSIF

ELSIF -> elsif(EXP_CONDITION){BLOCKCODE} | elsif(EXP_CONDITION){BLOCKCODE}ELSIF2
ELSIF2 -> ELSIF | else{BLOCKCODE}

INTERATIONS -> FOR | DOWHILE | WHILE 

FOR -> for(FOR_ASSIGNMENTS; [EXP_CONDITION]; FOR_ASSIGNMENTS){BLOCKCODE}
FOR_ASSIGNMENTS -> EXP_ASSIGNMENT | EXP_ASSIGNMENT , FOR_ASSIGNMENTS

DOWHILE -> do{BLOCKCODE}while(EXP_CONDITION)
WHILE -> while(EXP_CONDITION){BLOCKCODE} | while(EXP_CONDITION){}


FUNCTION -> sub IDENTIFIER(){BLOCKCODE} | sub IDENTIFIER(FUNCTION_ASSIGNMENTS){BLOCKCODE}
FUNCTION_ASSIGNMENTS -> EXP_ASSIGNMENT | EXP_ASSIGNMENT , FUNCTION_ASSIGNMENTS

EXP_CONDITION -> ATTCOND > ATTCOND | ATTCOND < ATTCOND |
            ATTCOND == ATTCOND | ATTCOND >= ATTCOND |
            ATTCOND <= ATTCOND | ATTCOND != ATTCOND |

            ATTCOND cmp ATTCOND | ATTCOND eq ATTCOND | 
            ATTCOND ne ATTCOND | ATTCOND lt ATTCOND |
            ATTCOND gt ATTCOND | ATTCOND le ATTCOND |
            ATTCOND ge ATTCOND
            ATTCOND | ((CONDITION) [LOGIC (CONDITION)]*) |

EXP_CONDITION -> EXP_CONDITION > EXP_CONDITION_2
    | EXP_CONDITION < EXP_CONDITION_2
    | EXP_CONDITION_2

EXP_CONDITION_2 -> EXP_CONDITION_2 >= EXP_CONDITION_3
    | EXP_CONDITION_2 <= EXP_CONDITION_3
    | EXP_CONDITION_3

EXP_CONDITION_3 -> EXP_CONDITION_3 == EXP_CONDITION_4
    | EXP_CONDITION_3 != EXP_CONDITION_4
    | EXP_CONDITION_4

EXP_CONDITION_4 -> EXP_CONDITION_4 gt EXP_CONDITION_5
    | EXP_CONDITION_4 lt EXP_CONDITION_5
    | EXP_CONDITION_5

EXP_CONDITION_5 -> EXP_CONDITION_5 ge EXP_CONDITION_6
    | EXP_CONDITION_5 le EXP_CONDITION_6
    | EXP_CONDITION_6

EXP_CONDITION_6 -> EXP_CONDITION_6 eq EXP_CONDITION_7
    | EXP_CONDITION_6 ne EXP_CONDITION_7
    | EXP_CONDITION_7

EXP_CONDITION_7 -> EXP_CONDITION_7 cmp EXP_CONDITION_8
    | EXP_CONDITION_7 ne EXP_CONDITION_8
    | EXP_CONDITION_8

EXP_CONDITION_8 -> ATTCOND
    | EXP_CONDITION LOGIC EXP_CONDITION

LOGIC -> && | || | ! |

ATTCOND -> EXP_ASSIGNMENT | NUMBER | true | false

RETURN -> ATTCOND | ARITHMETIC

CALL -> IDENTIFIER() | IDENTIFIER(FUNCTION_ASSIGNMENTS)

ARITHMETIC -> EXP
EXP -> EXP + EXP1 | EXP - EXP1 | EXP1
EXP1 -> EXP1 * EXP2 | EXP1 / EXP2 | EXP2
EXP2 -> EXP3 ^ EXP2 | EXP3
EXP3 -> ( ARITHMETIC ) | NUMBER | EXP_ASSIGNMENT | CALL | EXP 

