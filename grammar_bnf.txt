** First version PERL**

INIT -> BLOCKCODE | FUNCTIONS

BLOCKCODE -> COMMAND | COMMAND BLOCKCODE  
COMMAND -> INTERATIONS | IF | EXP_ASSIGNMENT | CALL |  return RETURN; | break; | continue;

EXP_ASSIGNMENT -> IDENTIFIER_SC = ARITHMETIC | IDENTIFIER_LI = ARITHMETIC |
                IDENTIFIER_SC | IDENTIFIER_LI |
                | ++IDENTIFIER_SC | --IDENTIFIER_SC | IDENTIFIER_SC++ | IDENTIFIER_SC--  

IDENTIFIER_SC -> $[a-zA-Z][a-zA-Z0-9]*
IDENTIFIER_LI -> @[a-zA-Z][a-zA-Z0-9]*
IDENTIFIER -> [a-zA-Z][a-zA-Z0-9]*


IF -> if(CONDITION){BLOCKCODE} |
    if(CONDITION){BLOCKCODE}else{BLOCKCODE} |
    if(CONDITION){BLOCKCODE}ELSIF

ELSIF -> elsif(CONDITION){BLOCKCODE} | elsif(CONDITION){BLOCKCODE}ELSIF2 
ELSIF2 -> ELSIF | else{BLOCKCODE}


IF -> if(CONDITION){BLOCKCODE}IF IF2 | if(CONDITION){BLOCKCODE}
IF2 -> else{BLOCKCODE} IF | elsif(CONDITION){BLOCKCODE} IF2 | else{BLOCKCODE}

INTERATIONS -> FOR | DOWHILE | WHILE 

FOR -> for(FOR_ASSIGNMENTS; [CONDITION]; FOR_ASSIGNMENTS){BLOCKCODE}
FOR_ASSIGNMENTS -> EXP_ASSIGNMENT | EXP_ASSIGNMENT , FOR_ASSIGNMENTS

DOWHILE -> do{BLOCKCODE}while(CONDITION)
WHILE -> while(CONDITION){BLOCKCODE}

FUNCTIONS -> FUNCTION | FUNCTION FUNCTIONS
FUNCTION -> sub IDENTIFIER(){BLOCKCODE} | sub IDENTIFIER(FUNCTION_ASSIGNMENTS){BLOCKCODE}
FUNCTION_ASSIGNMENTS -> EXP_ASSIGNMENT | EXP_ASSIGNMENT , FUNCTION_ASSIGNMENTS

CONDITION -> ATTCOND > ATTCOND | ATTCOND < ATTCOND |
            ATTCOND == ATTCOND | ATTCOND >= ATTCOND |
            ATTCOND <= ATTCOND | ATTCOND != ATTCOND |
            ATTCOND | ((CONDITION) [LOGIC (CONDITION)]*) |
            ATTCOND cmp ATTCOND | ATTCOND eq ATTCOND | 
            ATTCOND ne ATTCOND | ATTCOND lt ATTCOND |
            ATTCOND gt ATTCOND | ATTCOND le ATTCOND |
            ATTCOND ge ATTCOND | EXP CONDITION 

LOGIC -> && | || | ! |

CALL ->

ATTCOND -> EXP_ASSIGNMENT | NUMBER | true | false

RETURN -> ATTCOND | ARITHMETIC

EXP -> NUMBER | EXP_ASSIGNMENT | CALL

ARITHMETIC -> EXP + EXP | EXP - EXP | EXP * EXP | EXP / EXP | EXP | ( ARITHMETIC )

ARITHMETIC -> EXP
EXP -> EXP + EXP1 | EXP - EXP1 | CONDITION | EXP1
EXP1 -> EXP1 * EXP2 | EXP1 / EXP2 | EXP2
EXP2 -> EXP3 ^ EXP2 | EXP3
EXP3 -> ( ARITHMETIC ) | NUMBER | EXP_ASSIGNMENT | CALL | | true | false |EXP 

