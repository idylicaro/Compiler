Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    ANDEQUAL
    COLON
    DIVEQUAL
    EXP
    LBRACKET
    LSHIFT
    LSHIFTEQUAL
    MINUSEQUAL
    MODEQUAL
    NO
    OR
    OREQUAL
    PERIOD
    PLUSEQUAL
    Q
    QQ
    QR
    QW
    QX
    RBRACKET
    RSHIFT
    RSHIFTEQUAL
    S
    TERNARY
    TIMESEQUAL
    TR
    UNLESS
    UNTIL
    XOREQUAL

Grammar

Rule 0     S' -> init
Rule 1     init -> blockcode init
Rule 2     init -> function init
Rule 3     init -> blockcode
Rule 4     init -> function
Rule 5     blockcode -> command
Rule 6     blockcode -> command blockcode
Rule 7     command -> interations
Rule 8     command -> if
Rule 9     command -> exp_assignment
Rule 10    command -> call
Rule 11    command -> RETURN return SEMICOLON
Rule 12    command -> BREAK SEMICOLON
Rule 13    command -> CONTINUE SEMICOLON
Rule 14    if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
Rule 15    if -> command IF LPAREN exp_condition RPAREN
Rule 16    if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
Rule 17    if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif
Rule 18    elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
Rule 19    elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2
Rule 20    elsif2 -> elsif
Rule 21    elsif2 -> ELSE LBRACE blockcode RBRACE
Rule 22    interations -> for
Rule 23    interations -> dowhile
Rule 24    interations -> while
Rule 25    for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
Rule 26    for_assignments -> exp_assignment
Rule 27    for_assignments -> exp_assignment COMMA for_assignments
Rule 28    dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
Rule 29    while -> LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
Rule 30    function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE
Rule 31    function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE
Rule 32    function_assignments -> exp_assignment
Rule 33    function_assignments -> exp_assignment COMMA function_assignments
Rule 34    exp_condition -> attcond GT attcond
Rule 35    exp_condition -> attcond LT attcond
Rule 36    exp_condition -> attcond EQ attcond
Rule 37    exp_condition -> attcond GE attcond
Rule 38    exp_condition -> attcond LE attcond
Rule 39    exp_condition -> attcond NE attcond
Rule 40    exp_condition -> attcond
Rule 41    exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic
Rule 42    exp_condition -> attcond CMP attcond
Rule 43    exp_condition -> attcond SEQ attcond
Rule 44    exp_condition -> attcond SNE attcond
Rule 45    exp_condition -> attcond SLT attcond
Rule 46    exp_condition -> attcond SGT attcond
Rule 47    exp_condition -> attcond SLE attcond
Rule 48    exp_condition -> attcond SGE attcond
Rule 49    exp_condition_logic -> LPAREN exp_condition RPAREN
Rule 50    exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN
Rule 51    logic -> LAND
Rule 52    logic -> LOR
Rule 53    logic -> LNOT
Rule 54    exp_assignment -> ID_SC EQUALS arithmetic
Rule 55    exp_assignment -> ID_LI EQUALS arithmetic
Rule 56    exp_assignment -> ID_SC
Rule 57    exp_assignment -> ID_LI
Rule 58    exp_assignment -> INCREMENT ID_SC
Rule 59    exp_assignment -> DECREMENT ID_SC
Rule 60    exp_assignment -> ID_SC INCREMENT
Rule 61    exp_assignment -> ID_SC DECREMENT
Rule 62    arithmetic -> exp
Rule 63    exp -> exp PLUS exp1
Rule 64    exp -> exp MINUS exp1
Rule 65    exp -> exp1
Rule 66    exp1 -> exp1 TIMES exp2
Rule 67    exp1 -> exp1 DIVIDE exp2
Rule 68    exp1 -> exp1 MODULO exp2
Rule 69    exp1 -> exp2
Rule 70    exp2 -> exp3 XOR exp2
Rule 71    exp2 -> exp3
Rule 72    exp3 -> LPAREN arithmetic RPAREN
Rule 73    exp3 -> NUMBER
Rule 74    exp3 -> exp_assignment
Rule 75    exp3 -> exp_condition
Rule 76    exp3 -> call
Rule 77    exp3 -> exp
Rule 78    attcond -> exp_assignment
Rule 79    attcond -> NUMBER
Rule 80    attcond -> true
Rule 81    attcond -> false
Rule 82    call -> ID LPAREN RPAREN
Rule 83    call -> ID LPAREN function_assignments RPAREN
Rule 84    return -> attcond
Rule 85    return -> arithmetic
Rule 86    true -> TRUE
Rule 87    false -> FALSE

Terminals, with rules where they appear

AND                  : 
ANDEQUAL             : 
BREAK                : 12
CMP                  : 42
COLON                : 
COMMA                : 27 33
CONTINUE             : 13
DECREMENT            : 59 61
DIVEQUAL             : 
DIVIDE               : 67
DO                   : 28
ELSE                 : 16 21
ELSIF                : 18 19
EQ                   : 36
EQUALS               : 54 55
EXP                  : 
FALSE                : 87
FOR                  : 25
GE                   : 37
GT                   : 34
ID                   : 30 31 82 83
ID_LI                : 55 57
ID_SC                : 54 56 58 59 60 61
IF                   : 14 15 16 17
INCREMENT            : 58 60
LAND                 : 51
LBRACE               : 14 16 16 17 18 19 21 25 28 29 30 31
LBRACKET             : 
LE                   : 38
LNOT                 : 53
LOR                  : 52
LPAREN               : 14 15 16 17 18 19 25 28 29 30 31 41 49 50 50 72 82 83
LSHIFT               : 
LSHIFTEQUAL          : 
LT                   : 35
MINUS                : 64
MINUSEQUAL           : 
MODEQUAL             : 
MODULO               : 68
NE                   : 39
NO                   : 
NUMBER               : 73 79
OR                   : 
OREQUAL              : 
PERIOD               : 
PLUS                 : 63
PLUSEQUAL            : 
Q                    : 
QQ                   : 
QR                   : 
QW                   : 
QX                   : 
RBRACE               : 14 16 16 17 18 19 21 25 28 29 30 31
RBRACKET             : 
RETURN               : 11
RPAREN               : 14 15 16 17 18 19 25 28 29 30 31 41 49 50 50 72 82 83
RSHIFT               : 
RSHIFTEQUAL          : 
S                    : 
SEMICOLON            : 11 12 13 25 25
SEQ                  : 43
SGE                  : 48
SGT                  : 46
SLE                  : 47
SLT                  : 45
SNE                  : 44
SUB                  : 30 31
TERNARY              : 
TIMES                : 66
TIMESEQUAL           : 
TR                   : 
TRUE                 : 86
UNLESS               : 
UNTIL                : 
WHILE                : 28
XOR                  : 70
XOREQUAL             : 
error                : 

Nonterminals, with rules where they appear

arithmetic           : 54 55 72 85
attcond              : 34 34 35 35 36 36 37 37 38 38 39 39 40 42 42 43 43 44 44 45 45 46 46 47 47 48 48 84
blockcode            : 1 3 6 14 16 16 17 18 19 21 25 28 29 30 31
call                 : 10 76
command              : 5 6 15
dowhile              : 23
elsif                : 17 20
elsif2               : 19
exp                  : 62 63 64 77
exp1                 : 63 64 65 66 67 68
exp2                 : 66 67 68 69 70
exp3                 : 70 71
exp_assignment       : 9 26 27 32 33 74 78
exp_condition        : 14 15 16 17 18 19 25 28 29 41 49 50 50 75
exp_condition_logic  : 41
false                : 81
for                  : 22
for_assignments      : 25 25 27
function             : 2 4
function_assignments : 31 33 83
if                   : 8
init                 : 1 2 0
interations          : 7
logic                : 41 50
return               : 11
true                 : 80
while                : 24

Parsing method: LALR

state 0

    (0) S' -> . init
    (1) init -> . blockcode init
    (2) init -> . function init
    (3) init -> . blockcode
    (4) init -> . function
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (30) function -> . SUB ID LPAREN RPAREN LBRACE blockcode RBRACE
    (31) function -> . SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (15) if -> . command IF LPAREN exp_condition RPAREN
    (16) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE

    SUB             shift and go to state 5
    RETURN          shift and go to state 12
    BREAK           shift and go to state 13
    CONTINUE        shift and go to state 14
    IF              shift and go to state 18
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    ID              shift and go to state 6
    FOR             shift and go to state 23
    DO              shift and go to state 24
    LPAREN          shift and go to state 7

    init                           shift and go to state 1
    blockcode                      shift and go to state 2
    function                       shift and go to state 3
    command                        shift and go to state 4
    interations                    shift and go to state 8
    if                             shift and go to state 9
    exp_assignment                 shift and go to state 10
    call                           shift and go to state 11
    for                            shift and go to state 15
    dowhile                        shift and go to state 16
    while                          shift and go to state 17

state 1

    (0) S' -> init .



state 2

    (1) init -> blockcode . init
    (3) init -> blockcode .
    (1) init -> . blockcode init
    (2) init -> . function init
    (3) init -> . blockcode
    (4) init -> . function
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (30) function -> . SUB ID LPAREN RPAREN LBRACE blockcode RBRACE
    (31) function -> . SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (15) if -> . command IF LPAREN exp_condition RPAREN
    (16) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE

    $end            reduce using rule 3 (init -> blockcode .)
    SUB             shift and go to state 5
    RETURN          shift and go to state 12
    BREAK           shift and go to state 13
    CONTINUE        shift and go to state 14
    IF              shift and go to state 18
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    ID              shift and go to state 6
    FOR             shift and go to state 23
    DO              shift and go to state 24
    LPAREN          shift and go to state 7

    blockcode                      shift and go to state 2
    init                           shift and go to state 25
    function                       shift and go to state 3
    command                        shift and go to state 4
    interations                    shift and go to state 8
    if                             shift and go to state 9
    exp_assignment                 shift and go to state 10
    call                           shift and go to state 11
    for                            shift and go to state 15
    dowhile                        shift and go to state 16
    while                          shift and go to state 17

state 3

    (2) init -> function . init
    (4) init -> function .
    (1) init -> . blockcode init
    (2) init -> . function init
    (3) init -> . blockcode
    (4) init -> . function
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (30) function -> . SUB ID LPAREN RPAREN LBRACE blockcode RBRACE
    (31) function -> . SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (15) if -> . command IF LPAREN exp_condition RPAREN
    (16) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE

    $end            reduce using rule 4 (init -> function .)
    SUB             shift and go to state 5
    RETURN          shift and go to state 12
    BREAK           shift and go to state 13
    CONTINUE        shift and go to state 14
    IF              shift and go to state 18
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    ID              shift and go to state 6
    FOR             shift and go to state 23
    DO              shift and go to state 24
    LPAREN          shift and go to state 7

    function                       shift and go to state 3
    init                           shift and go to state 26
    blockcode                      shift and go to state 2
    command                        shift and go to state 4
    interations                    shift and go to state 8
    if                             shift and go to state 9
    exp_assignment                 shift and go to state 10
    call                           shift and go to state 11
    for                            shift and go to state 15
    dowhile                        shift and go to state 16
    while                          shift and go to state 17

state 4

    (5) blockcode -> command .
    (6) blockcode -> command . blockcode
    (15) if -> command . IF LPAREN exp_condition RPAREN
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (15) if -> . command IF LPAREN exp_condition RPAREN
    (16) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for ID_SC resolved as shift
  ! shift/reduce conflict for ID_LI resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    SUB             reduce using rule 5 (blockcode -> command .)
    $end            reduce using rule 5 (blockcode -> command .)
    RBRACE          reduce using rule 5 (blockcode -> command .)
    IF              shift and go to state 28
    RETURN          shift and go to state 12
    BREAK           shift and go to state 13
    CONTINUE        shift and go to state 14
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    ID              shift and go to state 6
    FOR             shift and go to state 23
    DO              shift and go to state 24
    LPAREN          shift and go to state 7

  ! RETURN          [ reduce using rule 5 (blockcode -> command .) ]
  ! BREAK           [ reduce using rule 5 (blockcode -> command .) ]
  ! CONTINUE        [ reduce using rule 5 (blockcode -> command .) ]
  ! IF              [ reduce using rule 5 (blockcode -> command .) ]
  ! ID_SC           [ reduce using rule 5 (blockcode -> command .) ]
  ! ID_LI           [ reduce using rule 5 (blockcode -> command .) ]
  ! INCREMENT       [ reduce using rule 5 (blockcode -> command .) ]
  ! DECREMENT       [ reduce using rule 5 (blockcode -> command .) ]
  ! ID              [ reduce using rule 5 (blockcode -> command .) ]
  ! FOR             [ reduce using rule 5 (blockcode -> command .) ]
  ! DO              [ reduce using rule 5 (blockcode -> command .) ]
  ! LPAREN          [ reduce using rule 5 (blockcode -> command .) ]

    command                        shift and go to state 4
    blockcode                      shift and go to state 27
    interations                    shift and go to state 8
    if                             shift and go to state 9
    exp_assignment                 shift and go to state 10
    call                           shift and go to state 11
    for                            shift and go to state 15
    dowhile                        shift and go to state 16
    while                          shift and go to state 17

state 5

    (30) function -> SUB . ID LPAREN RPAREN LBRACE blockcode RBRACE
    (31) function -> SUB . ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE

    ID              shift and go to state 29


state 6

    (82) call -> ID . LPAREN RPAREN
    (83) call -> ID . LPAREN function_assignments RPAREN

    LPAREN          shift and go to state 30


state 7

    (29) while -> LPAREN . exp_condition RPAREN LBRACE blockcode RBRACE
    (34) exp_condition -> . attcond GT attcond
    (35) exp_condition -> . attcond LT attcond
    (36) exp_condition -> . attcond EQ attcond
    (37) exp_condition -> . attcond GE attcond
    (38) exp_condition -> . attcond LE attcond
    (39) exp_condition -> . attcond NE attcond
    (40) exp_condition -> . attcond
    (41) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (42) exp_condition -> . attcond CMP attcond
    (43) exp_condition -> . attcond SEQ attcond
    (44) exp_condition -> . attcond SNE attcond
    (45) exp_condition -> . attcond SLT attcond
    (46) exp_condition -> . attcond SGT attcond
    (47) exp_condition -> . attcond SLE attcond
    (48) exp_condition -> . attcond SGE attcond
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE

    LPAREN          shift and go to state 31
    NUMBER          shift and go to state 35
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    exp_condition                  shift and go to state 32
    attcond                        shift and go to state 33
    exp_assignment                 shift and go to state 34
    true                           shift and go to state 36
    false                          shift and go to state 37

state 8

    (7) command -> interations .

    IF              reduce using rule 7 (command -> interations .)
    RETURN          reduce using rule 7 (command -> interations .)
    BREAK           reduce using rule 7 (command -> interations .)
    CONTINUE        reduce using rule 7 (command -> interations .)
    ID_SC           reduce using rule 7 (command -> interations .)
    ID_LI           reduce using rule 7 (command -> interations .)
    INCREMENT       reduce using rule 7 (command -> interations .)
    DECREMENT       reduce using rule 7 (command -> interations .)
    ID              reduce using rule 7 (command -> interations .)
    FOR             reduce using rule 7 (command -> interations .)
    DO              reduce using rule 7 (command -> interations .)
    LPAREN          reduce using rule 7 (command -> interations .)
    SUB             reduce using rule 7 (command -> interations .)
    $end            reduce using rule 7 (command -> interations .)
    RBRACE          reduce using rule 7 (command -> interations .)


state 9

    (8) command -> if .

    IF              reduce using rule 8 (command -> if .)
    RETURN          reduce using rule 8 (command -> if .)
    BREAK           reduce using rule 8 (command -> if .)
    CONTINUE        reduce using rule 8 (command -> if .)
    ID_SC           reduce using rule 8 (command -> if .)
    ID_LI           reduce using rule 8 (command -> if .)
    INCREMENT       reduce using rule 8 (command -> if .)
    DECREMENT       reduce using rule 8 (command -> if .)
    ID              reduce using rule 8 (command -> if .)
    FOR             reduce using rule 8 (command -> if .)
    DO              reduce using rule 8 (command -> if .)
    LPAREN          reduce using rule 8 (command -> if .)
    SUB             reduce using rule 8 (command -> if .)
    $end            reduce using rule 8 (command -> if .)
    RBRACE          reduce using rule 8 (command -> if .)


state 10

    (9) command -> exp_assignment .

    IF              reduce using rule 9 (command -> exp_assignment .)
    RETURN          reduce using rule 9 (command -> exp_assignment .)
    BREAK           reduce using rule 9 (command -> exp_assignment .)
    CONTINUE        reduce using rule 9 (command -> exp_assignment .)
    ID_SC           reduce using rule 9 (command -> exp_assignment .)
    ID_LI           reduce using rule 9 (command -> exp_assignment .)
    INCREMENT       reduce using rule 9 (command -> exp_assignment .)
    DECREMENT       reduce using rule 9 (command -> exp_assignment .)
    ID              reduce using rule 9 (command -> exp_assignment .)
    FOR             reduce using rule 9 (command -> exp_assignment .)
    DO              reduce using rule 9 (command -> exp_assignment .)
    LPAREN          reduce using rule 9 (command -> exp_assignment .)
    SUB             reduce using rule 9 (command -> exp_assignment .)
    $end            reduce using rule 9 (command -> exp_assignment .)
    RBRACE          reduce using rule 9 (command -> exp_assignment .)


state 11

    (10) command -> call .

    IF              reduce using rule 10 (command -> call .)
    RETURN          reduce using rule 10 (command -> call .)
    BREAK           reduce using rule 10 (command -> call .)
    CONTINUE        reduce using rule 10 (command -> call .)
    ID_SC           reduce using rule 10 (command -> call .)
    ID_LI           reduce using rule 10 (command -> call .)
    INCREMENT       reduce using rule 10 (command -> call .)
    DECREMENT       reduce using rule 10 (command -> call .)
    ID              reduce using rule 10 (command -> call .)
    FOR             reduce using rule 10 (command -> call .)
    DO              reduce using rule 10 (command -> call .)
    LPAREN          reduce using rule 10 (command -> call .)
    SUB             reduce using rule 10 (command -> call .)
    $end            reduce using rule 10 (command -> call .)
    RBRACE          reduce using rule 10 (command -> call .)


state 12

    (11) command -> RETURN . return SEMICOLON
    (84) return -> . attcond
    (85) return -> . arithmetic
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (62) arithmetic -> . exp
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE
    (63) exp -> . exp PLUS exp1
    (64) exp -> . exp MINUS exp1
    (65) exp -> . exp1
    (66) exp1 -> . exp1 TIMES exp2
    (67) exp1 -> . exp1 DIVIDE exp2
    (68) exp1 -> . exp1 MODULO exp2
    (69) exp1 -> . exp2
    (70) exp2 -> . exp3 XOR exp2
    (71) exp2 -> . exp3
    (72) exp3 -> . LPAREN arithmetic RPAREN
    (73) exp3 -> . NUMBER
    (74) exp3 -> . exp_assignment
    (75) exp3 -> . exp_condition
    (76) exp3 -> . call
    (77) exp3 -> . exp
    (34) exp_condition -> . attcond GT attcond
    (35) exp_condition -> . attcond LT attcond
    (36) exp_condition -> . attcond EQ attcond
    (37) exp_condition -> . attcond GE attcond
    (38) exp_condition -> . attcond LE attcond
    (39) exp_condition -> . attcond NE attcond
    (40) exp_condition -> . attcond
    (41) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (42) exp_condition -> . attcond CMP attcond
    (43) exp_condition -> . attcond SEQ attcond
    (44) exp_condition -> . attcond SNE attcond
    (45) exp_condition -> . attcond SLT attcond
    (46) exp_condition -> . attcond SGT attcond
    (47) exp_condition -> . attcond SLE attcond
    (48) exp_condition -> . attcond SGE attcond
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN

    NUMBER          shift and go to state 44
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39
    LPAREN          shift and go to state 49
    ID              shift and go to state 6

    return                         shift and go to state 40
    attcond                        shift and go to state 41
    arithmetic                     shift and go to state 42
    exp_assignment                 shift and go to state 43
    true                           shift and go to state 36
    false                          shift and go to state 37
    exp                            shift and go to state 45
    exp1                           shift and go to state 46
    exp2                           shift and go to state 47
    exp3                           shift and go to state 48
    exp_condition                  shift and go to state 50
    call                           shift and go to state 51

state 13

    (12) command -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 52


state 14

    (13) command -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 53


state 15

    (22) interations -> for .

    IF              reduce using rule 22 (interations -> for .)
    RETURN          reduce using rule 22 (interations -> for .)
    BREAK           reduce using rule 22 (interations -> for .)
    CONTINUE        reduce using rule 22 (interations -> for .)
    ID_SC           reduce using rule 22 (interations -> for .)
    ID_LI           reduce using rule 22 (interations -> for .)
    INCREMENT       reduce using rule 22 (interations -> for .)
    DECREMENT       reduce using rule 22 (interations -> for .)
    ID              reduce using rule 22 (interations -> for .)
    FOR             reduce using rule 22 (interations -> for .)
    DO              reduce using rule 22 (interations -> for .)
    LPAREN          reduce using rule 22 (interations -> for .)
    SUB             reduce using rule 22 (interations -> for .)
    $end            reduce using rule 22 (interations -> for .)
    RBRACE          reduce using rule 22 (interations -> for .)


state 16

    (23) interations -> dowhile .

    IF              reduce using rule 23 (interations -> dowhile .)
    RETURN          reduce using rule 23 (interations -> dowhile .)
    BREAK           reduce using rule 23 (interations -> dowhile .)
    CONTINUE        reduce using rule 23 (interations -> dowhile .)
    ID_SC           reduce using rule 23 (interations -> dowhile .)
    ID_LI           reduce using rule 23 (interations -> dowhile .)
    INCREMENT       reduce using rule 23 (interations -> dowhile .)
    DECREMENT       reduce using rule 23 (interations -> dowhile .)
    ID              reduce using rule 23 (interations -> dowhile .)
    FOR             reduce using rule 23 (interations -> dowhile .)
    DO              reduce using rule 23 (interations -> dowhile .)
    LPAREN          reduce using rule 23 (interations -> dowhile .)
    SUB             reduce using rule 23 (interations -> dowhile .)
    $end            reduce using rule 23 (interations -> dowhile .)
    RBRACE          reduce using rule 23 (interations -> dowhile .)


state 17

    (24) interations -> while .

    IF              reduce using rule 24 (interations -> while .)
    RETURN          reduce using rule 24 (interations -> while .)
    BREAK           reduce using rule 24 (interations -> while .)
    CONTINUE        reduce using rule 24 (interations -> while .)
    ID_SC           reduce using rule 24 (interations -> while .)
    ID_LI           reduce using rule 24 (interations -> while .)
    INCREMENT       reduce using rule 24 (interations -> while .)
    DECREMENT       reduce using rule 24 (interations -> while .)
    ID              reduce using rule 24 (interations -> while .)
    FOR             reduce using rule 24 (interations -> while .)
    DO              reduce using rule 24 (interations -> while .)
    LPAREN          reduce using rule 24 (interations -> while .)
    SUB             reduce using rule 24 (interations -> while .)
    $end            reduce using rule 24 (interations -> while .)
    RBRACE          reduce using rule 24 (interations -> while .)


state 18

    (14) if -> IF . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (16) if -> IF . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if -> IF . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif

    LPAREN          shift and go to state 54


state 19

    (54) exp_assignment -> ID_SC . EQUALS arithmetic
    (56) exp_assignment -> ID_SC .
    (60) exp_assignment -> ID_SC . INCREMENT
    (61) exp_assignment -> ID_SC . DECREMENT

  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
    EQUALS          shift and go to state 55
    IF              reduce using rule 56 (exp_assignment -> ID_SC .)
    RETURN          reduce using rule 56 (exp_assignment -> ID_SC .)
    BREAK           reduce using rule 56 (exp_assignment -> ID_SC .)
    CONTINUE        reduce using rule 56 (exp_assignment -> ID_SC .)
    ID_SC           reduce using rule 56 (exp_assignment -> ID_SC .)
    ID_LI           reduce using rule 56 (exp_assignment -> ID_SC .)
    ID              reduce using rule 56 (exp_assignment -> ID_SC .)
    FOR             reduce using rule 56 (exp_assignment -> ID_SC .)
    DO              reduce using rule 56 (exp_assignment -> ID_SC .)
    LPAREN          reduce using rule 56 (exp_assignment -> ID_SC .)
    SUB             reduce using rule 56 (exp_assignment -> ID_SC .)
    $end            reduce using rule 56 (exp_assignment -> ID_SC .)
    RBRACE          reduce using rule 56 (exp_assignment -> ID_SC .)
    GT              reduce using rule 56 (exp_assignment -> ID_SC .)
    LT              reduce using rule 56 (exp_assignment -> ID_SC .)
    EQ              reduce using rule 56 (exp_assignment -> ID_SC .)
    GE              reduce using rule 56 (exp_assignment -> ID_SC .)
    LE              reduce using rule 56 (exp_assignment -> ID_SC .)
    NE              reduce using rule 56 (exp_assignment -> ID_SC .)
    CMP             reduce using rule 56 (exp_assignment -> ID_SC .)
    SEQ             reduce using rule 56 (exp_assignment -> ID_SC .)
    SNE             reduce using rule 56 (exp_assignment -> ID_SC .)
    SLT             reduce using rule 56 (exp_assignment -> ID_SC .)
    SGT             reduce using rule 56 (exp_assignment -> ID_SC .)
    SLE             reduce using rule 56 (exp_assignment -> ID_SC .)
    SGE             reduce using rule 56 (exp_assignment -> ID_SC .)
    RPAREN          reduce using rule 56 (exp_assignment -> ID_SC .)
    SEMICOLON       reduce using rule 56 (exp_assignment -> ID_SC .)
    XOR             reduce using rule 56 (exp_assignment -> ID_SC .)
    TIMES           reduce using rule 56 (exp_assignment -> ID_SC .)
    DIVIDE          reduce using rule 56 (exp_assignment -> ID_SC .)
    MODULO          reduce using rule 56 (exp_assignment -> ID_SC .)
    PLUS            reduce using rule 56 (exp_assignment -> ID_SC .)
    MINUS           reduce using rule 56 (exp_assignment -> ID_SC .)
    COMMA           reduce using rule 56 (exp_assignment -> ID_SC .)
    INCREMENT       shift and go to state 56
    DECREMENT       shift and go to state 57

  ! INCREMENT       [ reduce using rule 56 (exp_assignment -> ID_SC .) ]
  ! DECREMENT       [ reduce using rule 56 (exp_assignment -> ID_SC .) ]


state 20

    (55) exp_assignment -> ID_LI . EQUALS arithmetic
    (57) exp_assignment -> ID_LI .

    EQUALS          shift and go to state 58
    IF              reduce using rule 57 (exp_assignment -> ID_LI .)
    RETURN          reduce using rule 57 (exp_assignment -> ID_LI .)
    BREAK           reduce using rule 57 (exp_assignment -> ID_LI .)
    CONTINUE        reduce using rule 57 (exp_assignment -> ID_LI .)
    ID_SC           reduce using rule 57 (exp_assignment -> ID_LI .)
    ID_LI           reduce using rule 57 (exp_assignment -> ID_LI .)
    INCREMENT       reduce using rule 57 (exp_assignment -> ID_LI .)
    DECREMENT       reduce using rule 57 (exp_assignment -> ID_LI .)
    ID              reduce using rule 57 (exp_assignment -> ID_LI .)
    FOR             reduce using rule 57 (exp_assignment -> ID_LI .)
    DO              reduce using rule 57 (exp_assignment -> ID_LI .)
    LPAREN          reduce using rule 57 (exp_assignment -> ID_LI .)
    SUB             reduce using rule 57 (exp_assignment -> ID_LI .)
    $end            reduce using rule 57 (exp_assignment -> ID_LI .)
    RBRACE          reduce using rule 57 (exp_assignment -> ID_LI .)
    GT              reduce using rule 57 (exp_assignment -> ID_LI .)
    LT              reduce using rule 57 (exp_assignment -> ID_LI .)
    EQ              reduce using rule 57 (exp_assignment -> ID_LI .)
    GE              reduce using rule 57 (exp_assignment -> ID_LI .)
    LE              reduce using rule 57 (exp_assignment -> ID_LI .)
    NE              reduce using rule 57 (exp_assignment -> ID_LI .)
    CMP             reduce using rule 57 (exp_assignment -> ID_LI .)
    SEQ             reduce using rule 57 (exp_assignment -> ID_LI .)
    SNE             reduce using rule 57 (exp_assignment -> ID_LI .)
    SLT             reduce using rule 57 (exp_assignment -> ID_LI .)
    SGT             reduce using rule 57 (exp_assignment -> ID_LI .)
    SLE             reduce using rule 57 (exp_assignment -> ID_LI .)
    SGE             reduce using rule 57 (exp_assignment -> ID_LI .)
    RPAREN          reduce using rule 57 (exp_assignment -> ID_LI .)
    SEMICOLON       reduce using rule 57 (exp_assignment -> ID_LI .)
    XOR             reduce using rule 57 (exp_assignment -> ID_LI .)
    TIMES           reduce using rule 57 (exp_assignment -> ID_LI .)
    DIVIDE          reduce using rule 57 (exp_assignment -> ID_LI .)
    MODULO          reduce using rule 57 (exp_assignment -> ID_LI .)
    PLUS            reduce using rule 57 (exp_assignment -> ID_LI .)
    MINUS           reduce using rule 57 (exp_assignment -> ID_LI .)
    COMMA           reduce using rule 57 (exp_assignment -> ID_LI .)


state 21

    (58) exp_assignment -> INCREMENT . ID_SC

    ID_SC           shift and go to state 59


state 22

    (59) exp_assignment -> DECREMENT . ID_SC

    ID_SC           shift and go to state 60


state 23

    (25) for -> FOR . LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE

    LPAREN          shift and go to state 61


state 24

    (28) dowhile -> DO . LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN

    LBRACE          shift and go to state 62


state 25

    (1) init -> blockcode init .

    $end            reduce using rule 1 (init -> blockcode init .)


state 26

    (2) init -> function init .

    $end            reduce using rule 2 (init -> function init .)


state 27

    (6) blockcode -> command blockcode .

    SUB             reduce using rule 6 (blockcode -> command blockcode .)
    RETURN          reduce using rule 6 (blockcode -> command blockcode .)
    BREAK           reduce using rule 6 (blockcode -> command blockcode .)
    CONTINUE        reduce using rule 6 (blockcode -> command blockcode .)
    IF              reduce using rule 6 (blockcode -> command blockcode .)
    ID_SC           reduce using rule 6 (blockcode -> command blockcode .)
    ID_LI           reduce using rule 6 (blockcode -> command blockcode .)
    INCREMENT       reduce using rule 6 (blockcode -> command blockcode .)
    DECREMENT       reduce using rule 6 (blockcode -> command blockcode .)
    ID              reduce using rule 6 (blockcode -> command blockcode .)
    FOR             reduce using rule 6 (blockcode -> command blockcode .)
    DO              reduce using rule 6 (blockcode -> command blockcode .)
    LPAREN          reduce using rule 6 (blockcode -> command blockcode .)
    $end            reduce using rule 6 (blockcode -> command blockcode .)
    RBRACE          reduce using rule 6 (blockcode -> command blockcode .)


state 28

    (15) if -> command IF . LPAREN exp_condition RPAREN
    (14) if -> IF . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (16) if -> IF . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if -> IF . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif

    LPAREN          shift and go to state 63


state 29

    (30) function -> SUB ID . LPAREN RPAREN LBRACE blockcode RBRACE
    (31) function -> SUB ID . LPAREN function_assignments RPAREN LBRACE blockcode RBRACE

    LPAREN          shift and go to state 64


state 30

    (82) call -> ID LPAREN . RPAREN
    (83) call -> ID LPAREN . function_assignments RPAREN
    (32) function_assignments -> . exp_assignment
    (33) function_assignments -> . exp_assignment COMMA function_assignments
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT

    RPAREN          shift and go to state 65
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22

    function_assignments           shift and go to state 66
    exp_assignment                 shift and go to state 67

state 31

    (41) exp_condition -> LPAREN . exp_condition RPAREN logic exp_condition_logic
    (34) exp_condition -> . attcond GT attcond
    (35) exp_condition -> . attcond LT attcond
    (36) exp_condition -> . attcond EQ attcond
    (37) exp_condition -> . attcond GE attcond
    (38) exp_condition -> . attcond LE attcond
    (39) exp_condition -> . attcond NE attcond
    (40) exp_condition -> . attcond
    (41) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (42) exp_condition -> . attcond CMP attcond
    (43) exp_condition -> . attcond SEQ attcond
    (44) exp_condition -> . attcond SNE attcond
    (45) exp_condition -> . attcond SLT attcond
    (46) exp_condition -> . attcond SGT attcond
    (47) exp_condition -> . attcond SLE attcond
    (48) exp_condition -> . attcond SGE attcond
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE

    LPAREN          shift and go to state 31
    NUMBER          shift and go to state 35
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    exp_condition                  shift and go to state 68
    attcond                        shift and go to state 33
    exp_assignment                 shift and go to state 34
    true                           shift and go to state 36
    false                          shift and go to state 37

state 32

    (29) while -> LPAREN exp_condition . RPAREN LBRACE blockcode RBRACE

    RPAREN          shift and go to state 69


state 33

    (34) exp_condition -> attcond . GT attcond
    (35) exp_condition -> attcond . LT attcond
    (36) exp_condition -> attcond . EQ attcond
    (37) exp_condition -> attcond . GE attcond
    (38) exp_condition -> attcond . LE attcond
    (39) exp_condition -> attcond . NE attcond
    (40) exp_condition -> attcond .
    (42) exp_condition -> attcond . CMP attcond
    (43) exp_condition -> attcond . SEQ attcond
    (44) exp_condition -> attcond . SNE attcond
    (45) exp_condition -> attcond . SLT attcond
    (46) exp_condition -> attcond . SGT attcond
    (47) exp_condition -> attcond . SLE attcond
    (48) exp_condition -> attcond . SGE attcond

  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for CMP resolved as shift
  ! shift/reduce conflict for SEQ resolved as shift
  ! shift/reduce conflict for SNE resolved as shift
  ! shift/reduce conflict for SLT resolved as shift
  ! shift/reduce conflict for SGT resolved as shift
  ! shift/reduce conflict for SLE resolved as shift
  ! shift/reduce conflict for SGE resolved as shift
    GT              shift and go to state 70
    LT              shift and go to state 71
    EQ              shift and go to state 72
    GE              shift and go to state 73
    LE              shift and go to state 74
    NE              shift and go to state 75
    RPAREN          reduce using rule 40 (exp_condition -> attcond .)
    XOR             reduce using rule 40 (exp_condition -> attcond .)
    TIMES           reduce using rule 40 (exp_condition -> attcond .)
    DIVIDE          reduce using rule 40 (exp_condition -> attcond .)
    MODULO          reduce using rule 40 (exp_condition -> attcond .)
    PLUS            reduce using rule 40 (exp_condition -> attcond .)
    MINUS           reduce using rule 40 (exp_condition -> attcond .)
    IF              reduce using rule 40 (exp_condition -> attcond .)
    RETURN          reduce using rule 40 (exp_condition -> attcond .)
    BREAK           reduce using rule 40 (exp_condition -> attcond .)
    CONTINUE        reduce using rule 40 (exp_condition -> attcond .)
    ID_SC           reduce using rule 40 (exp_condition -> attcond .)
    ID_LI           reduce using rule 40 (exp_condition -> attcond .)
    INCREMENT       reduce using rule 40 (exp_condition -> attcond .)
    DECREMENT       reduce using rule 40 (exp_condition -> attcond .)
    ID              reduce using rule 40 (exp_condition -> attcond .)
    FOR             reduce using rule 40 (exp_condition -> attcond .)
    DO              reduce using rule 40 (exp_condition -> attcond .)
    LPAREN          reduce using rule 40 (exp_condition -> attcond .)
    SUB             reduce using rule 40 (exp_condition -> attcond .)
    $end            reduce using rule 40 (exp_condition -> attcond .)
    RBRACE          reduce using rule 40 (exp_condition -> attcond .)
    SEMICOLON       reduce using rule 40 (exp_condition -> attcond .)
    COMMA           reduce using rule 40 (exp_condition -> attcond .)
    CMP             shift and go to state 76
    SEQ             shift and go to state 77
    SNE             shift and go to state 78
    SLT             shift and go to state 79
    SGT             shift and go to state 80
    SLE             shift and go to state 81
    SGE             shift and go to state 82

  ! GT              [ reduce using rule 40 (exp_condition -> attcond .) ]
  ! LT              [ reduce using rule 40 (exp_condition -> attcond .) ]
  ! EQ              [ reduce using rule 40 (exp_condition -> attcond .) ]
  ! GE              [ reduce using rule 40 (exp_condition -> attcond .) ]
  ! LE              [ reduce using rule 40 (exp_condition -> attcond .) ]
  ! NE              [ reduce using rule 40 (exp_condition -> attcond .) ]
  ! CMP             [ reduce using rule 40 (exp_condition -> attcond .) ]
  ! SEQ             [ reduce using rule 40 (exp_condition -> attcond .) ]
  ! SNE             [ reduce using rule 40 (exp_condition -> attcond .) ]
  ! SLT             [ reduce using rule 40 (exp_condition -> attcond .) ]
  ! SGT             [ reduce using rule 40 (exp_condition -> attcond .) ]
  ! SLE             [ reduce using rule 40 (exp_condition -> attcond .) ]
  ! SGE             [ reduce using rule 40 (exp_condition -> attcond .) ]


state 34

    (78) attcond -> exp_assignment .

    GT              reduce using rule 78 (attcond -> exp_assignment .)
    LT              reduce using rule 78 (attcond -> exp_assignment .)
    EQ              reduce using rule 78 (attcond -> exp_assignment .)
    GE              reduce using rule 78 (attcond -> exp_assignment .)
    LE              reduce using rule 78 (attcond -> exp_assignment .)
    NE              reduce using rule 78 (attcond -> exp_assignment .)
    CMP             reduce using rule 78 (attcond -> exp_assignment .)
    SEQ             reduce using rule 78 (attcond -> exp_assignment .)
    SNE             reduce using rule 78 (attcond -> exp_assignment .)
    SLT             reduce using rule 78 (attcond -> exp_assignment .)
    SGT             reduce using rule 78 (attcond -> exp_assignment .)
    SLE             reduce using rule 78 (attcond -> exp_assignment .)
    SGE             reduce using rule 78 (attcond -> exp_assignment .)
    RPAREN          reduce using rule 78 (attcond -> exp_assignment .)
    IF              reduce using rule 78 (attcond -> exp_assignment .)
    RETURN          reduce using rule 78 (attcond -> exp_assignment .)
    BREAK           reduce using rule 78 (attcond -> exp_assignment .)
    CONTINUE        reduce using rule 78 (attcond -> exp_assignment .)
    ID_SC           reduce using rule 78 (attcond -> exp_assignment .)
    ID_LI           reduce using rule 78 (attcond -> exp_assignment .)
    INCREMENT       reduce using rule 78 (attcond -> exp_assignment .)
    DECREMENT       reduce using rule 78 (attcond -> exp_assignment .)
    ID              reduce using rule 78 (attcond -> exp_assignment .)
    FOR             reduce using rule 78 (attcond -> exp_assignment .)
    DO              reduce using rule 78 (attcond -> exp_assignment .)
    LPAREN          reduce using rule 78 (attcond -> exp_assignment .)
    SUB             reduce using rule 78 (attcond -> exp_assignment .)
    $end            reduce using rule 78 (attcond -> exp_assignment .)
    RBRACE          reduce using rule 78 (attcond -> exp_assignment .)
    SEMICOLON       reduce using rule 78 (attcond -> exp_assignment .)
    XOR             reduce using rule 78 (attcond -> exp_assignment .)
    TIMES           reduce using rule 78 (attcond -> exp_assignment .)
    DIVIDE          reduce using rule 78 (attcond -> exp_assignment .)
    MODULO          reduce using rule 78 (attcond -> exp_assignment .)
    PLUS            reduce using rule 78 (attcond -> exp_assignment .)
    MINUS           reduce using rule 78 (attcond -> exp_assignment .)
    COMMA           reduce using rule 78 (attcond -> exp_assignment .)


state 35

    (79) attcond -> NUMBER .

    GT              reduce using rule 79 (attcond -> NUMBER .)
    LT              reduce using rule 79 (attcond -> NUMBER .)
    EQ              reduce using rule 79 (attcond -> NUMBER .)
    GE              reduce using rule 79 (attcond -> NUMBER .)
    LE              reduce using rule 79 (attcond -> NUMBER .)
    NE              reduce using rule 79 (attcond -> NUMBER .)
    CMP             reduce using rule 79 (attcond -> NUMBER .)
    SEQ             reduce using rule 79 (attcond -> NUMBER .)
    SNE             reduce using rule 79 (attcond -> NUMBER .)
    SLT             reduce using rule 79 (attcond -> NUMBER .)
    SGT             reduce using rule 79 (attcond -> NUMBER .)
    SLE             reduce using rule 79 (attcond -> NUMBER .)
    SGE             reduce using rule 79 (attcond -> NUMBER .)
    RPAREN          reduce using rule 79 (attcond -> NUMBER .)
    IF              reduce using rule 79 (attcond -> NUMBER .)
    RETURN          reduce using rule 79 (attcond -> NUMBER .)
    BREAK           reduce using rule 79 (attcond -> NUMBER .)
    CONTINUE        reduce using rule 79 (attcond -> NUMBER .)
    ID_SC           reduce using rule 79 (attcond -> NUMBER .)
    ID_LI           reduce using rule 79 (attcond -> NUMBER .)
    INCREMENT       reduce using rule 79 (attcond -> NUMBER .)
    DECREMENT       reduce using rule 79 (attcond -> NUMBER .)
    ID              reduce using rule 79 (attcond -> NUMBER .)
    FOR             reduce using rule 79 (attcond -> NUMBER .)
    DO              reduce using rule 79 (attcond -> NUMBER .)
    LPAREN          reduce using rule 79 (attcond -> NUMBER .)
    SUB             reduce using rule 79 (attcond -> NUMBER .)
    $end            reduce using rule 79 (attcond -> NUMBER .)
    RBRACE          reduce using rule 79 (attcond -> NUMBER .)
    SEMICOLON       reduce using rule 79 (attcond -> NUMBER .)
    XOR             reduce using rule 79 (attcond -> NUMBER .)
    TIMES           reduce using rule 79 (attcond -> NUMBER .)
    DIVIDE          reduce using rule 79 (attcond -> NUMBER .)
    MODULO          reduce using rule 79 (attcond -> NUMBER .)
    PLUS            reduce using rule 79 (attcond -> NUMBER .)
    MINUS           reduce using rule 79 (attcond -> NUMBER .)
    COMMA           reduce using rule 79 (attcond -> NUMBER .)


state 36

    (80) attcond -> true .

    GT              reduce using rule 80 (attcond -> true .)
    LT              reduce using rule 80 (attcond -> true .)
    EQ              reduce using rule 80 (attcond -> true .)
    GE              reduce using rule 80 (attcond -> true .)
    LE              reduce using rule 80 (attcond -> true .)
    NE              reduce using rule 80 (attcond -> true .)
    CMP             reduce using rule 80 (attcond -> true .)
    SEQ             reduce using rule 80 (attcond -> true .)
    SNE             reduce using rule 80 (attcond -> true .)
    SLT             reduce using rule 80 (attcond -> true .)
    SGT             reduce using rule 80 (attcond -> true .)
    SLE             reduce using rule 80 (attcond -> true .)
    SGE             reduce using rule 80 (attcond -> true .)
    RPAREN          reduce using rule 80 (attcond -> true .)
    SEMICOLON       reduce using rule 80 (attcond -> true .)
    XOR             reduce using rule 80 (attcond -> true .)
    TIMES           reduce using rule 80 (attcond -> true .)
    DIVIDE          reduce using rule 80 (attcond -> true .)
    MODULO          reduce using rule 80 (attcond -> true .)
    PLUS            reduce using rule 80 (attcond -> true .)
    MINUS           reduce using rule 80 (attcond -> true .)
    IF              reduce using rule 80 (attcond -> true .)
    RETURN          reduce using rule 80 (attcond -> true .)
    BREAK           reduce using rule 80 (attcond -> true .)
    CONTINUE        reduce using rule 80 (attcond -> true .)
    ID_SC           reduce using rule 80 (attcond -> true .)
    ID_LI           reduce using rule 80 (attcond -> true .)
    INCREMENT       reduce using rule 80 (attcond -> true .)
    DECREMENT       reduce using rule 80 (attcond -> true .)
    ID              reduce using rule 80 (attcond -> true .)
    FOR             reduce using rule 80 (attcond -> true .)
    DO              reduce using rule 80 (attcond -> true .)
    LPAREN          reduce using rule 80 (attcond -> true .)
    SUB             reduce using rule 80 (attcond -> true .)
    $end            reduce using rule 80 (attcond -> true .)
    RBRACE          reduce using rule 80 (attcond -> true .)
    COMMA           reduce using rule 80 (attcond -> true .)


state 37

    (81) attcond -> false .

    GT              reduce using rule 81 (attcond -> false .)
    LT              reduce using rule 81 (attcond -> false .)
    EQ              reduce using rule 81 (attcond -> false .)
    GE              reduce using rule 81 (attcond -> false .)
    LE              reduce using rule 81 (attcond -> false .)
    NE              reduce using rule 81 (attcond -> false .)
    CMP             reduce using rule 81 (attcond -> false .)
    SEQ             reduce using rule 81 (attcond -> false .)
    SNE             reduce using rule 81 (attcond -> false .)
    SLT             reduce using rule 81 (attcond -> false .)
    SGT             reduce using rule 81 (attcond -> false .)
    SLE             reduce using rule 81 (attcond -> false .)
    SGE             reduce using rule 81 (attcond -> false .)
    RPAREN          reduce using rule 81 (attcond -> false .)
    SEMICOLON       reduce using rule 81 (attcond -> false .)
    XOR             reduce using rule 81 (attcond -> false .)
    TIMES           reduce using rule 81 (attcond -> false .)
    DIVIDE          reduce using rule 81 (attcond -> false .)
    MODULO          reduce using rule 81 (attcond -> false .)
    PLUS            reduce using rule 81 (attcond -> false .)
    MINUS           reduce using rule 81 (attcond -> false .)
    IF              reduce using rule 81 (attcond -> false .)
    RETURN          reduce using rule 81 (attcond -> false .)
    BREAK           reduce using rule 81 (attcond -> false .)
    CONTINUE        reduce using rule 81 (attcond -> false .)
    ID_SC           reduce using rule 81 (attcond -> false .)
    ID_LI           reduce using rule 81 (attcond -> false .)
    INCREMENT       reduce using rule 81 (attcond -> false .)
    DECREMENT       reduce using rule 81 (attcond -> false .)
    ID              reduce using rule 81 (attcond -> false .)
    FOR             reduce using rule 81 (attcond -> false .)
    DO              reduce using rule 81 (attcond -> false .)
    LPAREN          reduce using rule 81 (attcond -> false .)
    SUB             reduce using rule 81 (attcond -> false .)
    $end            reduce using rule 81 (attcond -> false .)
    RBRACE          reduce using rule 81 (attcond -> false .)
    COMMA           reduce using rule 81 (attcond -> false .)


state 38

    (86) true -> TRUE .

    GT              reduce using rule 86 (true -> TRUE .)
    LT              reduce using rule 86 (true -> TRUE .)
    EQ              reduce using rule 86 (true -> TRUE .)
    GE              reduce using rule 86 (true -> TRUE .)
    LE              reduce using rule 86 (true -> TRUE .)
    NE              reduce using rule 86 (true -> TRUE .)
    CMP             reduce using rule 86 (true -> TRUE .)
    SEQ             reduce using rule 86 (true -> TRUE .)
    SNE             reduce using rule 86 (true -> TRUE .)
    SLT             reduce using rule 86 (true -> TRUE .)
    SGT             reduce using rule 86 (true -> TRUE .)
    SLE             reduce using rule 86 (true -> TRUE .)
    SGE             reduce using rule 86 (true -> TRUE .)
    RPAREN          reduce using rule 86 (true -> TRUE .)
    SEMICOLON       reduce using rule 86 (true -> TRUE .)
    XOR             reduce using rule 86 (true -> TRUE .)
    TIMES           reduce using rule 86 (true -> TRUE .)
    DIVIDE          reduce using rule 86 (true -> TRUE .)
    MODULO          reduce using rule 86 (true -> TRUE .)
    PLUS            reduce using rule 86 (true -> TRUE .)
    MINUS           reduce using rule 86 (true -> TRUE .)
    IF              reduce using rule 86 (true -> TRUE .)
    RETURN          reduce using rule 86 (true -> TRUE .)
    BREAK           reduce using rule 86 (true -> TRUE .)
    CONTINUE        reduce using rule 86 (true -> TRUE .)
    ID_SC           reduce using rule 86 (true -> TRUE .)
    ID_LI           reduce using rule 86 (true -> TRUE .)
    INCREMENT       reduce using rule 86 (true -> TRUE .)
    DECREMENT       reduce using rule 86 (true -> TRUE .)
    ID              reduce using rule 86 (true -> TRUE .)
    FOR             reduce using rule 86 (true -> TRUE .)
    DO              reduce using rule 86 (true -> TRUE .)
    LPAREN          reduce using rule 86 (true -> TRUE .)
    SUB             reduce using rule 86 (true -> TRUE .)
    $end            reduce using rule 86 (true -> TRUE .)
    RBRACE          reduce using rule 86 (true -> TRUE .)
    COMMA           reduce using rule 86 (true -> TRUE .)


state 39

    (87) false -> FALSE .

    GT              reduce using rule 87 (false -> FALSE .)
    LT              reduce using rule 87 (false -> FALSE .)
    EQ              reduce using rule 87 (false -> FALSE .)
    GE              reduce using rule 87 (false -> FALSE .)
    LE              reduce using rule 87 (false -> FALSE .)
    NE              reduce using rule 87 (false -> FALSE .)
    CMP             reduce using rule 87 (false -> FALSE .)
    SEQ             reduce using rule 87 (false -> FALSE .)
    SNE             reduce using rule 87 (false -> FALSE .)
    SLT             reduce using rule 87 (false -> FALSE .)
    SGT             reduce using rule 87 (false -> FALSE .)
    SLE             reduce using rule 87 (false -> FALSE .)
    SGE             reduce using rule 87 (false -> FALSE .)
    RPAREN          reduce using rule 87 (false -> FALSE .)
    SEMICOLON       reduce using rule 87 (false -> FALSE .)
    XOR             reduce using rule 87 (false -> FALSE .)
    TIMES           reduce using rule 87 (false -> FALSE .)
    DIVIDE          reduce using rule 87 (false -> FALSE .)
    MODULO          reduce using rule 87 (false -> FALSE .)
    PLUS            reduce using rule 87 (false -> FALSE .)
    MINUS           reduce using rule 87 (false -> FALSE .)
    IF              reduce using rule 87 (false -> FALSE .)
    RETURN          reduce using rule 87 (false -> FALSE .)
    BREAK           reduce using rule 87 (false -> FALSE .)
    CONTINUE        reduce using rule 87 (false -> FALSE .)
    ID_SC           reduce using rule 87 (false -> FALSE .)
    ID_LI           reduce using rule 87 (false -> FALSE .)
    INCREMENT       reduce using rule 87 (false -> FALSE .)
    DECREMENT       reduce using rule 87 (false -> FALSE .)
    ID              reduce using rule 87 (false -> FALSE .)
    FOR             reduce using rule 87 (false -> FALSE .)
    DO              reduce using rule 87 (false -> FALSE .)
    LPAREN          reduce using rule 87 (false -> FALSE .)
    SUB             reduce using rule 87 (false -> FALSE .)
    $end            reduce using rule 87 (false -> FALSE .)
    RBRACE          reduce using rule 87 (false -> FALSE .)
    COMMA           reduce using rule 87 (false -> FALSE .)


state 40

    (11) command -> RETURN return . SEMICOLON

    SEMICOLON       shift and go to state 83


state 41

    (84) return -> attcond .
    (34) exp_condition -> attcond . GT attcond
    (35) exp_condition -> attcond . LT attcond
    (36) exp_condition -> attcond . EQ attcond
    (37) exp_condition -> attcond . GE attcond
    (38) exp_condition -> attcond . LE attcond
    (39) exp_condition -> attcond . NE attcond
    (40) exp_condition -> attcond .
    (42) exp_condition -> attcond . CMP attcond
    (43) exp_condition -> attcond . SEQ attcond
    (44) exp_condition -> attcond . SNE attcond
    (45) exp_condition -> attcond . SLT attcond
    (46) exp_condition -> attcond . SGT attcond
    (47) exp_condition -> attcond . SLE attcond
    (48) exp_condition -> attcond . SGE attcond

  ! reduce/reduce conflict for SEMICOLON resolved using rule 40 (exp_condition -> attcond .)
    GT              shift and go to state 70
    LT              shift and go to state 71
    EQ              shift and go to state 72
    GE              shift and go to state 73
    LE              shift and go to state 74
    NE              shift and go to state 75
    XOR             reduce using rule 40 (exp_condition -> attcond .)
    TIMES           reduce using rule 40 (exp_condition -> attcond .)
    DIVIDE          reduce using rule 40 (exp_condition -> attcond .)
    MODULO          reduce using rule 40 (exp_condition -> attcond .)
    PLUS            reduce using rule 40 (exp_condition -> attcond .)
    MINUS           reduce using rule 40 (exp_condition -> attcond .)
    SEMICOLON       reduce using rule 40 (exp_condition -> attcond .)
    CMP             shift and go to state 76
    SEQ             shift and go to state 77
    SNE             shift and go to state 78
    SLT             shift and go to state 79
    SGT             shift and go to state 80
    SLE             shift and go to state 81
    SGE             shift and go to state 82

  ! SEMICOLON       [ reduce using rule 84 (return -> attcond .) ]


state 42

    (85) return -> arithmetic .

    SEMICOLON       reduce using rule 85 (return -> arithmetic .)


state 43

    (78) attcond -> exp_assignment .
    (74) exp3 -> exp_assignment .

  ! reduce/reduce conflict for XOR resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for TIMES resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for MODULO resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for PLUS resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for MINUS resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for RPAREN resolved using rule 74 (exp3 -> exp_assignment .)
    GT              reduce using rule 78 (attcond -> exp_assignment .)
    LT              reduce using rule 78 (attcond -> exp_assignment .)
    EQ              reduce using rule 78 (attcond -> exp_assignment .)
    GE              reduce using rule 78 (attcond -> exp_assignment .)
    LE              reduce using rule 78 (attcond -> exp_assignment .)
    NE              reduce using rule 78 (attcond -> exp_assignment .)
    CMP             reduce using rule 78 (attcond -> exp_assignment .)
    SEQ             reduce using rule 78 (attcond -> exp_assignment .)
    SNE             reduce using rule 78 (attcond -> exp_assignment .)
    SLT             reduce using rule 78 (attcond -> exp_assignment .)
    SGT             reduce using rule 78 (attcond -> exp_assignment .)
    SLE             reduce using rule 78 (attcond -> exp_assignment .)
    SGE             reduce using rule 78 (attcond -> exp_assignment .)
    XOR             reduce using rule 74 (exp3 -> exp_assignment .)
    TIMES           reduce using rule 74 (exp3 -> exp_assignment .)
    DIVIDE          reduce using rule 74 (exp3 -> exp_assignment .)
    MODULO          reduce using rule 74 (exp3 -> exp_assignment .)
    PLUS            reduce using rule 74 (exp3 -> exp_assignment .)
    MINUS           reduce using rule 74 (exp3 -> exp_assignment .)
    SEMICOLON       reduce using rule 74 (exp3 -> exp_assignment .)
    RPAREN          reduce using rule 74 (exp3 -> exp_assignment .)

  ! SEMICOLON       [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! XOR             [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! TIMES           [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! DIVIDE          [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! MODULO          [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! PLUS            [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! MINUS           [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! RPAREN          [ reduce using rule 78 (attcond -> exp_assignment .) ]


state 44

    (79) attcond -> NUMBER .
    (73) exp3 -> NUMBER .

  ! reduce/reduce conflict for XOR resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for TIMES resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for MODULO resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for PLUS resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for MINUS resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 73 (exp3 -> NUMBER .)
    GT              reduce using rule 79 (attcond -> NUMBER .)
    LT              reduce using rule 79 (attcond -> NUMBER .)
    EQ              reduce using rule 79 (attcond -> NUMBER .)
    GE              reduce using rule 79 (attcond -> NUMBER .)
    LE              reduce using rule 79 (attcond -> NUMBER .)
    NE              reduce using rule 79 (attcond -> NUMBER .)
    CMP             reduce using rule 79 (attcond -> NUMBER .)
    SEQ             reduce using rule 79 (attcond -> NUMBER .)
    SNE             reduce using rule 79 (attcond -> NUMBER .)
    SLT             reduce using rule 79 (attcond -> NUMBER .)
    SGT             reduce using rule 79 (attcond -> NUMBER .)
    SLE             reduce using rule 79 (attcond -> NUMBER .)
    SGE             reduce using rule 79 (attcond -> NUMBER .)
    XOR             reduce using rule 73 (exp3 -> NUMBER .)
    TIMES           reduce using rule 73 (exp3 -> NUMBER .)
    DIVIDE          reduce using rule 73 (exp3 -> NUMBER .)
    MODULO          reduce using rule 73 (exp3 -> NUMBER .)
    PLUS            reduce using rule 73 (exp3 -> NUMBER .)
    MINUS           reduce using rule 73 (exp3 -> NUMBER .)
    SEMICOLON       reduce using rule 73 (exp3 -> NUMBER .)
    RPAREN          reduce using rule 73 (exp3 -> NUMBER .)

  ! SEMICOLON       [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! XOR             [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! TIMES           [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! DIVIDE          [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! MODULO          [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! PLUS            [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! MINUS           [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! RPAREN          [ reduce using rule 79 (attcond -> NUMBER .) ]


state 45

    (62) arithmetic -> exp .
    (63) exp -> exp . PLUS exp1
    (64) exp -> exp . MINUS exp1
    (77) exp3 -> exp .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for XOR resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for TIMES resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for MODULO resolved using rule 62 (arithmetic -> exp .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for RPAREN resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for IF resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for RETURN resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for BREAK resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for ID_SC resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for ID_LI resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for INCREMENT resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for DECREMENT resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for ID resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for FOR resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for DO resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for LPAREN resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for SUB resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for $end resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for RBRACE resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for GT resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for LT resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for EQ resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for GE resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for LE resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for NE resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for CMP resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for SEQ resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for SNE resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for SLT resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for SGT resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for SLE resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for SGE resolved using rule 62 (arithmetic -> exp .)
  ! reduce/reduce conflict for COMMA resolved using rule 62 (arithmetic -> exp .)
    SEMICOLON       reduce using rule 62 (arithmetic -> exp .)
    RPAREN          reduce using rule 62 (arithmetic -> exp .)
    IF              reduce using rule 62 (arithmetic -> exp .)
    RETURN          reduce using rule 62 (arithmetic -> exp .)
    BREAK           reduce using rule 62 (arithmetic -> exp .)
    CONTINUE        reduce using rule 62 (arithmetic -> exp .)
    ID_SC           reduce using rule 62 (arithmetic -> exp .)
    ID_LI           reduce using rule 62 (arithmetic -> exp .)
    INCREMENT       reduce using rule 62 (arithmetic -> exp .)
    DECREMENT       reduce using rule 62 (arithmetic -> exp .)
    ID              reduce using rule 62 (arithmetic -> exp .)
    FOR             reduce using rule 62 (arithmetic -> exp .)
    DO              reduce using rule 62 (arithmetic -> exp .)
    LPAREN          reduce using rule 62 (arithmetic -> exp .)
    SUB             reduce using rule 62 (arithmetic -> exp .)
    $end            reduce using rule 62 (arithmetic -> exp .)
    RBRACE          reduce using rule 62 (arithmetic -> exp .)
    GT              reduce using rule 62 (arithmetic -> exp .)
    LT              reduce using rule 62 (arithmetic -> exp .)
    EQ              reduce using rule 62 (arithmetic -> exp .)
    GE              reduce using rule 62 (arithmetic -> exp .)
    LE              reduce using rule 62 (arithmetic -> exp .)
    NE              reduce using rule 62 (arithmetic -> exp .)
    CMP             reduce using rule 62 (arithmetic -> exp .)
    SEQ             reduce using rule 62 (arithmetic -> exp .)
    SNE             reduce using rule 62 (arithmetic -> exp .)
    SLT             reduce using rule 62 (arithmetic -> exp .)
    SGT             reduce using rule 62 (arithmetic -> exp .)
    SLE             reduce using rule 62 (arithmetic -> exp .)
    SGE             reduce using rule 62 (arithmetic -> exp .)
    XOR             reduce using rule 62 (arithmetic -> exp .)
    TIMES           reduce using rule 62 (arithmetic -> exp .)
    DIVIDE          reduce using rule 62 (arithmetic -> exp .)
    MODULO          reduce using rule 62 (arithmetic -> exp .)
    COMMA           reduce using rule 62 (arithmetic -> exp .)
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85

  ! PLUS            [ reduce using rule 62 (arithmetic -> exp .) ]
  ! MINUS           [ reduce using rule 62 (arithmetic -> exp .) ]
  ! XOR             [ reduce using rule 77 (exp3 -> exp .) ]
  ! TIMES           [ reduce using rule 77 (exp3 -> exp .) ]
  ! DIVIDE          [ reduce using rule 77 (exp3 -> exp .) ]
  ! MODULO          [ reduce using rule 77 (exp3 -> exp .) ]
  ! PLUS            [ reduce using rule 77 (exp3 -> exp .) ]
  ! MINUS           [ reduce using rule 77 (exp3 -> exp .) ]
  ! SEMICOLON       [ reduce using rule 77 (exp3 -> exp .) ]
  ! RPAREN          [ reduce using rule 77 (exp3 -> exp .) ]
  ! IF              [ reduce using rule 77 (exp3 -> exp .) ]
  ! RETURN          [ reduce using rule 77 (exp3 -> exp .) ]
  ! BREAK           [ reduce using rule 77 (exp3 -> exp .) ]
  ! CONTINUE        [ reduce using rule 77 (exp3 -> exp .) ]
  ! ID_SC           [ reduce using rule 77 (exp3 -> exp .) ]
  ! ID_LI           [ reduce using rule 77 (exp3 -> exp .) ]
  ! INCREMENT       [ reduce using rule 77 (exp3 -> exp .) ]
  ! DECREMENT       [ reduce using rule 77 (exp3 -> exp .) ]
  ! ID              [ reduce using rule 77 (exp3 -> exp .) ]
  ! FOR             [ reduce using rule 77 (exp3 -> exp .) ]
  ! DO              [ reduce using rule 77 (exp3 -> exp .) ]
  ! LPAREN          [ reduce using rule 77 (exp3 -> exp .) ]
  ! SUB             [ reduce using rule 77 (exp3 -> exp .) ]
  ! $end            [ reduce using rule 77 (exp3 -> exp .) ]
  ! RBRACE          [ reduce using rule 77 (exp3 -> exp .) ]
  ! GT              [ reduce using rule 77 (exp3 -> exp .) ]
  ! LT              [ reduce using rule 77 (exp3 -> exp .) ]
  ! EQ              [ reduce using rule 77 (exp3 -> exp .) ]
  ! GE              [ reduce using rule 77 (exp3 -> exp .) ]
  ! LE              [ reduce using rule 77 (exp3 -> exp .) ]
  ! NE              [ reduce using rule 77 (exp3 -> exp .) ]
  ! CMP             [ reduce using rule 77 (exp3 -> exp .) ]
  ! SEQ             [ reduce using rule 77 (exp3 -> exp .) ]
  ! SNE             [ reduce using rule 77 (exp3 -> exp .) ]
  ! SLT             [ reduce using rule 77 (exp3 -> exp .) ]
  ! SGT             [ reduce using rule 77 (exp3 -> exp .) ]
  ! SLE             [ reduce using rule 77 (exp3 -> exp .) ]
  ! SGE             [ reduce using rule 77 (exp3 -> exp .) ]
  ! COMMA           [ reduce using rule 77 (exp3 -> exp .) ]


state 46

    (65) exp -> exp1 .
    (66) exp1 -> exp1 . TIMES exp2
    (67) exp1 -> exp1 . DIVIDE exp2
    (68) exp1 -> exp1 . MODULO exp2

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
    XOR             reduce using rule 65 (exp -> exp1 .)
    PLUS            reduce using rule 65 (exp -> exp1 .)
    MINUS           reduce using rule 65 (exp -> exp1 .)
    SEMICOLON       reduce using rule 65 (exp -> exp1 .)
    RPAREN          reduce using rule 65 (exp -> exp1 .)
    IF              reduce using rule 65 (exp -> exp1 .)
    RETURN          reduce using rule 65 (exp -> exp1 .)
    BREAK           reduce using rule 65 (exp -> exp1 .)
    CONTINUE        reduce using rule 65 (exp -> exp1 .)
    ID_SC           reduce using rule 65 (exp -> exp1 .)
    ID_LI           reduce using rule 65 (exp -> exp1 .)
    INCREMENT       reduce using rule 65 (exp -> exp1 .)
    DECREMENT       reduce using rule 65 (exp -> exp1 .)
    ID              reduce using rule 65 (exp -> exp1 .)
    FOR             reduce using rule 65 (exp -> exp1 .)
    DO              reduce using rule 65 (exp -> exp1 .)
    LPAREN          reduce using rule 65 (exp -> exp1 .)
    SUB             reduce using rule 65 (exp -> exp1 .)
    $end            reduce using rule 65 (exp -> exp1 .)
    RBRACE          reduce using rule 65 (exp -> exp1 .)
    GT              reduce using rule 65 (exp -> exp1 .)
    LT              reduce using rule 65 (exp -> exp1 .)
    EQ              reduce using rule 65 (exp -> exp1 .)
    GE              reduce using rule 65 (exp -> exp1 .)
    LE              reduce using rule 65 (exp -> exp1 .)
    NE              reduce using rule 65 (exp -> exp1 .)
    CMP             reduce using rule 65 (exp -> exp1 .)
    SEQ             reduce using rule 65 (exp -> exp1 .)
    SNE             reduce using rule 65 (exp -> exp1 .)
    SLT             reduce using rule 65 (exp -> exp1 .)
    SGT             reduce using rule 65 (exp -> exp1 .)
    SLE             reduce using rule 65 (exp -> exp1 .)
    SGE             reduce using rule 65 (exp -> exp1 .)
    COMMA           reduce using rule 65 (exp -> exp1 .)
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULO          shift and go to state 88

  ! TIMES           [ reduce using rule 65 (exp -> exp1 .) ]
  ! DIVIDE          [ reduce using rule 65 (exp -> exp1 .) ]
  ! MODULO          [ reduce using rule 65 (exp -> exp1 .) ]


state 47

    (69) exp1 -> exp2 .

    XOR             reduce using rule 69 (exp1 -> exp2 .)
    TIMES           reduce using rule 69 (exp1 -> exp2 .)
    DIVIDE          reduce using rule 69 (exp1 -> exp2 .)
    MODULO          reduce using rule 69 (exp1 -> exp2 .)
    PLUS            reduce using rule 69 (exp1 -> exp2 .)
    MINUS           reduce using rule 69 (exp1 -> exp2 .)
    SEMICOLON       reduce using rule 69 (exp1 -> exp2 .)
    RPAREN          reduce using rule 69 (exp1 -> exp2 .)
    IF              reduce using rule 69 (exp1 -> exp2 .)
    RETURN          reduce using rule 69 (exp1 -> exp2 .)
    BREAK           reduce using rule 69 (exp1 -> exp2 .)
    CONTINUE        reduce using rule 69 (exp1 -> exp2 .)
    ID_SC           reduce using rule 69 (exp1 -> exp2 .)
    ID_LI           reduce using rule 69 (exp1 -> exp2 .)
    INCREMENT       reduce using rule 69 (exp1 -> exp2 .)
    DECREMENT       reduce using rule 69 (exp1 -> exp2 .)
    ID              reduce using rule 69 (exp1 -> exp2 .)
    FOR             reduce using rule 69 (exp1 -> exp2 .)
    DO              reduce using rule 69 (exp1 -> exp2 .)
    LPAREN          reduce using rule 69 (exp1 -> exp2 .)
    SUB             reduce using rule 69 (exp1 -> exp2 .)
    $end            reduce using rule 69 (exp1 -> exp2 .)
    RBRACE          reduce using rule 69 (exp1 -> exp2 .)
    GT              reduce using rule 69 (exp1 -> exp2 .)
    LT              reduce using rule 69 (exp1 -> exp2 .)
    EQ              reduce using rule 69 (exp1 -> exp2 .)
    GE              reduce using rule 69 (exp1 -> exp2 .)
    LE              reduce using rule 69 (exp1 -> exp2 .)
    NE              reduce using rule 69 (exp1 -> exp2 .)
    CMP             reduce using rule 69 (exp1 -> exp2 .)
    SEQ             reduce using rule 69 (exp1 -> exp2 .)
    SNE             reduce using rule 69 (exp1 -> exp2 .)
    SLT             reduce using rule 69 (exp1 -> exp2 .)
    SGT             reduce using rule 69 (exp1 -> exp2 .)
    SLE             reduce using rule 69 (exp1 -> exp2 .)
    SGE             reduce using rule 69 (exp1 -> exp2 .)
    COMMA           reduce using rule 69 (exp1 -> exp2 .)


state 48

    (70) exp2 -> exp3 . XOR exp2
    (71) exp2 -> exp3 .

  ! shift/reduce conflict for XOR resolved as shift
    XOR             shift and go to state 89
    TIMES           reduce using rule 71 (exp2 -> exp3 .)
    DIVIDE          reduce using rule 71 (exp2 -> exp3 .)
    MODULO          reduce using rule 71 (exp2 -> exp3 .)
    PLUS            reduce using rule 71 (exp2 -> exp3 .)
    MINUS           reduce using rule 71 (exp2 -> exp3 .)
    SEMICOLON       reduce using rule 71 (exp2 -> exp3 .)
    RPAREN          reduce using rule 71 (exp2 -> exp3 .)
    IF              reduce using rule 71 (exp2 -> exp3 .)
    RETURN          reduce using rule 71 (exp2 -> exp3 .)
    BREAK           reduce using rule 71 (exp2 -> exp3 .)
    CONTINUE        reduce using rule 71 (exp2 -> exp3 .)
    ID_SC           reduce using rule 71 (exp2 -> exp3 .)
    ID_LI           reduce using rule 71 (exp2 -> exp3 .)
    INCREMENT       reduce using rule 71 (exp2 -> exp3 .)
    DECREMENT       reduce using rule 71 (exp2 -> exp3 .)
    ID              reduce using rule 71 (exp2 -> exp3 .)
    FOR             reduce using rule 71 (exp2 -> exp3 .)
    DO              reduce using rule 71 (exp2 -> exp3 .)
    LPAREN          reduce using rule 71 (exp2 -> exp3 .)
    SUB             reduce using rule 71 (exp2 -> exp3 .)
    $end            reduce using rule 71 (exp2 -> exp3 .)
    RBRACE          reduce using rule 71 (exp2 -> exp3 .)
    GT              reduce using rule 71 (exp2 -> exp3 .)
    LT              reduce using rule 71 (exp2 -> exp3 .)
    EQ              reduce using rule 71 (exp2 -> exp3 .)
    GE              reduce using rule 71 (exp2 -> exp3 .)
    LE              reduce using rule 71 (exp2 -> exp3 .)
    NE              reduce using rule 71 (exp2 -> exp3 .)
    CMP             reduce using rule 71 (exp2 -> exp3 .)
    SEQ             reduce using rule 71 (exp2 -> exp3 .)
    SNE             reduce using rule 71 (exp2 -> exp3 .)
    SLT             reduce using rule 71 (exp2 -> exp3 .)
    SGT             reduce using rule 71 (exp2 -> exp3 .)
    SLE             reduce using rule 71 (exp2 -> exp3 .)
    SGE             reduce using rule 71 (exp2 -> exp3 .)
    COMMA           reduce using rule 71 (exp2 -> exp3 .)

  ! XOR             [ reduce using rule 71 (exp2 -> exp3 .) ]


state 49

    (72) exp3 -> LPAREN . arithmetic RPAREN
    (41) exp_condition -> LPAREN . exp_condition RPAREN logic exp_condition_logic
    (62) arithmetic -> . exp
    (34) exp_condition -> . attcond GT attcond
    (35) exp_condition -> . attcond LT attcond
    (36) exp_condition -> . attcond EQ attcond
    (37) exp_condition -> . attcond GE attcond
    (38) exp_condition -> . attcond LE attcond
    (39) exp_condition -> . attcond NE attcond
    (40) exp_condition -> . attcond
    (41) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (42) exp_condition -> . attcond CMP attcond
    (43) exp_condition -> . attcond SEQ attcond
    (44) exp_condition -> . attcond SNE attcond
    (45) exp_condition -> . attcond SLT attcond
    (46) exp_condition -> . attcond SGT attcond
    (47) exp_condition -> . attcond SLE attcond
    (48) exp_condition -> . attcond SGE attcond
    (63) exp -> . exp PLUS exp1
    (64) exp -> . exp MINUS exp1
    (65) exp -> . exp1
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (66) exp1 -> . exp1 TIMES exp2
    (67) exp1 -> . exp1 DIVIDE exp2
    (68) exp1 -> . exp1 MODULO exp2
    (69) exp1 -> . exp2
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE
    (70) exp2 -> . exp3 XOR exp2
    (71) exp2 -> . exp3
    (72) exp3 -> . LPAREN arithmetic RPAREN
    (73) exp3 -> . NUMBER
    (74) exp3 -> . exp_assignment
    (75) exp3 -> . exp_condition
    (76) exp3 -> . call
    (77) exp3 -> . exp
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN

    LPAREN          shift and go to state 90
    NUMBER          shift and go to state 44
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39
    ID              shift and go to state 6

    arithmetic                     shift and go to state 91
    exp_condition                  shift and go to state 92
    exp                            shift and go to state 45
    attcond                        shift and go to state 33
    exp1                           shift and go to state 46
    exp_assignment                 shift and go to state 43
    true                           shift and go to state 36
    false                          shift and go to state 37
    exp2                           shift and go to state 47
    exp3                           shift and go to state 48
    call                           shift and go to state 51

state 50

    (75) exp3 -> exp_condition .

    XOR             reduce using rule 75 (exp3 -> exp_condition .)
    TIMES           reduce using rule 75 (exp3 -> exp_condition .)
    DIVIDE          reduce using rule 75 (exp3 -> exp_condition .)
    MODULO          reduce using rule 75 (exp3 -> exp_condition .)
    PLUS            reduce using rule 75 (exp3 -> exp_condition .)
    MINUS           reduce using rule 75 (exp3 -> exp_condition .)
    SEMICOLON       reduce using rule 75 (exp3 -> exp_condition .)
    IF              reduce using rule 75 (exp3 -> exp_condition .)
    RETURN          reduce using rule 75 (exp3 -> exp_condition .)
    BREAK           reduce using rule 75 (exp3 -> exp_condition .)
    CONTINUE        reduce using rule 75 (exp3 -> exp_condition .)
    ID_SC           reduce using rule 75 (exp3 -> exp_condition .)
    ID_LI           reduce using rule 75 (exp3 -> exp_condition .)
    INCREMENT       reduce using rule 75 (exp3 -> exp_condition .)
    DECREMENT       reduce using rule 75 (exp3 -> exp_condition .)
    ID              reduce using rule 75 (exp3 -> exp_condition .)
    FOR             reduce using rule 75 (exp3 -> exp_condition .)
    DO              reduce using rule 75 (exp3 -> exp_condition .)
    LPAREN          reduce using rule 75 (exp3 -> exp_condition .)
    SUB             reduce using rule 75 (exp3 -> exp_condition .)
    $end            reduce using rule 75 (exp3 -> exp_condition .)
    RBRACE          reduce using rule 75 (exp3 -> exp_condition .)
    GT              reduce using rule 75 (exp3 -> exp_condition .)
    LT              reduce using rule 75 (exp3 -> exp_condition .)
    EQ              reduce using rule 75 (exp3 -> exp_condition .)
    GE              reduce using rule 75 (exp3 -> exp_condition .)
    LE              reduce using rule 75 (exp3 -> exp_condition .)
    NE              reduce using rule 75 (exp3 -> exp_condition .)
    CMP             reduce using rule 75 (exp3 -> exp_condition .)
    SEQ             reduce using rule 75 (exp3 -> exp_condition .)
    SNE             reduce using rule 75 (exp3 -> exp_condition .)
    SLT             reduce using rule 75 (exp3 -> exp_condition .)
    SGT             reduce using rule 75 (exp3 -> exp_condition .)
    SLE             reduce using rule 75 (exp3 -> exp_condition .)
    SGE             reduce using rule 75 (exp3 -> exp_condition .)
    RPAREN          reduce using rule 75 (exp3 -> exp_condition .)
    COMMA           reduce using rule 75 (exp3 -> exp_condition .)


state 51

    (76) exp3 -> call .

    XOR             reduce using rule 76 (exp3 -> call .)
    TIMES           reduce using rule 76 (exp3 -> call .)
    DIVIDE          reduce using rule 76 (exp3 -> call .)
    MODULO          reduce using rule 76 (exp3 -> call .)
    PLUS            reduce using rule 76 (exp3 -> call .)
    MINUS           reduce using rule 76 (exp3 -> call .)
    SEMICOLON       reduce using rule 76 (exp3 -> call .)
    RPAREN          reduce using rule 76 (exp3 -> call .)
    IF              reduce using rule 76 (exp3 -> call .)
    RETURN          reduce using rule 76 (exp3 -> call .)
    BREAK           reduce using rule 76 (exp3 -> call .)
    CONTINUE        reduce using rule 76 (exp3 -> call .)
    ID_SC           reduce using rule 76 (exp3 -> call .)
    ID_LI           reduce using rule 76 (exp3 -> call .)
    INCREMENT       reduce using rule 76 (exp3 -> call .)
    DECREMENT       reduce using rule 76 (exp3 -> call .)
    ID              reduce using rule 76 (exp3 -> call .)
    FOR             reduce using rule 76 (exp3 -> call .)
    DO              reduce using rule 76 (exp3 -> call .)
    LPAREN          reduce using rule 76 (exp3 -> call .)
    SUB             reduce using rule 76 (exp3 -> call .)
    $end            reduce using rule 76 (exp3 -> call .)
    RBRACE          reduce using rule 76 (exp3 -> call .)
    GT              reduce using rule 76 (exp3 -> call .)
    LT              reduce using rule 76 (exp3 -> call .)
    EQ              reduce using rule 76 (exp3 -> call .)
    GE              reduce using rule 76 (exp3 -> call .)
    LE              reduce using rule 76 (exp3 -> call .)
    NE              reduce using rule 76 (exp3 -> call .)
    CMP             reduce using rule 76 (exp3 -> call .)
    SEQ             reduce using rule 76 (exp3 -> call .)
    SNE             reduce using rule 76 (exp3 -> call .)
    SLT             reduce using rule 76 (exp3 -> call .)
    SGT             reduce using rule 76 (exp3 -> call .)
    SLE             reduce using rule 76 (exp3 -> call .)
    SGE             reduce using rule 76 (exp3 -> call .)
    COMMA           reduce using rule 76 (exp3 -> call .)


state 52

    (12) command -> BREAK SEMICOLON .

    IF              reduce using rule 12 (command -> BREAK SEMICOLON .)
    RETURN          reduce using rule 12 (command -> BREAK SEMICOLON .)
    BREAK           reduce using rule 12 (command -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 12 (command -> BREAK SEMICOLON .)
    ID_SC           reduce using rule 12 (command -> BREAK SEMICOLON .)
    ID_LI           reduce using rule 12 (command -> BREAK SEMICOLON .)
    INCREMENT       reduce using rule 12 (command -> BREAK SEMICOLON .)
    DECREMENT       reduce using rule 12 (command -> BREAK SEMICOLON .)
    ID              reduce using rule 12 (command -> BREAK SEMICOLON .)
    FOR             reduce using rule 12 (command -> BREAK SEMICOLON .)
    DO              reduce using rule 12 (command -> BREAK SEMICOLON .)
    LPAREN          reduce using rule 12 (command -> BREAK SEMICOLON .)
    SUB             reduce using rule 12 (command -> BREAK SEMICOLON .)
    $end            reduce using rule 12 (command -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 12 (command -> BREAK SEMICOLON .)


state 53

    (13) command -> CONTINUE SEMICOLON .

    IF              reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    ID_SC           reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    ID_LI           reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    INCREMENT       reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    DECREMENT       reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    ID              reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    DO              reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    LPAREN          reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    SUB             reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    $end            reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    RBRACE          reduce using rule 13 (command -> CONTINUE SEMICOLON .)


state 54

    (14) if -> IF LPAREN . exp_condition RPAREN LBRACE blockcode RBRACE
    (16) if -> IF LPAREN . exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if -> IF LPAREN . exp_condition RPAREN LBRACE blockcode RBRACE elsif
    (34) exp_condition -> . attcond GT attcond
    (35) exp_condition -> . attcond LT attcond
    (36) exp_condition -> . attcond EQ attcond
    (37) exp_condition -> . attcond GE attcond
    (38) exp_condition -> . attcond LE attcond
    (39) exp_condition -> . attcond NE attcond
    (40) exp_condition -> . attcond
    (41) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (42) exp_condition -> . attcond CMP attcond
    (43) exp_condition -> . attcond SEQ attcond
    (44) exp_condition -> . attcond SNE attcond
    (45) exp_condition -> . attcond SLT attcond
    (46) exp_condition -> . attcond SGT attcond
    (47) exp_condition -> . attcond SLE attcond
    (48) exp_condition -> . attcond SGE attcond
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE

    LPAREN          shift and go to state 31
    NUMBER          shift and go to state 35
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    exp_condition                  shift and go to state 93
    attcond                        shift and go to state 33
    exp_assignment                 shift and go to state 34
    true                           shift and go to state 36
    false                          shift and go to state 37

state 55

    (54) exp_assignment -> ID_SC EQUALS . arithmetic
    (62) arithmetic -> . exp
    (63) exp -> . exp PLUS exp1
    (64) exp -> . exp MINUS exp1
    (65) exp -> . exp1
    (66) exp1 -> . exp1 TIMES exp2
    (67) exp1 -> . exp1 DIVIDE exp2
    (68) exp1 -> . exp1 MODULO exp2
    (69) exp1 -> . exp2
    (70) exp2 -> . exp3 XOR exp2
    (71) exp2 -> . exp3
    (72) exp3 -> . LPAREN arithmetic RPAREN
    (73) exp3 -> . NUMBER
    (74) exp3 -> . exp_assignment
    (75) exp3 -> . exp_condition
    (76) exp3 -> . call
    (77) exp3 -> . exp
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (34) exp_condition -> . attcond GT attcond
    (35) exp_condition -> . attcond LT attcond
    (36) exp_condition -> . attcond EQ attcond
    (37) exp_condition -> . attcond GE attcond
    (38) exp_condition -> . attcond LE attcond
    (39) exp_condition -> . attcond NE attcond
    (40) exp_condition -> . attcond
    (41) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (42) exp_condition -> . attcond CMP attcond
    (43) exp_condition -> . attcond SEQ attcond
    (44) exp_condition -> . attcond SNE attcond
    (45) exp_condition -> . attcond SLT attcond
    (46) exp_condition -> . attcond SGT attcond
    (47) exp_condition -> . attcond SLE attcond
    (48) exp_condition -> . attcond SGE attcond
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (86) true -> . TRUE
    (87) false -> . FALSE

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 95
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    ID              shift and go to state 6
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    arithmetic                     shift and go to state 94
    exp                            shift and go to state 45
    exp1                           shift and go to state 46
    exp2                           shift and go to state 47
    exp3                           shift and go to state 48
    exp_assignment                 shift and go to state 96
    exp_condition                  shift and go to state 50
    call                           shift and go to state 51
    attcond                        shift and go to state 33
    true                           shift and go to state 36
    false                          shift and go to state 37

state 56

    (60) exp_assignment -> ID_SC INCREMENT .

    IF              reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    RETURN          reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    BREAK           reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    CONTINUE        reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    ID_SC           reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    ID_LI           reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    INCREMENT       reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    DECREMENT       reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    ID              reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    FOR             reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    DO              reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    LPAREN          reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    SUB             reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    $end            reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    RBRACE          reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    GT              reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    LT              reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    EQ              reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    GE              reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    LE              reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    NE              reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    CMP             reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    SEQ             reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    SNE             reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    SLT             reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    SGT             reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    SLE             reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    SGE             reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    RPAREN          reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    SEMICOLON       reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    XOR             reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    TIMES           reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    DIVIDE          reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    MODULO          reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    PLUS            reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    MINUS           reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)
    COMMA           reduce using rule 60 (exp_assignment -> ID_SC INCREMENT .)


state 57

    (61) exp_assignment -> ID_SC DECREMENT .

    IF              reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    RETURN          reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    BREAK           reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    CONTINUE        reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    ID_SC           reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    ID_LI           reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    INCREMENT       reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    DECREMENT       reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    ID              reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    FOR             reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    DO              reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    LPAREN          reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    SUB             reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    $end            reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    RBRACE          reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    GT              reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    LT              reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    EQ              reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    GE              reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    LE              reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    NE              reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    CMP             reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    SEQ             reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    SNE             reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    SLT             reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    SGT             reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    SLE             reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    SGE             reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    RPAREN          reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    SEMICOLON       reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    XOR             reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    TIMES           reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    DIVIDE          reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    MODULO          reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    PLUS            reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    MINUS           reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)
    COMMA           reduce using rule 61 (exp_assignment -> ID_SC DECREMENT .)


state 58

    (55) exp_assignment -> ID_LI EQUALS . arithmetic
    (62) arithmetic -> . exp
    (63) exp -> . exp PLUS exp1
    (64) exp -> . exp MINUS exp1
    (65) exp -> . exp1
    (66) exp1 -> . exp1 TIMES exp2
    (67) exp1 -> . exp1 DIVIDE exp2
    (68) exp1 -> . exp1 MODULO exp2
    (69) exp1 -> . exp2
    (70) exp2 -> . exp3 XOR exp2
    (71) exp2 -> . exp3
    (72) exp3 -> . LPAREN arithmetic RPAREN
    (73) exp3 -> . NUMBER
    (74) exp3 -> . exp_assignment
    (75) exp3 -> . exp_condition
    (76) exp3 -> . call
    (77) exp3 -> . exp
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (34) exp_condition -> . attcond GT attcond
    (35) exp_condition -> . attcond LT attcond
    (36) exp_condition -> . attcond EQ attcond
    (37) exp_condition -> . attcond GE attcond
    (38) exp_condition -> . attcond LE attcond
    (39) exp_condition -> . attcond NE attcond
    (40) exp_condition -> . attcond
    (41) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (42) exp_condition -> . attcond CMP attcond
    (43) exp_condition -> . attcond SEQ attcond
    (44) exp_condition -> . attcond SNE attcond
    (45) exp_condition -> . attcond SLT attcond
    (46) exp_condition -> . attcond SGT attcond
    (47) exp_condition -> . attcond SLE attcond
    (48) exp_condition -> . attcond SGE attcond
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (86) true -> . TRUE
    (87) false -> . FALSE

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 95
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    ID              shift and go to state 6
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    arithmetic                     shift and go to state 97
    exp                            shift and go to state 45
    exp1                           shift and go to state 46
    exp2                           shift and go to state 47
    exp3                           shift and go to state 48
    exp_assignment                 shift and go to state 96
    exp_condition                  shift and go to state 50
    call                           shift and go to state 51
    attcond                        shift and go to state 33
    true                           shift and go to state 36
    false                          shift and go to state 37

state 59

    (58) exp_assignment -> INCREMENT ID_SC .

    IF              reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    RETURN          reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    BREAK           reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    CONTINUE        reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    ID_SC           reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    ID_LI           reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    INCREMENT       reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    DECREMENT       reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    ID              reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    FOR             reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    DO              reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    LPAREN          reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    SUB             reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    $end            reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    RBRACE          reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    GT              reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    LT              reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    EQ              reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    GE              reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    LE              reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    NE              reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    CMP             reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    SEQ             reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    SNE             reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    SLT             reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    SGT             reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    SLE             reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    SGE             reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    RPAREN          reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    SEMICOLON       reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    XOR             reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    TIMES           reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    DIVIDE          reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    MODULO          reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    PLUS            reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    MINUS           reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)
    COMMA           reduce using rule 58 (exp_assignment -> INCREMENT ID_SC .)


state 60

    (59) exp_assignment -> DECREMENT ID_SC .

    IF              reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    RETURN          reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    BREAK           reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    CONTINUE        reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    ID_SC           reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    ID_LI           reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    INCREMENT       reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    DECREMENT       reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    ID              reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    FOR             reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    DO              reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    LPAREN          reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    SUB             reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    $end            reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    RBRACE          reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    GT              reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    LT              reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    EQ              reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    GE              reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    LE              reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    NE              reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    CMP             reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    SEQ             reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    SNE             reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    SLT             reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    SGT             reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    SLE             reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    SGE             reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    RPAREN          reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    SEMICOLON       reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    XOR             reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    TIMES           reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    DIVIDE          reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    MODULO          reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    PLUS            reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    MINUS           reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)
    COMMA           reduce using rule 59 (exp_assignment -> DECREMENT ID_SC .)


state 61

    (25) for -> FOR LPAREN . for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (26) for_assignments -> . exp_assignment
    (27) for_assignments -> . exp_assignment COMMA for_assignments
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT

    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22

    for_assignments                shift and go to state 98
    exp_assignment                 shift and go to state 99

state 62

    (28) dowhile -> DO LBRACE . blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (15) if -> . command IF LPAREN exp_condition RPAREN
    (16) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE

    RETURN          shift and go to state 12
    BREAK           shift and go to state 13
    CONTINUE        shift and go to state 14
    IF              shift and go to state 18
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    ID              shift and go to state 6
    FOR             shift and go to state 23
    DO              shift and go to state 24
    LPAREN          shift and go to state 7

    blockcode                      shift and go to state 100
    command                        shift and go to state 4
    interations                    shift and go to state 8
    if                             shift and go to state 9
    exp_assignment                 shift and go to state 10
    call                           shift and go to state 11
    for                            shift and go to state 15
    dowhile                        shift and go to state 16
    while                          shift and go to state 17

state 63

    (15) if -> command IF LPAREN . exp_condition RPAREN
    (14) if -> IF LPAREN . exp_condition RPAREN LBRACE blockcode RBRACE
    (16) if -> IF LPAREN . exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if -> IF LPAREN . exp_condition RPAREN LBRACE blockcode RBRACE elsif
    (34) exp_condition -> . attcond GT attcond
    (35) exp_condition -> . attcond LT attcond
    (36) exp_condition -> . attcond EQ attcond
    (37) exp_condition -> . attcond GE attcond
    (38) exp_condition -> . attcond LE attcond
    (39) exp_condition -> . attcond NE attcond
    (40) exp_condition -> . attcond
    (41) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (42) exp_condition -> . attcond CMP attcond
    (43) exp_condition -> . attcond SEQ attcond
    (44) exp_condition -> . attcond SNE attcond
    (45) exp_condition -> . attcond SLT attcond
    (46) exp_condition -> . attcond SGT attcond
    (47) exp_condition -> . attcond SLE attcond
    (48) exp_condition -> . attcond SGE attcond
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE

    LPAREN          shift and go to state 31
    NUMBER          shift and go to state 35
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    exp_condition                  shift and go to state 101
    attcond                        shift and go to state 33
    exp_assignment                 shift and go to state 34
    true                           shift and go to state 36
    false                          shift and go to state 37

state 64

    (30) function -> SUB ID LPAREN . RPAREN LBRACE blockcode RBRACE
    (31) function -> SUB ID LPAREN . function_assignments RPAREN LBRACE blockcode RBRACE
    (32) function_assignments -> . exp_assignment
    (33) function_assignments -> . exp_assignment COMMA function_assignments
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT

    RPAREN          shift and go to state 102
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22

    function_assignments           shift and go to state 103
    exp_assignment                 shift and go to state 67

state 65

    (82) call -> ID LPAREN RPAREN .

    IF              reduce using rule 82 (call -> ID LPAREN RPAREN .)
    RETURN          reduce using rule 82 (call -> ID LPAREN RPAREN .)
    BREAK           reduce using rule 82 (call -> ID LPAREN RPAREN .)
    CONTINUE        reduce using rule 82 (call -> ID LPAREN RPAREN .)
    ID_SC           reduce using rule 82 (call -> ID LPAREN RPAREN .)
    ID_LI           reduce using rule 82 (call -> ID LPAREN RPAREN .)
    INCREMENT       reduce using rule 82 (call -> ID LPAREN RPAREN .)
    DECREMENT       reduce using rule 82 (call -> ID LPAREN RPAREN .)
    ID              reduce using rule 82 (call -> ID LPAREN RPAREN .)
    FOR             reduce using rule 82 (call -> ID LPAREN RPAREN .)
    DO              reduce using rule 82 (call -> ID LPAREN RPAREN .)
    LPAREN          reduce using rule 82 (call -> ID LPAREN RPAREN .)
    SUB             reduce using rule 82 (call -> ID LPAREN RPAREN .)
    $end            reduce using rule 82 (call -> ID LPAREN RPAREN .)
    RBRACE          reduce using rule 82 (call -> ID LPAREN RPAREN .)
    XOR             reduce using rule 82 (call -> ID LPAREN RPAREN .)
    TIMES           reduce using rule 82 (call -> ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 82 (call -> ID LPAREN RPAREN .)
    MODULO          reduce using rule 82 (call -> ID LPAREN RPAREN .)
    PLUS            reduce using rule 82 (call -> ID LPAREN RPAREN .)
    MINUS           reduce using rule 82 (call -> ID LPAREN RPAREN .)
    SEMICOLON       reduce using rule 82 (call -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 82 (call -> ID LPAREN RPAREN .)
    GT              reduce using rule 82 (call -> ID LPAREN RPAREN .)
    LT              reduce using rule 82 (call -> ID LPAREN RPAREN .)
    EQ              reduce using rule 82 (call -> ID LPAREN RPAREN .)
    GE              reduce using rule 82 (call -> ID LPAREN RPAREN .)
    LE              reduce using rule 82 (call -> ID LPAREN RPAREN .)
    NE              reduce using rule 82 (call -> ID LPAREN RPAREN .)
    CMP             reduce using rule 82 (call -> ID LPAREN RPAREN .)
    SEQ             reduce using rule 82 (call -> ID LPAREN RPAREN .)
    SNE             reduce using rule 82 (call -> ID LPAREN RPAREN .)
    SLT             reduce using rule 82 (call -> ID LPAREN RPAREN .)
    SGT             reduce using rule 82 (call -> ID LPAREN RPAREN .)
    SLE             reduce using rule 82 (call -> ID LPAREN RPAREN .)
    SGE             reduce using rule 82 (call -> ID LPAREN RPAREN .)
    COMMA           reduce using rule 82 (call -> ID LPAREN RPAREN .)


state 66

    (83) call -> ID LPAREN function_assignments . RPAREN

    RPAREN          shift and go to state 104


state 67

    (32) function_assignments -> exp_assignment .
    (33) function_assignments -> exp_assignment . COMMA function_assignments

    RPAREN          reduce using rule 32 (function_assignments -> exp_assignment .)
    COMMA           shift and go to state 105


state 68

    (41) exp_condition -> LPAREN exp_condition . RPAREN logic exp_condition_logic

    RPAREN          shift and go to state 106


state 69

    (29) while -> LPAREN exp_condition RPAREN . LBRACE blockcode RBRACE

    LBRACE          shift and go to state 107


state 70

    (34) exp_condition -> attcond GT . attcond
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE

    NUMBER          shift and go to state 35
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    attcond                        shift and go to state 108
    exp_assignment                 shift and go to state 34
    true                           shift and go to state 36
    false                          shift and go to state 37

state 71

    (35) exp_condition -> attcond LT . attcond
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE

    NUMBER          shift and go to state 35
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    attcond                        shift and go to state 109
    exp_assignment                 shift and go to state 34
    true                           shift and go to state 36
    false                          shift and go to state 37

state 72

    (36) exp_condition -> attcond EQ . attcond
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE

    NUMBER          shift and go to state 35
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    attcond                        shift and go to state 110
    exp_assignment                 shift and go to state 34
    true                           shift and go to state 36
    false                          shift and go to state 37

state 73

    (37) exp_condition -> attcond GE . attcond
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE

    NUMBER          shift and go to state 35
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    attcond                        shift and go to state 111
    exp_assignment                 shift and go to state 34
    true                           shift and go to state 36
    false                          shift and go to state 37

state 74

    (38) exp_condition -> attcond LE . attcond
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE

    NUMBER          shift and go to state 35
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    attcond                        shift and go to state 112
    exp_assignment                 shift and go to state 34
    true                           shift and go to state 36
    false                          shift and go to state 37

state 75

    (39) exp_condition -> attcond NE . attcond
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE

    NUMBER          shift and go to state 35
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    attcond                        shift and go to state 113
    exp_assignment                 shift and go to state 34
    true                           shift and go to state 36
    false                          shift and go to state 37

state 76

    (42) exp_condition -> attcond CMP . attcond
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE

    NUMBER          shift and go to state 35
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    attcond                        shift and go to state 114
    exp_assignment                 shift and go to state 34
    true                           shift and go to state 36
    false                          shift and go to state 37

state 77

    (43) exp_condition -> attcond SEQ . attcond
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE

    NUMBER          shift and go to state 35
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    attcond                        shift and go to state 115
    exp_assignment                 shift and go to state 34
    true                           shift and go to state 36
    false                          shift and go to state 37

state 78

    (44) exp_condition -> attcond SNE . attcond
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE

    NUMBER          shift and go to state 35
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    attcond                        shift and go to state 116
    exp_assignment                 shift and go to state 34
    true                           shift and go to state 36
    false                          shift and go to state 37

state 79

    (45) exp_condition -> attcond SLT . attcond
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE

    NUMBER          shift and go to state 35
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    attcond                        shift and go to state 117
    exp_assignment                 shift and go to state 34
    true                           shift and go to state 36
    false                          shift and go to state 37

state 80

    (46) exp_condition -> attcond SGT . attcond
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE

    NUMBER          shift and go to state 35
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    attcond                        shift and go to state 118
    exp_assignment                 shift and go to state 34
    true                           shift and go to state 36
    false                          shift and go to state 37

state 81

    (47) exp_condition -> attcond SLE . attcond
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE

    NUMBER          shift and go to state 35
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    attcond                        shift and go to state 119
    exp_assignment                 shift and go to state 34
    true                           shift and go to state 36
    false                          shift and go to state 37

state 82

    (48) exp_condition -> attcond SGE . attcond
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE

    NUMBER          shift and go to state 35
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    attcond                        shift and go to state 120
    exp_assignment                 shift and go to state 34
    true                           shift and go to state 36
    false                          shift and go to state 37

state 83

    (11) command -> RETURN return SEMICOLON .

    IF              reduce using rule 11 (command -> RETURN return SEMICOLON .)
    RETURN          reduce using rule 11 (command -> RETURN return SEMICOLON .)
    BREAK           reduce using rule 11 (command -> RETURN return SEMICOLON .)
    CONTINUE        reduce using rule 11 (command -> RETURN return SEMICOLON .)
    ID_SC           reduce using rule 11 (command -> RETURN return SEMICOLON .)
    ID_LI           reduce using rule 11 (command -> RETURN return SEMICOLON .)
    INCREMENT       reduce using rule 11 (command -> RETURN return SEMICOLON .)
    DECREMENT       reduce using rule 11 (command -> RETURN return SEMICOLON .)
    ID              reduce using rule 11 (command -> RETURN return SEMICOLON .)
    FOR             reduce using rule 11 (command -> RETURN return SEMICOLON .)
    DO              reduce using rule 11 (command -> RETURN return SEMICOLON .)
    LPAREN          reduce using rule 11 (command -> RETURN return SEMICOLON .)
    SUB             reduce using rule 11 (command -> RETURN return SEMICOLON .)
    $end            reduce using rule 11 (command -> RETURN return SEMICOLON .)
    RBRACE          reduce using rule 11 (command -> RETURN return SEMICOLON .)


state 84

    (63) exp -> exp PLUS . exp1
    (66) exp1 -> . exp1 TIMES exp2
    (67) exp1 -> . exp1 DIVIDE exp2
    (68) exp1 -> . exp1 MODULO exp2
    (69) exp1 -> . exp2
    (70) exp2 -> . exp3 XOR exp2
    (71) exp2 -> . exp3
    (72) exp3 -> . LPAREN arithmetic RPAREN
    (73) exp3 -> . NUMBER
    (74) exp3 -> . exp_assignment
    (75) exp3 -> . exp_condition
    (76) exp3 -> . call
    (77) exp3 -> . exp
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (34) exp_condition -> . attcond GT attcond
    (35) exp_condition -> . attcond LT attcond
    (36) exp_condition -> . attcond EQ attcond
    (37) exp_condition -> . attcond GE attcond
    (38) exp_condition -> . attcond LE attcond
    (39) exp_condition -> . attcond NE attcond
    (40) exp_condition -> . attcond
    (41) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (42) exp_condition -> . attcond CMP attcond
    (43) exp_condition -> . attcond SEQ attcond
    (44) exp_condition -> . attcond SNE attcond
    (45) exp_condition -> . attcond SLT attcond
    (46) exp_condition -> . attcond SGT attcond
    (47) exp_condition -> . attcond SLE attcond
    (48) exp_condition -> . attcond SGE attcond
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN
    (63) exp -> . exp PLUS exp1
    (64) exp -> . exp MINUS exp1
    (65) exp -> . exp1
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (86) true -> . TRUE
    (87) false -> . FALSE

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 95
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    ID              shift and go to state 6
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    exp                            shift and go to state 121
    exp1                           shift and go to state 122
    exp2                           shift and go to state 47
    exp3                           shift and go to state 48
    exp_assignment                 shift and go to state 96
    exp_condition                  shift and go to state 50
    call                           shift and go to state 51
    attcond                        shift and go to state 33
    true                           shift and go to state 36
    false                          shift and go to state 37

state 85

    (64) exp -> exp MINUS . exp1
    (66) exp1 -> . exp1 TIMES exp2
    (67) exp1 -> . exp1 DIVIDE exp2
    (68) exp1 -> . exp1 MODULO exp2
    (69) exp1 -> . exp2
    (70) exp2 -> . exp3 XOR exp2
    (71) exp2 -> . exp3
    (72) exp3 -> . LPAREN arithmetic RPAREN
    (73) exp3 -> . NUMBER
    (74) exp3 -> . exp_assignment
    (75) exp3 -> . exp_condition
    (76) exp3 -> . call
    (77) exp3 -> . exp
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (34) exp_condition -> . attcond GT attcond
    (35) exp_condition -> . attcond LT attcond
    (36) exp_condition -> . attcond EQ attcond
    (37) exp_condition -> . attcond GE attcond
    (38) exp_condition -> . attcond LE attcond
    (39) exp_condition -> . attcond NE attcond
    (40) exp_condition -> . attcond
    (41) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (42) exp_condition -> . attcond CMP attcond
    (43) exp_condition -> . attcond SEQ attcond
    (44) exp_condition -> . attcond SNE attcond
    (45) exp_condition -> . attcond SLT attcond
    (46) exp_condition -> . attcond SGT attcond
    (47) exp_condition -> . attcond SLE attcond
    (48) exp_condition -> . attcond SGE attcond
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN
    (63) exp -> . exp PLUS exp1
    (64) exp -> . exp MINUS exp1
    (65) exp -> . exp1
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (86) true -> . TRUE
    (87) false -> . FALSE

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 95
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    ID              shift and go to state 6
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    exp                            shift and go to state 121
    exp1                           shift and go to state 123
    exp2                           shift and go to state 47
    exp3                           shift and go to state 48
    exp_assignment                 shift and go to state 96
    exp_condition                  shift and go to state 50
    call                           shift and go to state 51
    attcond                        shift and go to state 33
    true                           shift and go to state 36
    false                          shift and go to state 37

state 86

    (66) exp1 -> exp1 TIMES . exp2
    (70) exp2 -> . exp3 XOR exp2
    (71) exp2 -> . exp3
    (72) exp3 -> . LPAREN arithmetic RPAREN
    (73) exp3 -> . NUMBER
    (74) exp3 -> . exp_assignment
    (75) exp3 -> . exp_condition
    (76) exp3 -> . call
    (77) exp3 -> . exp
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (34) exp_condition -> . attcond GT attcond
    (35) exp_condition -> . attcond LT attcond
    (36) exp_condition -> . attcond EQ attcond
    (37) exp_condition -> . attcond GE attcond
    (38) exp_condition -> . attcond LE attcond
    (39) exp_condition -> . attcond NE attcond
    (40) exp_condition -> . attcond
    (41) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (42) exp_condition -> . attcond CMP attcond
    (43) exp_condition -> . attcond SEQ attcond
    (44) exp_condition -> . attcond SNE attcond
    (45) exp_condition -> . attcond SLT attcond
    (46) exp_condition -> . attcond SGT attcond
    (47) exp_condition -> . attcond SLE attcond
    (48) exp_condition -> . attcond SGE attcond
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN
    (63) exp -> . exp PLUS exp1
    (64) exp -> . exp MINUS exp1
    (65) exp -> . exp1
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (66) exp1 -> . exp1 TIMES exp2
    (67) exp1 -> . exp1 DIVIDE exp2
    (68) exp1 -> . exp1 MODULO exp2
    (69) exp1 -> . exp2
    (86) true -> . TRUE
    (87) false -> . FALSE

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 95
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    ID              shift and go to state 6
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    exp1                           shift and go to state 46
    exp2                           shift and go to state 124
    exp3                           shift and go to state 48
    exp_assignment                 shift and go to state 96
    exp_condition                  shift and go to state 50
    call                           shift and go to state 51
    exp                            shift and go to state 121
    attcond                        shift and go to state 33
    true                           shift and go to state 36
    false                          shift and go to state 37

state 87

    (67) exp1 -> exp1 DIVIDE . exp2
    (70) exp2 -> . exp3 XOR exp2
    (71) exp2 -> . exp3
    (72) exp3 -> . LPAREN arithmetic RPAREN
    (73) exp3 -> . NUMBER
    (74) exp3 -> . exp_assignment
    (75) exp3 -> . exp_condition
    (76) exp3 -> . call
    (77) exp3 -> . exp
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (34) exp_condition -> . attcond GT attcond
    (35) exp_condition -> . attcond LT attcond
    (36) exp_condition -> . attcond EQ attcond
    (37) exp_condition -> . attcond GE attcond
    (38) exp_condition -> . attcond LE attcond
    (39) exp_condition -> . attcond NE attcond
    (40) exp_condition -> . attcond
    (41) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (42) exp_condition -> . attcond CMP attcond
    (43) exp_condition -> . attcond SEQ attcond
    (44) exp_condition -> . attcond SNE attcond
    (45) exp_condition -> . attcond SLT attcond
    (46) exp_condition -> . attcond SGT attcond
    (47) exp_condition -> . attcond SLE attcond
    (48) exp_condition -> . attcond SGE attcond
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN
    (63) exp -> . exp PLUS exp1
    (64) exp -> . exp MINUS exp1
    (65) exp -> . exp1
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (66) exp1 -> . exp1 TIMES exp2
    (67) exp1 -> . exp1 DIVIDE exp2
    (68) exp1 -> . exp1 MODULO exp2
    (69) exp1 -> . exp2
    (86) true -> . TRUE
    (87) false -> . FALSE

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 95
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    ID              shift and go to state 6
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    exp1                           shift and go to state 46
    exp2                           shift and go to state 125
    exp3                           shift and go to state 48
    exp_assignment                 shift and go to state 96
    exp_condition                  shift and go to state 50
    call                           shift and go to state 51
    exp                            shift and go to state 121
    attcond                        shift and go to state 33
    true                           shift and go to state 36
    false                          shift and go to state 37

state 88

    (68) exp1 -> exp1 MODULO . exp2
    (70) exp2 -> . exp3 XOR exp2
    (71) exp2 -> . exp3
    (72) exp3 -> . LPAREN arithmetic RPAREN
    (73) exp3 -> . NUMBER
    (74) exp3 -> . exp_assignment
    (75) exp3 -> . exp_condition
    (76) exp3 -> . call
    (77) exp3 -> . exp
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (34) exp_condition -> . attcond GT attcond
    (35) exp_condition -> . attcond LT attcond
    (36) exp_condition -> . attcond EQ attcond
    (37) exp_condition -> . attcond GE attcond
    (38) exp_condition -> . attcond LE attcond
    (39) exp_condition -> . attcond NE attcond
    (40) exp_condition -> . attcond
    (41) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (42) exp_condition -> . attcond CMP attcond
    (43) exp_condition -> . attcond SEQ attcond
    (44) exp_condition -> . attcond SNE attcond
    (45) exp_condition -> . attcond SLT attcond
    (46) exp_condition -> . attcond SGT attcond
    (47) exp_condition -> . attcond SLE attcond
    (48) exp_condition -> . attcond SGE attcond
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN
    (63) exp -> . exp PLUS exp1
    (64) exp -> . exp MINUS exp1
    (65) exp -> . exp1
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (66) exp1 -> . exp1 TIMES exp2
    (67) exp1 -> . exp1 DIVIDE exp2
    (68) exp1 -> . exp1 MODULO exp2
    (69) exp1 -> . exp2
    (86) true -> . TRUE
    (87) false -> . FALSE

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 95
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    ID              shift and go to state 6
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    exp1                           shift and go to state 46
    exp2                           shift and go to state 126
    exp3                           shift and go to state 48
    exp_assignment                 shift and go to state 96
    exp_condition                  shift and go to state 50
    call                           shift and go to state 51
    exp                            shift and go to state 121
    attcond                        shift and go to state 33
    true                           shift and go to state 36
    false                          shift and go to state 37

state 89

    (70) exp2 -> exp3 XOR . exp2
    (70) exp2 -> . exp3 XOR exp2
    (71) exp2 -> . exp3
    (72) exp3 -> . LPAREN arithmetic RPAREN
    (73) exp3 -> . NUMBER
    (74) exp3 -> . exp_assignment
    (75) exp3 -> . exp_condition
    (76) exp3 -> . call
    (77) exp3 -> . exp
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (34) exp_condition -> . attcond GT attcond
    (35) exp_condition -> . attcond LT attcond
    (36) exp_condition -> . attcond EQ attcond
    (37) exp_condition -> . attcond GE attcond
    (38) exp_condition -> . attcond LE attcond
    (39) exp_condition -> . attcond NE attcond
    (40) exp_condition -> . attcond
    (41) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (42) exp_condition -> . attcond CMP attcond
    (43) exp_condition -> . attcond SEQ attcond
    (44) exp_condition -> . attcond SNE attcond
    (45) exp_condition -> . attcond SLT attcond
    (46) exp_condition -> . attcond SGT attcond
    (47) exp_condition -> . attcond SLE attcond
    (48) exp_condition -> . attcond SGE attcond
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN
    (63) exp -> . exp PLUS exp1
    (64) exp -> . exp MINUS exp1
    (65) exp -> . exp1
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (66) exp1 -> . exp1 TIMES exp2
    (67) exp1 -> . exp1 DIVIDE exp2
    (68) exp1 -> . exp1 MODULO exp2
    (69) exp1 -> . exp2
    (86) true -> . TRUE
    (87) false -> . FALSE

    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 95
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    ID              shift and go to state 6
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    exp3                           shift and go to state 48
    exp2                           shift and go to state 127
    exp_assignment                 shift and go to state 96
    exp_condition                  shift and go to state 50
    call                           shift and go to state 51
    exp                            shift and go to state 121
    attcond                        shift and go to state 33
    exp1                           shift and go to state 46
    true                           shift and go to state 36
    false                          shift and go to state 37

state 90

    (41) exp_condition -> LPAREN . exp_condition RPAREN logic exp_condition_logic
    (72) exp3 -> LPAREN . arithmetic RPAREN
    (34) exp_condition -> . attcond GT attcond
    (35) exp_condition -> . attcond LT attcond
    (36) exp_condition -> . attcond EQ attcond
    (37) exp_condition -> . attcond GE attcond
    (38) exp_condition -> . attcond LE attcond
    (39) exp_condition -> . attcond NE attcond
    (40) exp_condition -> . attcond
    (41) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (42) exp_condition -> . attcond CMP attcond
    (43) exp_condition -> . attcond SEQ attcond
    (44) exp_condition -> . attcond SNE attcond
    (45) exp_condition -> . attcond SLT attcond
    (46) exp_condition -> . attcond SGT attcond
    (47) exp_condition -> . attcond SLE attcond
    (48) exp_condition -> . attcond SGE attcond
    (62) arithmetic -> . exp
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (63) exp -> . exp PLUS exp1
    (64) exp -> . exp MINUS exp1
    (65) exp -> . exp1
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE
    (66) exp1 -> . exp1 TIMES exp2
    (67) exp1 -> . exp1 DIVIDE exp2
    (68) exp1 -> . exp1 MODULO exp2
    (69) exp1 -> . exp2
    (70) exp2 -> . exp3 XOR exp2
    (71) exp2 -> . exp3
    (72) exp3 -> . LPAREN arithmetic RPAREN
    (73) exp3 -> . NUMBER
    (74) exp3 -> . exp_assignment
    (75) exp3 -> . exp_condition
    (76) exp3 -> . call
    (77) exp3 -> . exp
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN

    LPAREN          shift and go to state 90
    NUMBER          shift and go to state 44
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39
    ID              shift and go to state 6

    exp_condition                  shift and go to state 92
    arithmetic                     shift and go to state 91
    attcond                        shift and go to state 33
    exp                            shift and go to state 45
    exp_assignment                 shift and go to state 43
    true                           shift and go to state 36
    false                          shift and go to state 37
    exp1                           shift and go to state 46
    exp2                           shift and go to state 47
    exp3                           shift and go to state 48
    call                           shift and go to state 51

state 91

    (72) exp3 -> LPAREN arithmetic . RPAREN

    RPAREN          shift and go to state 128


state 92

    (41) exp_condition -> LPAREN exp_condition . RPAREN logic exp_condition_logic
    (75) exp3 -> exp_condition .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 106
    XOR             reduce using rule 75 (exp3 -> exp_condition .)
    TIMES           reduce using rule 75 (exp3 -> exp_condition .)
    DIVIDE          reduce using rule 75 (exp3 -> exp_condition .)
    MODULO          reduce using rule 75 (exp3 -> exp_condition .)
    PLUS            reduce using rule 75 (exp3 -> exp_condition .)
    MINUS           reduce using rule 75 (exp3 -> exp_condition .)

  ! RPAREN          [ reduce using rule 75 (exp3 -> exp_condition .) ]


state 93

    (14) if -> IF LPAREN exp_condition . RPAREN LBRACE blockcode RBRACE
    (16) if -> IF LPAREN exp_condition . RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if -> IF LPAREN exp_condition . RPAREN LBRACE blockcode RBRACE elsif

    RPAREN          shift and go to state 129


state 94

    (54) exp_assignment -> ID_SC EQUALS arithmetic .

    IF              reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    RETURN          reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    BREAK           reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    CONTINUE        reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    ID_SC           reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    ID_LI           reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    INCREMENT       reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    DECREMENT       reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    ID              reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    FOR             reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    DO              reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    LPAREN          reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    SUB             reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    $end            reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    RBRACE          reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    GT              reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    LT              reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    EQ              reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    GE              reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    LE              reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    NE              reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    CMP             reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    SEQ             reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    SNE             reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    SLT             reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    SGT             reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    SLE             reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    SGE             reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    RPAREN          reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    SEMICOLON       reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    XOR             reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    TIMES           reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    DIVIDE          reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    MODULO          reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    PLUS            reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    MINUS           reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)
    COMMA           reduce using rule 54 (exp_assignment -> ID_SC EQUALS arithmetic .)


state 95

    (73) exp3 -> NUMBER .
    (79) attcond -> NUMBER .

  ! reduce/reduce conflict for IF resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for RETURN resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for BREAK resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for ID_SC resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for ID_LI resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for INCREMENT resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for DECREMENT resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for ID resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for FOR resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for DO resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for LPAREN resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for SUB resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for $end resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for RBRACE resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for GT resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for LT resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for EQ resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for GE resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for LE resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for NE resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for CMP resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for SEQ resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for SNE resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for SLT resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for SGT resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for SLE resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for SGE resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for XOR resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for TIMES resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for MODULO resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for PLUS resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for MINUS resolved using rule 73 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for COMMA resolved using rule 73 (exp3 -> NUMBER .)
    IF              reduce using rule 73 (exp3 -> NUMBER .)
    RETURN          reduce using rule 73 (exp3 -> NUMBER .)
    BREAK           reduce using rule 73 (exp3 -> NUMBER .)
    CONTINUE        reduce using rule 73 (exp3 -> NUMBER .)
    ID_SC           reduce using rule 73 (exp3 -> NUMBER .)
    ID_LI           reduce using rule 73 (exp3 -> NUMBER .)
    INCREMENT       reduce using rule 73 (exp3 -> NUMBER .)
    DECREMENT       reduce using rule 73 (exp3 -> NUMBER .)
    ID              reduce using rule 73 (exp3 -> NUMBER .)
    FOR             reduce using rule 73 (exp3 -> NUMBER .)
    DO              reduce using rule 73 (exp3 -> NUMBER .)
    LPAREN          reduce using rule 73 (exp3 -> NUMBER .)
    SUB             reduce using rule 73 (exp3 -> NUMBER .)
    $end            reduce using rule 73 (exp3 -> NUMBER .)
    RBRACE          reduce using rule 73 (exp3 -> NUMBER .)
    GT              reduce using rule 73 (exp3 -> NUMBER .)
    LT              reduce using rule 73 (exp3 -> NUMBER .)
    EQ              reduce using rule 73 (exp3 -> NUMBER .)
    GE              reduce using rule 73 (exp3 -> NUMBER .)
    LE              reduce using rule 73 (exp3 -> NUMBER .)
    NE              reduce using rule 73 (exp3 -> NUMBER .)
    CMP             reduce using rule 73 (exp3 -> NUMBER .)
    SEQ             reduce using rule 73 (exp3 -> NUMBER .)
    SNE             reduce using rule 73 (exp3 -> NUMBER .)
    SLT             reduce using rule 73 (exp3 -> NUMBER .)
    SGT             reduce using rule 73 (exp3 -> NUMBER .)
    SLE             reduce using rule 73 (exp3 -> NUMBER .)
    SGE             reduce using rule 73 (exp3 -> NUMBER .)
    RPAREN          reduce using rule 73 (exp3 -> NUMBER .)
    SEMICOLON       reduce using rule 73 (exp3 -> NUMBER .)
    XOR             reduce using rule 73 (exp3 -> NUMBER .)
    TIMES           reduce using rule 73 (exp3 -> NUMBER .)
    DIVIDE          reduce using rule 73 (exp3 -> NUMBER .)
    MODULO          reduce using rule 73 (exp3 -> NUMBER .)
    PLUS            reduce using rule 73 (exp3 -> NUMBER .)
    MINUS           reduce using rule 73 (exp3 -> NUMBER .)
    COMMA           reduce using rule 73 (exp3 -> NUMBER .)

  ! IF              [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! RETURN          [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! BREAK           [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! CONTINUE        [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! ID_SC           [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! ID_LI           [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! INCREMENT       [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! DECREMENT       [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! ID              [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! FOR             [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! DO              [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! LPAREN          [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! SUB             [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! $end            [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! RBRACE          [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! GT              [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! LT              [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! EQ              [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! GE              [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! LE              [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! NE              [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! CMP             [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! SEQ             [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! SNE             [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! SLT             [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! SGT             [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! SLE             [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! SGE             [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! RPAREN          [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! SEMICOLON       [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! XOR             [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! TIMES           [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! DIVIDE          [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! MODULO          [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! PLUS            [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! MINUS           [ reduce using rule 79 (attcond -> NUMBER .) ]
  ! COMMA           [ reduce using rule 79 (attcond -> NUMBER .) ]


state 96

    (74) exp3 -> exp_assignment .
    (78) attcond -> exp_assignment .

  ! reduce/reduce conflict for IF resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for RETURN resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for BREAK resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for ID_SC resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for ID_LI resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for INCREMENT resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for DECREMENT resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for ID resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for FOR resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for DO resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for LPAREN resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for SUB resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for $end resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for RBRACE resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for GT resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for LT resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for EQ resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for GE resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for LE resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for NE resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for CMP resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for SEQ resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for SNE resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for SLT resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for SGT resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for SLE resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for SGE resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for RPAREN resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for XOR resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for TIMES resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for MODULO resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for PLUS resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for MINUS resolved using rule 74 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for COMMA resolved using rule 74 (exp3 -> exp_assignment .)
    IF              reduce using rule 74 (exp3 -> exp_assignment .)
    RETURN          reduce using rule 74 (exp3 -> exp_assignment .)
    BREAK           reduce using rule 74 (exp3 -> exp_assignment .)
    CONTINUE        reduce using rule 74 (exp3 -> exp_assignment .)
    ID_SC           reduce using rule 74 (exp3 -> exp_assignment .)
    ID_LI           reduce using rule 74 (exp3 -> exp_assignment .)
    INCREMENT       reduce using rule 74 (exp3 -> exp_assignment .)
    DECREMENT       reduce using rule 74 (exp3 -> exp_assignment .)
    ID              reduce using rule 74 (exp3 -> exp_assignment .)
    FOR             reduce using rule 74 (exp3 -> exp_assignment .)
    DO              reduce using rule 74 (exp3 -> exp_assignment .)
    LPAREN          reduce using rule 74 (exp3 -> exp_assignment .)
    SUB             reduce using rule 74 (exp3 -> exp_assignment .)
    $end            reduce using rule 74 (exp3 -> exp_assignment .)
    RBRACE          reduce using rule 74 (exp3 -> exp_assignment .)
    GT              reduce using rule 74 (exp3 -> exp_assignment .)
    LT              reduce using rule 74 (exp3 -> exp_assignment .)
    EQ              reduce using rule 74 (exp3 -> exp_assignment .)
    GE              reduce using rule 74 (exp3 -> exp_assignment .)
    LE              reduce using rule 74 (exp3 -> exp_assignment .)
    NE              reduce using rule 74 (exp3 -> exp_assignment .)
    CMP             reduce using rule 74 (exp3 -> exp_assignment .)
    SEQ             reduce using rule 74 (exp3 -> exp_assignment .)
    SNE             reduce using rule 74 (exp3 -> exp_assignment .)
    SLT             reduce using rule 74 (exp3 -> exp_assignment .)
    SGT             reduce using rule 74 (exp3 -> exp_assignment .)
    SLE             reduce using rule 74 (exp3 -> exp_assignment .)
    SGE             reduce using rule 74 (exp3 -> exp_assignment .)
    RPAREN          reduce using rule 74 (exp3 -> exp_assignment .)
    SEMICOLON       reduce using rule 74 (exp3 -> exp_assignment .)
    XOR             reduce using rule 74 (exp3 -> exp_assignment .)
    TIMES           reduce using rule 74 (exp3 -> exp_assignment .)
    DIVIDE          reduce using rule 74 (exp3 -> exp_assignment .)
    MODULO          reduce using rule 74 (exp3 -> exp_assignment .)
    PLUS            reduce using rule 74 (exp3 -> exp_assignment .)
    MINUS           reduce using rule 74 (exp3 -> exp_assignment .)
    COMMA           reduce using rule 74 (exp3 -> exp_assignment .)

  ! IF              [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! RETURN          [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! BREAK           [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! CONTINUE        [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! ID_SC           [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! ID_LI           [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! INCREMENT       [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! DECREMENT       [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! ID              [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! FOR             [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! DO              [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! LPAREN          [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! SUB             [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! $end            [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! RBRACE          [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! GT              [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! LT              [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! EQ              [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! GE              [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! LE              [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! NE              [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! CMP             [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! SEQ             [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! SNE             [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! SLT             [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! SGT             [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! SLE             [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! SGE             [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! RPAREN          [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! SEMICOLON       [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! XOR             [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! TIMES           [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! DIVIDE          [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! MODULO          [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! PLUS            [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! MINUS           [ reduce using rule 78 (attcond -> exp_assignment .) ]
  ! COMMA           [ reduce using rule 78 (attcond -> exp_assignment .) ]


state 97

    (55) exp_assignment -> ID_LI EQUALS arithmetic .

    IF              reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    RETURN          reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    BREAK           reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    CONTINUE        reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    ID_SC           reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    ID_LI           reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    INCREMENT       reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    DECREMENT       reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    ID              reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    FOR             reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    DO              reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    LPAREN          reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    SUB             reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    $end            reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    RBRACE          reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    GT              reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    LT              reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    EQ              reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    GE              reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    LE              reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    NE              reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    CMP             reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    SEQ             reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    SNE             reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    SLT             reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    SGT             reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    SLE             reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    SGE             reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    RPAREN          reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    SEMICOLON       reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    XOR             reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    TIMES           reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    DIVIDE          reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    MODULO          reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    PLUS            reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    MINUS           reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)
    COMMA           reduce using rule 55 (exp_assignment -> ID_LI EQUALS arithmetic .)


state 98

    (25) for -> FOR LPAREN for_assignments . SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE

    SEMICOLON       shift and go to state 130


state 99

    (26) for_assignments -> exp_assignment .
    (27) for_assignments -> exp_assignment . COMMA for_assignments

    SEMICOLON       reduce using rule 26 (for_assignments -> exp_assignment .)
    RPAREN          reduce using rule 26 (for_assignments -> exp_assignment .)
    COMMA           shift and go to state 131


state 100

    (28) dowhile -> DO LBRACE blockcode . RBRACE WHILE LPAREN exp_condition RPAREN

    RBRACE          shift and go to state 132


state 101

    (15) if -> command IF LPAREN exp_condition . RPAREN
    (14) if -> IF LPAREN exp_condition . RPAREN LBRACE blockcode RBRACE
    (16) if -> IF LPAREN exp_condition . RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if -> IF LPAREN exp_condition . RPAREN LBRACE blockcode RBRACE elsif

    RPAREN          shift and go to state 133


state 102

    (30) function -> SUB ID LPAREN RPAREN . LBRACE blockcode RBRACE

    LBRACE          shift and go to state 134


state 103

    (31) function -> SUB ID LPAREN function_assignments . RPAREN LBRACE blockcode RBRACE

    RPAREN          shift and go to state 135


state 104

    (83) call -> ID LPAREN function_assignments RPAREN .

    IF              reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    RETURN          reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    BREAK           reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    CONTINUE        reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    ID_SC           reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    ID_LI           reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    INCREMENT       reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    DECREMENT       reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    ID              reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    FOR             reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    DO              reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    LPAREN          reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    SUB             reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    $end            reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    RBRACE          reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    XOR             reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    TIMES           reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    DIVIDE          reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    MODULO          reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    PLUS            reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    MINUS           reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    SEMICOLON       reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    RPAREN          reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    GT              reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    LT              reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    EQ              reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    GE              reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    LE              reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    NE              reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    CMP             reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    SEQ             reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    SNE             reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    SLT             reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    SGT             reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    SLE             reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    SGE             reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)
    COMMA           reduce using rule 83 (call -> ID LPAREN function_assignments RPAREN .)


state 105

    (33) function_assignments -> exp_assignment COMMA . function_assignments
    (32) function_assignments -> . exp_assignment
    (33) function_assignments -> . exp_assignment COMMA function_assignments
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT

    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22

    exp_assignment                 shift and go to state 67
    function_assignments           shift and go to state 136

state 106

    (41) exp_condition -> LPAREN exp_condition RPAREN . logic exp_condition_logic
    (51) logic -> . LAND
    (52) logic -> . LOR
    (53) logic -> . LNOT

    LAND            shift and go to state 138
    LOR             shift and go to state 139
    LNOT            shift and go to state 140

    logic                          shift and go to state 137

state 107

    (29) while -> LPAREN exp_condition RPAREN LBRACE . blockcode RBRACE
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (15) if -> . command IF LPAREN exp_condition RPAREN
    (16) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE

    RETURN          shift and go to state 12
    BREAK           shift and go to state 13
    CONTINUE        shift and go to state 14
    IF              shift and go to state 18
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    ID              shift and go to state 6
    FOR             shift and go to state 23
    DO              shift and go to state 24
    LPAREN          shift and go to state 7

    blockcode                      shift and go to state 141
    command                        shift and go to state 4
    interations                    shift and go to state 8
    if                             shift and go to state 9
    exp_assignment                 shift and go to state 10
    call                           shift and go to state 11
    for                            shift and go to state 15
    dowhile                        shift and go to state 16
    while                          shift and go to state 17

state 108

    (34) exp_condition -> attcond GT attcond .

    RPAREN          reduce using rule 34 (exp_condition -> attcond GT attcond .)
    XOR             reduce using rule 34 (exp_condition -> attcond GT attcond .)
    TIMES           reduce using rule 34 (exp_condition -> attcond GT attcond .)
    DIVIDE          reduce using rule 34 (exp_condition -> attcond GT attcond .)
    MODULO          reduce using rule 34 (exp_condition -> attcond GT attcond .)
    PLUS            reduce using rule 34 (exp_condition -> attcond GT attcond .)
    MINUS           reduce using rule 34 (exp_condition -> attcond GT attcond .)
    SEMICOLON       reduce using rule 34 (exp_condition -> attcond GT attcond .)
    IF              reduce using rule 34 (exp_condition -> attcond GT attcond .)
    RETURN          reduce using rule 34 (exp_condition -> attcond GT attcond .)
    BREAK           reduce using rule 34 (exp_condition -> attcond GT attcond .)
    CONTINUE        reduce using rule 34 (exp_condition -> attcond GT attcond .)
    ID_SC           reduce using rule 34 (exp_condition -> attcond GT attcond .)
    ID_LI           reduce using rule 34 (exp_condition -> attcond GT attcond .)
    INCREMENT       reduce using rule 34 (exp_condition -> attcond GT attcond .)
    DECREMENT       reduce using rule 34 (exp_condition -> attcond GT attcond .)
    ID              reduce using rule 34 (exp_condition -> attcond GT attcond .)
    FOR             reduce using rule 34 (exp_condition -> attcond GT attcond .)
    DO              reduce using rule 34 (exp_condition -> attcond GT attcond .)
    LPAREN          reduce using rule 34 (exp_condition -> attcond GT attcond .)
    SUB             reduce using rule 34 (exp_condition -> attcond GT attcond .)
    $end            reduce using rule 34 (exp_condition -> attcond GT attcond .)
    RBRACE          reduce using rule 34 (exp_condition -> attcond GT attcond .)
    GT              reduce using rule 34 (exp_condition -> attcond GT attcond .)
    LT              reduce using rule 34 (exp_condition -> attcond GT attcond .)
    EQ              reduce using rule 34 (exp_condition -> attcond GT attcond .)
    GE              reduce using rule 34 (exp_condition -> attcond GT attcond .)
    LE              reduce using rule 34 (exp_condition -> attcond GT attcond .)
    NE              reduce using rule 34 (exp_condition -> attcond GT attcond .)
    CMP             reduce using rule 34 (exp_condition -> attcond GT attcond .)
    SEQ             reduce using rule 34 (exp_condition -> attcond GT attcond .)
    SNE             reduce using rule 34 (exp_condition -> attcond GT attcond .)
    SLT             reduce using rule 34 (exp_condition -> attcond GT attcond .)
    SGT             reduce using rule 34 (exp_condition -> attcond GT attcond .)
    SLE             reduce using rule 34 (exp_condition -> attcond GT attcond .)
    SGE             reduce using rule 34 (exp_condition -> attcond GT attcond .)
    COMMA           reduce using rule 34 (exp_condition -> attcond GT attcond .)


state 109

    (35) exp_condition -> attcond LT attcond .

    RPAREN          reduce using rule 35 (exp_condition -> attcond LT attcond .)
    XOR             reduce using rule 35 (exp_condition -> attcond LT attcond .)
    TIMES           reduce using rule 35 (exp_condition -> attcond LT attcond .)
    DIVIDE          reduce using rule 35 (exp_condition -> attcond LT attcond .)
    MODULO          reduce using rule 35 (exp_condition -> attcond LT attcond .)
    PLUS            reduce using rule 35 (exp_condition -> attcond LT attcond .)
    MINUS           reduce using rule 35 (exp_condition -> attcond LT attcond .)
    SEMICOLON       reduce using rule 35 (exp_condition -> attcond LT attcond .)
    IF              reduce using rule 35 (exp_condition -> attcond LT attcond .)
    RETURN          reduce using rule 35 (exp_condition -> attcond LT attcond .)
    BREAK           reduce using rule 35 (exp_condition -> attcond LT attcond .)
    CONTINUE        reduce using rule 35 (exp_condition -> attcond LT attcond .)
    ID_SC           reduce using rule 35 (exp_condition -> attcond LT attcond .)
    ID_LI           reduce using rule 35 (exp_condition -> attcond LT attcond .)
    INCREMENT       reduce using rule 35 (exp_condition -> attcond LT attcond .)
    DECREMENT       reduce using rule 35 (exp_condition -> attcond LT attcond .)
    ID              reduce using rule 35 (exp_condition -> attcond LT attcond .)
    FOR             reduce using rule 35 (exp_condition -> attcond LT attcond .)
    DO              reduce using rule 35 (exp_condition -> attcond LT attcond .)
    LPAREN          reduce using rule 35 (exp_condition -> attcond LT attcond .)
    SUB             reduce using rule 35 (exp_condition -> attcond LT attcond .)
    $end            reduce using rule 35 (exp_condition -> attcond LT attcond .)
    RBRACE          reduce using rule 35 (exp_condition -> attcond LT attcond .)
    GT              reduce using rule 35 (exp_condition -> attcond LT attcond .)
    LT              reduce using rule 35 (exp_condition -> attcond LT attcond .)
    EQ              reduce using rule 35 (exp_condition -> attcond LT attcond .)
    GE              reduce using rule 35 (exp_condition -> attcond LT attcond .)
    LE              reduce using rule 35 (exp_condition -> attcond LT attcond .)
    NE              reduce using rule 35 (exp_condition -> attcond LT attcond .)
    CMP             reduce using rule 35 (exp_condition -> attcond LT attcond .)
    SEQ             reduce using rule 35 (exp_condition -> attcond LT attcond .)
    SNE             reduce using rule 35 (exp_condition -> attcond LT attcond .)
    SLT             reduce using rule 35 (exp_condition -> attcond LT attcond .)
    SGT             reduce using rule 35 (exp_condition -> attcond LT attcond .)
    SLE             reduce using rule 35 (exp_condition -> attcond LT attcond .)
    SGE             reduce using rule 35 (exp_condition -> attcond LT attcond .)
    COMMA           reduce using rule 35 (exp_condition -> attcond LT attcond .)


state 110

    (36) exp_condition -> attcond EQ attcond .

    RPAREN          reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    XOR             reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    TIMES           reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    DIVIDE          reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    MODULO          reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    PLUS            reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    MINUS           reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    SEMICOLON       reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    IF              reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    RETURN          reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    BREAK           reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    CONTINUE        reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    ID_SC           reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    ID_LI           reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    INCREMENT       reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    DECREMENT       reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    ID              reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    FOR             reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    DO              reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    LPAREN          reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    SUB             reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    $end            reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    RBRACE          reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    GT              reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    LT              reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    EQ              reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    GE              reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    LE              reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    NE              reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    CMP             reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    SEQ             reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    SNE             reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    SLT             reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    SGT             reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    SLE             reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    SGE             reduce using rule 36 (exp_condition -> attcond EQ attcond .)
    COMMA           reduce using rule 36 (exp_condition -> attcond EQ attcond .)


state 111

    (37) exp_condition -> attcond GE attcond .

    RPAREN          reduce using rule 37 (exp_condition -> attcond GE attcond .)
    XOR             reduce using rule 37 (exp_condition -> attcond GE attcond .)
    TIMES           reduce using rule 37 (exp_condition -> attcond GE attcond .)
    DIVIDE          reduce using rule 37 (exp_condition -> attcond GE attcond .)
    MODULO          reduce using rule 37 (exp_condition -> attcond GE attcond .)
    PLUS            reduce using rule 37 (exp_condition -> attcond GE attcond .)
    MINUS           reduce using rule 37 (exp_condition -> attcond GE attcond .)
    SEMICOLON       reduce using rule 37 (exp_condition -> attcond GE attcond .)
    IF              reduce using rule 37 (exp_condition -> attcond GE attcond .)
    RETURN          reduce using rule 37 (exp_condition -> attcond GE attcond .)
    BREAK           reduce using rule 37 (exp_condition -> attcond GE attcond .)
    CONTINUE        reduce using rule 37 (exp_condition -> attcond GE attcond .)
    ID_SC           reduce using rule 37 (exp_condition -> attcond GE attcond .)
    ID_LI           reduce using rule 37 (exp_condition -> attcond GE attcond .)
    INCREMENT       reduce using rule 37 (exp_condition -> attcond GE attcond .)
    DECREMENT       reduce using rule 37 (exp_condition -> attcond GE attcond .)
    ID              reduce using rule 37 (exp_condition -> attcond GE attcond .)
    FOR             reduce using rule 37 (exp_condition -> attcond GE attcond .)
    DO              reduce using rule 37 (exp_condition -> attcond GE attcond .)
    LPAREN          reduce using rule 37 (exp_condition -> attcond GE attcond .)
    SUB             reduce using rule 37 (exp_condition -> attcond GE attcond .)
    $end            reduce using rule 37 (exp_condition -> attcond GE attcond .)
    RBRACE          reduce using rule 37 (exp_condition -> attcond GE attcond .)
    GT              reduce using rule 37 (exp_condition -> attcond GE attcond .)
    LT              reduce using rule 37 (exp_condition -> attcond GE attcond .)
    EQ              reduce using rule 37 (exp_condition -> attcond GE attcond .)
    GE              reduce using rule 37 (exp_condition -> attcond GE attcond .)
    LE              reduce using rule 37 (exp_condition -> attcond GE attcond .)
    NE              reduce using rule 37 (exp_condition -> attcond GE attcond .)
    CMP             reduce using rule 37 (exp_condition -> attcond GE attcond .)
    SEQ             reduce using rule 37 (exp_condition -> attcond GE attcond .)
    SNE             reduce using rule 37 (exp_condition -> attcond GE attcond .)
    SLT             reduce using rule 37 (exp_condition -> attcond GE attcond .)
    SGT             reduce using rule 37 (exp_condition -> attcond GE attcond .)
    SLE             reduce using rule 37 (exp_condition -> attcond GE attcond .)
    SGE             reduce using rule 37 (exp_condition -> attcond GE attcond .)
    COMMA           reduce using rule 37 (exp_condition -> attcond GE attcond .)


state 112

    (38) exp_condition -> attcond LE attcond .

    RPAREN          reduce using rule 38 (exp_condition -> attcond LE attcond .)
    XOR             reduce using rule 38 (exp_condition -> attcond LE attcond .)
    TIMES           reduce using rule 38 (exp_condition -> attcond LE attcond .)
    DIVIDE          reduce using rule 38 (exp_condition -> attcond LE attcond .)
    MODULO          reduce using rule 38 (exp_condition -> attcond LE attcond .)
    PLUS            reduce using rule 38 (exp_condition -> attcond LE attcond .)
    MINUS           reduce using rule 38 (exp_condition -> attcond LE attcond .)
    SEMICOLON       reduce using rule 38 (exp_condition -> attcond LE attcond .)
    IF              reduce using rule 38 (exp_condition -> attcond LE attcond .)
    RETURN          reduce using rule 38 (exp_condition -> attcond LE attcond .)
    BREAK           reduce using rule 38 (exp_condition -> attcond LE attcond .)
    CONTINUE        reduce using rule 38 (exp_condition -> attcond LE attcond .)
    ID_SC           reduce using rule 38 (exp_condition -> attcond LE attcond .)
    ID_LI           reduce using rule 38 (exp_condition -> attcond LE attcond .)
    INCREMENT       reduce using rule 38 (exp_condition -> attcond LE attcond .)
    DECREMENT       reduce using rule 38 (exp_condition -> attcond LE attcond .)
    ID              reduce using rule 38 (exp_condition -> attcond LE attcond .)
    FOR             reduce using rule 38 (exp_condition -> attcond LE attcond .)
    DO              reduce using rule 38 (exp_condition -> attcond LE attcond .)
    LPAREN          reduce using rule 38 (exp_condition -> attcond LE attcond .)
    SUB             reduce using rule 38 (exp_condition -> attcond LE attcond .)
    $end            reduce using rule 38 (exp_condition -> attcond LE attcond .)
    RBRACE          reduce using rule 38 (exp_condition -> attcond LE attcond .)
    GT              reduce using rule 38 (exp_condition -> attcond LE attcond .)
    LT              reduce using rule 38 (exp_condition -> attcond LE attcond .)
    EQ              reduce using rule 38 (exp_condition -> attcond LE attcond .)
    GE              reduce using rule 38 (exp_condition -> attcond LE attcond .)
    LE              reduce using rule 38 (exp_condition -> attcond LE attcond .)
    NE              reduce using rule 38 (exp_condition -> attcond LE attcond .)
    CMP             reduce using rule 38 (exp_condition -> attcond LE attcond .)
    SEQ             reduce using rule 38 (exp_condition -> attcond LE attcond .)
    SNE             reduce using rule 38 (exp_condition -> attcond LE attcond .)
    SLT             reduce using rule 38 (exp_condition -> attcond LE attcond .)
    SGT             reduce using rule 38 (exp_condition -> attcond LE attcond .)
    SLE             reduce using rule 38 (exp_condition -> attcond LE attcond .)
    SGE             reduce using rule 38 (exp_condition -> attcond LE attcond .)
    COMMA           reduce using rule 38 (exp_condition -> attcond LE attcond .)


state 113

    (39) exp_condition -> attcond NE attcond .

    RPAREN          reduce using rule 39 (exp_condition -> attcond NE attcond .)
    XOR             reduce using rule 39 (exp_condition -> attcond NE attcond .)
    TIMES           reduce using rule 39 (exp_condition -> attcond NE attcond .)
    DIVIDE          reduce using rule 39 (exp_condition -> attcond NE attcond .)
    MODULO          reduce using rule 39 (exp_condition -> attcond NE attcond .)
    PLUS            reduce using rule 39 (exp_condition -> attcond NE attcond .)
    MINUS           reduce using rule 39 (exp_condition -> attcond NE attcond .)
    SEMICOLON       reduce using rule 39 (exp_condition -> attcond NE attcond .)
    IF              reduce using rule 39 (exp_condition -> attcond NE attcond .)
    RETURN          reduce using rule 39 (exp_condition -> attcond NE attcond .)
    BREAK           reduce using rule 39 (exp_condition -> attcond NE attcond .)
    CONTINUE        reduce using rule 39 (exp_condition -> attcond NE attcond .)
    ID_SC           reduce using rule 39 (exp_condition -> attcond NE attcond .)
    ID_LI           reduce using rule 39 (exp_condition -> attcond NE attcond .)
    INCREMENT       reduce using rule 39 (exp_condition -> attcond NE attcond .)
    DECREMENT       reduce using rule 39 (exp_condition -> attcond NE attcond .)
    ID              reduce using rule 39 (exp_condition -> attcond NE attcond .)
    FOR             reduce using rule 39 (exp_condition -> attcond NE attcond .)
    DO              reduce using rule 39 (exp_condition -> attcond NE attcond .)
    LPAREN          reduce using rule 39 (exp_condition -> attcond NE attcond .)
    SUB             reduce using rule 39 (exp_condition -> attcond NE attcond .)
    $end            reduce using rule 39 (exp_condition -> attcond NE attcond .)
    RBRACE          reduce using rule 39 (exp_condition -> attcond NE attcond .)
    GT              reduce using rule 39 (exp_condition -> attcond NE attcond .)
    LT              reduce using rule 39 (exp_condition -> attcond NE attcond .)
    EQ              reduce using rule 39 (exp_condition -> attcond NE attcond .)
    GE              reduce using rule 39 (exp_condition -> attcond NE attcond .)
    LE              reduce using rule 39 (exp_condition -> attcond NE attcond .)
    NE              reduce using rule 39 (exp_condition -> attcond NE attcond .)
    CMP             reduce using rule 39 (exp_condition -> attcond NE attcond .)
    SEQ             reduce using rule 39 (exp_condition -> attcond NE attcond .)
    SNE             reduce using rule 39 (exp_condition -> attcond NE attcond .)
    SLT             reduce using rule 39 (exp_condition -> attcond NE attcond .)
    SGT             reduce using rule 39 (exp_condition -> attcond NE attcond .)
    SLE             reduce using rule 39 (exp_condition -> attcond NE attcond .)
    SGE             reduce using rule 39 (exp_condition -> attcond NE attcond .)
    COMMA           reduce using rule 39 (exp_condition -> attcond NE attcond .)


state 114

    (42) exp_condition -> attcond CMP attcond .

    RPAREN          reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    XOR             reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    TIMES           reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    DIVIDE          reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    MODULO          reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    PLUS            reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    MINUS           reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    SEMICOLON       reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    IF              reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    RETURN          reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    BREAK           reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    CONTINUE        reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    ID_SC           reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    ID_LI           reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    INCREMENT       reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    DECREMENT       reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    ID              reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    FOR             reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    DO              reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    LPAREN          reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    SUB             reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    $end            reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    RBRACE          reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    GT              reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    LT              reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    EQ              reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    GE              reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    LE              reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    NE              reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    CMP             reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    SEQ             reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    SNE             reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    SLT             reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    SGT             reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    SLE             reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    SGE             reduce using rule 42 (exp_condition -> attcond CMP attcond .)
    COMMA           reduce using rule 42 (exp_condition -> attcond CMP attcond .)


state 115

    (43) exp_condition -> attcond SEQ attcond .

    RPAREN          reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    XOR             reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    TIMES           reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    DIVIDE          reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    MODULO          reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    PLUS            reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    MINUS           reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    SEMICOLON       reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    IF              reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    RETURN          reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    BREAK           reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    CONTINUE        reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    ID_SC           reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    ID_LI           reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    INCREMENT       reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    DECREMENT       reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    ID              reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    FOR             reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    DO              reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    LPAREN          reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    SUB             reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    $end            reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    RBRACE          reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    GT              reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    LT              reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    EQ              reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    GE              reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    LE              reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    NE              reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    CMP             reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    SEQ             reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    SNE             reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    SLT             reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    SGT             reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    SLE             reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    SGE             reduce using rule 43 (exp_condition -> attcond SEQ attcond .)
    COMMA           reduce using rule 43 (exp_condition -> attcond SEQ attcond .)


state 116

    (44) exp_condition -> attcond SNE attcond .

    RPAREN          reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    XOR             reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    TIMES           reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    DIVIDE          reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    MODULO          reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    PLUS            reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    MINUS           reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    SEMICOLON       reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    IF              reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    RETURN          reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    BREAK           reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    CONTINUE        reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    ID_SC           reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    ID_LI           reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    INCREMENT       reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    DECREMENT       reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    ID              reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    FOR             reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    DO              reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    LPAREN          reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    SUB             reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    $end            reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    RBRACE          reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    GT              reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    LT              reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    EQ              reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    GE              reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    LE              reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    NE              reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    CMP             reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    SEQ             reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    SNE             reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    SLT             reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    SGT             reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    SLE             reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    SGE             reduce using rule 44 (exp_condition -> attcond SNE attcond .)
    COMMA           reduce using rule 44 (exp_condition -> attcond SNE attcond .)


state 117

    (45) exp_condition -> attcond SLT attcond .

    RPAREN          reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    XOR             reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    TIMES           reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    DIVIDE          reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    MODULO          reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    PLUS            reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    MINUS           reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    SEMICOLON       reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    IF              reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    RETURN          reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    BREAK           reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    CONTINUE        reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    ID_SC           reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    ID_LI           reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    INCREMENT       reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    DECREMENT       reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    ID              reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    FOR             reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    DO              reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    LPAREN          reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    SUB             reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    $end            reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    RBRACE          reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    GT              reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    LT              reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    EQ              reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    GE              reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    LE              reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    NE              reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    CMP             reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    SEQ             reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    SNE             reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    SLT             reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    SGT             reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    SLE             reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    SGE             reduce using rule 45 (exp_condition -> attcond SLT attcond .)
    COMMA           reduce using rule 45 (exp_condition -> attcond SLT attcond .)


state 118

    (46) exp_condition -> attcond SGT attcond .

    RPAREN          reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    XOR             reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    TIMES           reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    DIVIDE          reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    MODULO          reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    PLUS            reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    MINUS           reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    SEMICOLON       reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    IF              reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    RETURN          reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    BREAK           reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    CONTINUE        reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    ID_SC           reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    ID_LI           reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    INCREMENT       reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    DECREMENT       reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    ID              reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    FOR             reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    DO              reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    LPAREN          reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    SUB             reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    $end            reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    RBRACE          reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    GT              reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    LT              reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    EQ              reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    GE              reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    LE              reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    NE              reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    CMP             reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    SEQ             reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    SNE             reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    SLT             reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    SGT             reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    SLE             reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    SGE             reduce using rule 46 (exp_condition -> attcond SGT attcond .)
    COMMA           reduce using rule 46 (exp_condition -> attcond SGT attcond .)


state 119

    (47) exp_condition -> attcond SLE attcond .

    RPAREN          reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    XOR             reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    TIMES           reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    DIVIDE          reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    MODULO          reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    PLUS            reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    MINUS           reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    SEMICOLON       reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    IF              reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    RETURN          reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    BREAK           reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    CONTINUE        reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    ID_SC           reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    ID_LI           reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    INCREMENT       reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    DECREMENT       reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    ID              reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    FOR             reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    DO              reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    LPAREN          reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    SUB             reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    $end            reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    RBRACE          reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    GT              reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    LT              reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    EQ              reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    GE              reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    LE              reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    NE              reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    CMP             reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    SEQ             reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    SNE             reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    SLT             reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    SGT             reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    SLE             reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    SGE             reduce using rule 47 (exp_condition -> attcond SLE attcond .)
    COMMA           reduce using rule 47 (exp_condition -> attcond SLE attcond .)


state 120

    (48) exp_condition -> attcond SGE attcond .

    RPAREN          reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    XOR             reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    TIMES           reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    DIVIDE          reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    MODULO          reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    PLUS            reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    MINUS           reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    SEMICOLON       reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    IF              reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    RETURN          reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    BREAK           reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    CONTINUE        reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    ID_SC           reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    ID_LI           reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    INCREMENT       reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    DECREMENT       reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    ID              reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    FOR             reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    DO              reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    LPAREN          reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    SUB             reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    $end            reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    RBRACE          reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    GT              reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    LT              reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    EQ              reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    GE              reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    LE              reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    NE              reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    CMP             reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    SEQ             reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    SNE             reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    SLT             reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    SGT             reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    SLE             reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    SGE             reduce using rule 48 (exp_condition -> attcond SGE attcond .)
    COMMA           reduce using rule 48 (exp_condition -> attcond SGE attcond .)


state 121

    (77) exp3 -> exp .
    (63) exp -> exp . PLUS exp1
    (64) exp -> exp . MINUS exp1

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IF              reduce using rule 77 (exp3 -> exp .)
    RETURN          reduce using rule 77 (exp3 -> exp .)
    BREAK           reduce using rule 77 (exp3 -> exp .)
    CONTINUE        reduce using rule 77 (exp3 -> exp .)
    ID_SC           reduce using rule 77 (exp3 -> exp .)
    ID_LI           reduce using rule 77 (exp3 -> exp .)
    INCREMENT       reduce using rule 77 (exp3 -> exp .)
    DECREMENT       reduce using rule 77 (exp3 -> exp .)
    ID              reduce using rule 77 (exp3 -> exp .)
    FOR             reduce using rule 77 (exp3 -> exp .)
    DO              reduce using rule 77 (exp3 -> exp .)
    LPAREN          reduce using rule 77 (exp3 -> exp .)
    SUB             reduce using rule 77 (exp3 -> exp .)
    $end            reduce using rule 77 (exp3 -> exp .)
    RBRACE          reduce using rule 77 (exp3 -> exp .)
    GT              reduce using rule 77 (exp3 -> exp .)
    LT              reduce using rule 77 (exp3 -> exp .)
    EQ              reduce using rule 77 (exp3 -> exp .)
    GE              reduce using rule 77 (exp3 -> exp .)
    LE              reduce using rule 77 (exp3 -> exp .)
    NE              reduce using rule 77 (exp3 -> exp .)
    CMP             reduce using rule 77 (exp3 -> exp .)
    SEQ             reduce using rule 77 (exp3 -> exp .)
    SNE             reduce using rule 77 (exp3 -> exp .)
    SLT             reduce using rule 77 (exp3 -> exp .)
    SGT             reduce using rule 77 (exp3 -> exp .)
    SLE             reduce using rule 77 (exp3 -> exp .)
    SGE             reduce using rule 77 (exp3 -> exp .)
    RPAREN          reduce using rule 77 (exp3 -> exp .)
    SEMICOLON       reduce using rule 77 (exp3 -> exp .)
    XOR             reduce using rule 77 (exp3 -> exp .)
    TIMES           reduce using rule 77 (exp3 -> exp .)
    DIVIDE          reduce using rule 77 (exp3 -> exp .)
    MODULO          reduce using rule 77 (exp3 -> exp .)
    COMMA           reduce using rule 77 (exp3 -> exp .)
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85

  ! PLUS            [ reduce using rule 77 (exp3 -> exp .) ]
  ! MINUS           [ reduce using rule 77 (exp3 -> exp .) ]


state 122

    (63) exp -> exp PLUS exp1 .
    (66) exp1 -> exp1 . TIMES exp2
    (67) exp1 -> exp1 . DIVIDE exp2
    (68) exp1 -> exp1 . MODULO exp2
    (65) exp -> exp1 .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! reduce/reduce conflict for IF resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for RETURN resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for BREAK resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for ID_SC resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for ID_LI resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for INCREMENT resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for DECREMENT resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for ID resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for FOR resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for DO resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for LPAREN resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for SUB resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for $end resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for RBRACE resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for GT resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for LT resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for EQ resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for GE resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for LE resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for NE resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for CMP resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for SEQ resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for SNE resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for SLT resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for SGT resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for SLE resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for SGE resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for RPAREN resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for XOR resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for MINUS resolved using rule 63 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for COMMA resolved using rule 63 (exp -> exp PLUS exp1 .)
    XOR             reduce using rule 63 (exp -> exp PLUS exp1 .)
    PLUS            reduce using rule 63 (exp -> exp PLUS exp1 .)
    MINUS           reduce using rule 63 (exp -> exp PLUS exp1 .)
    SEMICOLON       reduce using rule 63 (exp -> exp PLUS exp1 .)
    RPAREN          reduce using rule 63 (exp -> exp PLUS exp1 .)
    IF              reduce using rule 63 (exp -> exp PLUS exp1 .)
    RETURN          reduce using rule 63 (exp -> exp PLUS exp1 .)
    BREAK           reduce using rule 63 (exp -> exp PLUS exp1 .)
    CONTINUE        reduce using rule 63 (exp -> exp PLUS exp1 .)
    ID_SC           reduce using rule 63 (exp -> exp PLUS exp1 .)
    ID_LI           reduce using rule 63 (exp -> exp PLUS exp1 .)
    INCREMENT       reduce using rule 63 (exp -> exp PLUS exp1 .)
    DECREMENT       reduce using rule 63 (exp -> exp PLUS exp1 .)
    ID              reduce using rule 63 (exp -> exp PLUS exp1 .)
    FOR             reduce using rule 63 (exp -> exp PLUS exp1 .)
    DO              reduce using rule 63 (exp -> exp PLUS exp1 .)
    LPAREN          reduce using rule 63 (exp -> exp PLUS exp1 .)
    SUB             reduce using rule 63 (exp -> exp PLUS exp1 .)
    $end            reduce using rule 63 (exp -> exp PLUS exp1 .)
    RBRACE          reduce using rule 63 (exp -> exp PLUS exp1 .)
    GT              reduce using rule 63 (exp -> exp PLUS exp1 .)
    LT              reduce using rule 63 (exp -> exp PLUS exp1 .)
    EQ              reduce using rule 63 (exp -> exp PLUS exp1 .)
    GE              reduce using rule 63 (exp -> exp PLUS exp1 .)
    LE              reduce using rule 63 (exp -> exp PLUS exp1 .)
    NE              reduce using rule 63 (exp -> exp PLUS exp1 .)
    CMP             reduce using rule 63 (exp -> exp PLUS exp1 .)
    SEQ             reduce using rule 63 (exp -> exp PLUS exp1 .)
    SNE             reduce using rule 63 (exp -> exp PLUS exp1 .)
    SLT             reduce using rule 63 (exp -> exp PLUS exp1 .)
    SGT             reduce using rule 63 (exp -> exp PLUS exp1 .)
    SLE             reduce using rule 63 (exp -> exp PLUS exp1 .)
    SGE             reduce using rule 63 (exp -> exp PLUS exp1 .)
    COMMA           reduce using rule 63 (exp -> exp PLUS exp1 .)
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULO          shift and go to state 88

  ! TIMES           [ reduce using rule 63 (exp -> exp PLUS exp1 .) ]
  ! DIVIDE          [ reduce using rule 63 (exp -> exp PLUS exp1 .) ]
  ! MODULO          [ reduce using rule 63 (exp -> exp PLUS exp1 .) ]
  ! IF              [ reduce using rule 65 (exp -> exp1 .) ]
  ! RETURN          [ reduce using rule 65 (exp -> exp1 .) ]
  ! BREAK           [ reduce using rule 65 (exp -> exp1 .) ]
  ! CONTINUE        [ reduce using rule 65 (exp -> exp1 .) ]
  ! ID_SC           [ reduce using rule 65 (exp -> exp1 .) ]
  ! ID_LI           [ reduce using rule 65 (exp -> exp1 .) ]
  ! INCREMENT       [ reduce using rule 65 (exp -> exp1 .) ]
  ! DECREMENT       [ reduce using rule 65 (exp -> exp1 .) ]
  ! ID              [ reduce using rule 65 (exp -> exp1 .) ]
  ! FOR             [ reduce using rule 65 (exp -> exp1 .) ]
  ! DO              [ reduce using rule 65 (exp -> exp1 .) ]
  ! LPAREN          [ reduce using rule 65 (exp -> exp1 .) ]
  ! SUB             [ reduce using rule 65 (exp -> exp1 .) ]
  ! $end            [ reduce using rule 65 (exp -> exp1 .) ]
  ! RBRACE          [ reduce using rule 65 (exp -> exp1 .) ]
  ! GT              [ reduce using rule 65 (exp -> exp1 .) ]
  ! LT              [ reduce using rule 65 (exp -> exp1 .) ]
  ! EQ              [ reduce using rule 65 (exp -> exp1 .) ]
  ! GE              [ reduce using rule 65 (exp -> exp1 .) ]
  ! LE              [ reduce using rule 65 (exp -> exp1 .) ]
  ! NE              [ reduce using rule 65 (exp -> exp1 .) ]
  ! CMP             [ reduce using rule 65 (exp -> exp1 .) ]
  ! SEQ             [ reduce using rule 65 (exp -> exp1 .) ]
  ! SNE             [ reduce using rule 65 (exp -> exp1 .) ]
  ! SLT             [ reduce using rule 65 (exp -> exp1 .) ]
  ! SGT             [ reduce using rule 65 (exp -> exp1 .) ]
  ! SLE             [ reduce using rule 65 (exp -> exp1 .) ]
  ! SGE             [ reduce using rule 65 (exp -> exp1 .) ]
  ! RPAREN          [ reduce using rule 65 (exp -> exp1 .) ]
  ! SEMICOLON       [ reduce using rule 65 (exp -> exp1 .) ]
  ! XOR             [ reduce using rule 65 (exp -> exp1 .) ]
  ! TIMES           [ reduce using rule 65 (exp -> exp1 .) ]
  ! DIVIDE          [ reduce using rule 65 (exp -> exp1 .) ]
  ! MODULO          [ reduce using rule 65 (exp -> exp1 .) ]
  ! PLUS            [ reduce using rule 65 (exp -> exp1 .) ]
  ! MINUS           [ reduce using rule 65 (exp -> exp1 .) ]
  ! COMMA           [ reduce using rule 65 (exp -> exp1 .) ]


state 123

    (64) exp -> exp MINUS exp1 .
    (66) exp1 -> exp1 . TIMES exp2
    (67) exp1 -> exp1 . DIVIDE exp2
    (68) exp1 -> exp1 . MODULO exp2
    (65) exp -> exp1 .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! reduce/reduce conflict for IF resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for RETURN resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for BREAK resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for ID_SC resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for ID_LI resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for INCREMENT resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for DECREMENT resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for ID resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for FOR resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for DO resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for LPAREN resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for SUB resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for $end resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for RBRACE resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for GT resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for LT resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for EQ resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for GE resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for LE resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for NE resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for CMP resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for SEQ resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for SNE resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for SLT resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for SGT resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for SLE resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for SGE resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for RPAREN resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for XOR resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for MINUS resolved using rule 64 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for COMMA resolved using rule 64 (exp -> exp MINUS exp1 .)
    XOR             reduce using rule 64 (exp -> exp MINUS exp1 .)
    PLUS            reduce using rule 64 (exp -> exp MINUS exp1 .)
    MINUS           reduce using rule 64 (exp -> exp MINUS exp1 .)
    SEMICOLON       reduce using rule 64 (exp -> exp MINUS exp1 .)
    RPAREN          reduce using rule 64 (exp -> exp MINUS exp1 .)
    IF              reduce using rule 64 (exp -> exp MINUS exp1 .)
    RETURN          reduce using rule 64 (exp -> exp MINUS exp1 .)
    BREAK           reduce using rule 64 (exp -> exp MINUS exp1 .)
    CONTINUE        reduce using rule 64 (exp -> exp MINUS exp1 .)
    ID_SC           reduce using rule 64 (exp -> exp MINUS exp1 .)
    ID_LI           reduce using rule 64 (exp -> exp MINUS exp1 .)
    INCREMENT       reduce using rule 64 (exp -> exp MINUS exp1 .)
    DECREMENT       reduce using rule 64 (exp -> exp MINUS exp1 .)
    ID              reduce using rule 64 (exp -> exp MINUS exp1 .)
    FOR             reduce using rule 64 (exp -> exp MINUS exp1 .)
    DO              reduce using rule 64 (exp -> exp MINUS exp1 .)
    LPAREN          reduce using rule 64 (exp -> exp MINUS exp1 .)
    SUB             reduce using rule 64 (exp -> exp MINUS exp1 .)
    $end            reduce using rule 64 (exp -> exp MINUS exp1 .)
    RBRACE          reduce using rule 64 (exp -> exp MINUS exp1 .)
    GT              reduce using rule 64 (exp -> exp MINUS exp1 .)
    LT              reduce using rule 64 (exp -> exp MINUS exp1 .)
    EQ              reduce using rule 64 (exp -> exp MINUS exp1 .)
    GE              reduce using rule 64 (exp -> exp MINUS exp1 .)
    LE              reduce using rule 64 (exp -> exp MINUS exp1 .)
    NE              reduce using rule 64 (exp -> exp MINUS exp1 .)
    CMP             reduce using rule 64 (exp -> exp MINUS exp1 .)
    SEQ             reduce using rule 64 (exp -> exp MINUS exp1 .)
    SNE             reduce using rule 64 (exp -> exp MINUS exp1 .)
    SLT             reduce using rule 64 (exp -> exp MINUS exp1 .)
    SGT             reduce using rule 64 (exp -> exp MINUS exp1 .)
    SLE             reduce using rule 64 (exp -> exp MINUS exp1 .)
    SGE             reduce using rule 64 (exp -> exp MINUS exp1 .)
    COMMA           reduce using rule 64 (exp -> exp MINUS exp1 .)
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULO          shift and go to state 88

  ! TIMES           [ reduce using rule 64 (exp -> exp MINUS exp1 .) ]
  ! DIVIDE          [ reduce using rule 64 (exp -> exp MINUS exp1 .) ]
  ! MODULO          [ reduce using rule 64 (exp -> exp MINUS exp1 .) ]
  ! IF              [ reduce using rule 65 (exp -> exp1 .) ]
  ! RETURN          [ reduce using rule 65 (exp -> exp1 .) ]
  ! BREAK           [ reduce using rule 65 (exp -> exp1 .) ]
  ! CONTINUE        [ reduce using rule 65 (exp -> exp1 .) ]
  ! ID_SC           [ reduce using rule 65 (exp -> exp1 .) ]
  ! ID_LI           [ reduce using rule 65 (exp -> exp1 .) ]
  ! INCREMENT       [ reduce using rule 65 (exp -> exp1 .) ]
  ! DECREMENT       [ reduce using rule 65 (exp -> exp1 .) ]
  ! ID              [ reduce using rule 65 (exp -> exp1 .) ]
  ! FOR             [ reduce using rule 65 (exp -> exp1 .) ]
  ! DO              [ reduce using rule 65 (exp -> exp1 .) ]
  ! LPAREN          [ reduce using rule 65 (exp -> exp1 .) ]
  ! SUB             [ reduce using rule 65 (exp -> exp1 .) ]
  ! $end            [ reduce using rule 65 (exp -> exp1 .) ]
  ! RBRACE          [ reduce using rule 65 (exp -> exp1 .) ]
  ! GT              [ reduce using rule 65 (exp -> exp1 .) ]
  ! LT              [ reduce using rule 65 (exp -> exp1 .) ]
  ! EQ              [ reduce using rule 65 (exp -> exp1 .) ]
  ! GE              [ reduce using rule 65 (exp -> exp1 .) ]
  ! LE              [ reduce using rule 65 (exp -> exp1 .) ]
  ! NE              [ reduce using rule 65 (exp -> exp1 .) ]
  ! CMP             [ reduce using rule 65 (exp -> exp1 .) ]
  ! SEQ             [ reduce using rule 65 (exp -> exp1 .) ]
  ! SNE             [ reduce using rule 65 (exp -> exp1 .) ]
  ! SLT             [ reduce using rule 65 (exp -> exp1 .) ]
  ! SGT             [ reduce using rule 65 (exp -> exp1 .) ]
  ! SLE             [ reduce using rule 65 (exp -> exp1 .) ]
  ! SGE             [ reduce using rule 65 (exp -> exp1 .) ]
  ! RPAREN          [ reduce using rule 65 (exp -> exp1 .) ]
  ! SEMICOLON       [ reduce using rule 65 (exp -> exp1 .) ]
  ! XOR             [ reduce using rule 65 (exp -> exp1 .) ]
  ! TIMES           [ reduce using rule 65 (exp -> exp1 .) ]
  ! DIVIDE          [ reduce using rule 65 (exp -> exp1 .) ]
  ! MODULO          [ reduce using rule 65 (exp -> exp1 .) ]
  ! PLUS            [ reduce using rule 65 (exp -> exp1 .) ]
  ! MINUS           [ reduce using rule 65 (exp -> exp1 .) ]
  ! COMMA           [ reduce using rule 65 (exp -> exp1 .) ]


state 124

    (66) exp1 -> exp1 TIMES exp2 .
    (69) exp1 -> exp2 .

  ! reduce/reduce conflict for IF resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for RETURN resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for BREAK resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for ID_SC resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for ID_LI resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for INCREMENT resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for DECREMENT resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for ID resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for FOR resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for DO resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for LPAREN resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for SUB resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for $end resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for RBRACE resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for GT resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for LT resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for EQ resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for GE resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for LE resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for NE resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for CMP resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for SEQ resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for SNE resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for SLT resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for SGT resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for SLE resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for SGE resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for RPAREN resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for XOR resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for TIMES resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for MODULO resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for PLUS resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for MINUS resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for COMMA resolved using rule 66 (exp1 -> exp1 TIMES exp2 .)
    XOR             reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    TIMES           reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    DIVIDE          reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    MODULO          reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    PLUS            reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    MINUS           reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    SEMICOLON       reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    RPAREN          reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    IF              reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    RETURN          reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    BREAK           reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    CONTINUE        reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    ID_SC           reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    ID_LI           reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    INCREMENT       reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    DECREMENT       reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    ID              reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    FOR             reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    DO              reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    LPAREN          reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    SUB             reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    $end            reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    RBRACE          reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    GT              reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    LT              reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    EQ              reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    GE              reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    LE              reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    NE              reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    CMP             reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    SEQ             reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    SNE             reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    SLT             reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    SGT             reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    SLE             reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    SGE             reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)
    COMMA           reduce using rule 66 (exp1 -> exp1 TIMES exp2 .)

  ! IF              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! RETURN          [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! BREAK           [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! CONTINUE        [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! ID_SC           [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! ID_LI           [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! INCREMENT       [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! DECREMENT       [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! ID              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! FOR             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! DO              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! LPAREN          [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SUB             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! $end            [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! RBRACE          [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! GT              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! LT              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! EQ              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! GE              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! LE              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! NE              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! CMP             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SEQ             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SNE             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SLT             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SGT             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SLE             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SGE             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! RPAREN          [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SEMICOLON       [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! XOR             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! TIMES           [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! DIVIDE          [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! MODULO          [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! PLUS            [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! MINUS           [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! COMMA           [ reduce using rule 69 (exp1 -> exp2 .) ]


state 125

    (67) exp1 -> exp1 DIVIDE exp2 .
    (69) exp1 -> exp2 .

  ! reduce/reduce conflict for IF resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for RETURN resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for BREAK resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for ID_SC resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for ID_LI resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for INCREMENT resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for DECREMENT resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for ID resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for FOR resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for DO resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for LPAREN resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for SUB resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for $end resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for RBRACE resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for GT resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for LT resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for EQ resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for GE resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for LE resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for NE resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for CMP resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for SEQ resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for SNE resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for SLT resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for SGT resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for SLE resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for SGE resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for RPAREN resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for XOR resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for TIMES resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for MODULO resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for PLUS resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for MINUS resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for COMMA resolved using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    XOR             reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    TIMES           reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    DIVIDE          reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    MODULO          reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    PLUS            reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    MINUS           reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    SEMICOLON       reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    RPAREN          reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    IF              reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    RETURN          reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    BREAK           reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    CONTINUE        reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    ID_SC           reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    ID_LI           reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    INCREMENT       reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    DECREMENT       reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    ID              reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    FOR             reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    DO              reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    LPAREN          reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    SUB             reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    $end            reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    RBRACE          reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    GT              reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    LT              reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    EQ              reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    GE              reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    LE              reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    NE              reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    CMP             reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    SEQ             reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    SNE             reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    SLT             reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    SGT             reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    SLE             reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    SGE             reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)
    COMMA           reduce using rule 67 (exp1 -> exp1 DIVIDE exp2 .)

  ! IF              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! RETURN          [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! BREAK           [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! CONTINUE        [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! ID_SC           [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! ID_LI           [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! INCREMENT       [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! DECREMENT       [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! ID              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! FOR             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! DO              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! LPAREN          [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SUB             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! $end            [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! RBRACE          [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! GT              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! LT              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! EQ              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! GE              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! LE              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! NE              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! CMP             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SEQ             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SNE             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SLT             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SGT             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SLE             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SGE             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! RPAREN          [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SEMICOLON       [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! XOR             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! TIMES           [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! DIVIDE          [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! MODULO          [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! PLUS            [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! MINUS           [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! COMMA           [ reduce using rule 69 (exp1 -> exp2 .) ]


state 126

    (68) exp1 -> exp1 MODULO exp2 .
    (69) exp1 -> exp2 .

  ! reduce/reduce conflict for IF resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for RETURN resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for BREAK resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for ID_SC resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for ID_LI resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for INCREMENT resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for DECREMENT resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for ID resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for FOR resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for DO resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for LPAREN resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for SUB resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for $end resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for RBRACE resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for GT resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for LT resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for EQ resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for GE resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for LE resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for NE resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for CMP resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for SEQ resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for SNE resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for SLT resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for SGT resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for SLE resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for SGE resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for RPAREN resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for XOR resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for TIMES resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for MODULO resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for PLUS resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for MINUS resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for COMMA resolved using rule 68 (exp1 -> exp1 MODULO exp2 .)
    XOR             reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    TIMES           reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    DIVIDE          reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    MODULO          reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    PLUS            reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    MINUS           reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    SEMICOLON       reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    RPAREN          reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    IF              reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    RETURN          reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    BREAK           reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    CONTINUE        reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    ID_SC           reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    ID_LI           reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    INCREMENT       reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    DECREMENT       reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    ID              reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    FOR             reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    DO              reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    LPAREN          reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    SUB             reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    $end            reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    RBRACE          reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    GT              reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    LT              reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    EQ              reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    GE              reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    LE              reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    NE              reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    CMP             reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    SEQ             reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    SNE             reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    SLT             reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    SGT             reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    SLE             reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    SGE             reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)
    COMMA           reduce using rule 68 (exp1 -> exp1 MODULO exp2 .)

  ! IF              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! RETURN          [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! BREAK           [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! CONTINUE        [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! ID_SC           [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! ID_LI           [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! INCREMENT       [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! DECREMENT       [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! ID              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! FOR             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! DO              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! LPAREN          [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SUB             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! $end            [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! RBRACE          [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! GT              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! LT              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! EQ              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! GE              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! LE              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! NE              [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! CMP             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SEQ             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SNE             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SLT             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SGT             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SLE             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SGE             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! RPAREN          [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! SEMICOLON       [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! XOR             [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! TIMES           [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! DIVIDE          [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! MODULO          [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! PLUS            [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! MINUS           [ reduce using rule 69 (exp1 -> exp2 .) ]
  ! COMMA           [ reduce using rule 69 (exp1 -> exp2 .) ]


state 127

    (70) exp2 -> exp3 XOR exp2 .
    (69) exp1 -> exp2 .

  ! reduce/reduce conflict for IF resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for RETURN resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for BREAK resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for ID_SC resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for ID_LI resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for INCREMENT resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for DECREMENT resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for ID resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for FOR resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for DO resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for LPAREN resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for SUB resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for $end resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for RBRACE resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for GT resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for LT resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for EQ resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for GE resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for LE resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for NE resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for CMP resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for SEQ resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for SNE resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for SLT resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for SGT resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for SLE resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for SGE resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for RPAREN resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for XOR resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for TIMES resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for MODULO resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for PLUS resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for MINUS resolved using rule 69 (exp1 -> exp2 .)
  ! reduce/reduce conflict for COMMA resolved using rule 69 (exp1 -> exp2 .)
    IF              reduce using rule 69 (exp1 -> exp2 .)
    RETURN          reduce using rule 69 (exp1 -> exp2 .)
    BREAK           reduce using rule 69 (exp1 -> exp2 .)
    CONTINUE        reduce using rule 69 (exp1 -> exp2 .)
    ID_SC           reduce using rule 69 (exp1 -> exp2 .)
    ID_LI           reduce using rule 69 (exp1 -> exp2 .)
    INCREMENT       reduce using rule 69 (exp1 -> exp2 .)
    DECREMENT       reduce using rule 69 (exp1 -> exp2 .)
    ID              reduce using rule 69 (exp1 -> exp2 .)
    FOR             reduce using rule 69 (exp1 -> exp2 .)
    DO              reduce using rule 69 (exp1 -> exp2 .)
    LPAREN          reduce using rule 69 (exp1 -> exp2 .)
    SUB             reduce using rule 69 (exp1 -> exp2 .)
    $end            reduce using rule 69 (exp1 -> exp2 .)
    RBRACE          reduce using rule 69 (exp1 -> exp2 .)
    GT              reduce using rule 69 (exp1 -> exp2 .)
    LT              reduce using rule 69 (exp1 -> exp2 .)
    EQ              reduce using rule 69 (exp1 -> exp2 .)
    GE              reduce using rule 69 (exp1 -> exp2 .)
    LE              reduce using rule 69 (exp1 -> exp2 .)
    NE              reduce using rule 69 (exp1 -> exp2 .)
    CMP             reduce using rule 69 (exp1 -> exp2 .)
    SEQ             reduce using rule 69 (exp1 -> exp2 .)
    SNE             reduce using rule 69 (exp1 -> exp2 .)
    SLT             reduce using rule 69 (exp1 -> exp2 .)
    SGT             reduce using rule 69 (exp1 -> exp2 .)
    SLE             reduce using rule 69 (exp1 -> exp2 .)
    SGE             reduce using rule 69 (exp1 -> exp2 .)
    RPAREN          reduce using rule 69 (exp1 -> exp2 .)
    SEMICOLON       reduce using rule 69 (exp1 -> exp2 .)
    XOR             reduce using rule 69 (exp1 -> exp2 .)
    TIMES           reduce using rule 69 (exp1 -> exp2 .)
    DIVIDE          reduce using rule 69 (exp1 -> exp2 .)
    MODULO          reduce using rule 69 (exp1 -> exp2 .)
    PLUS            reduce using rule 69 (exp1 -> exp2 .)
    MINUS           reduce using rule 69 (exp1 -> exp2 .)
    COMMA           reduce using rule 69 (exp1 -> exp2 .)

  ! XOR             [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! TIMES           [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! DIVIDE          [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! MODULO          [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! PLUS            [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! MINUS           [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! SEMICOLON       [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! RPAREN          [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! IF              [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! RETURN          [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! BREAK           [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! CONTINUE        [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! ID_SC           [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! ID_LI           [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! INCREMENT       [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! DECREMENT       [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! ID              [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! FOR             [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! DO              [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! LPAREN          [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! SUB             [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! $end            [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! RBRACE          [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! GT              [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! LT              [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! EQ              [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! GE              [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! LE              [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! NE              [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! CMP             [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! SEQ             [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! SNE             [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! SLT             [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! SGT             [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! SLE             [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! SGE             [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]
  ! COMMA           [ reduce using rule 70 (exp2 -> exp3 XOR exp2 .) ]


state 128

    (72) exp3 -> LPAREN arithmetic RPAREN .

    XOR             reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    TIMES           reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    DIVIDE          reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    MODULO          reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    PLUS            reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    MINUS           reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    SEMICOLON       reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    RPAREN          reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    IF              reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    RETURN          reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    BREAK           reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    CONTINUE        reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    ID_SC           reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    ID_LI           reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    INCREMENT       reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    DECREMENT       reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    ID              reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    FOR             reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    DO              reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    LPAREN          reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    SUB             reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    $end            reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    RBRACE          reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    GT              reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    LT              reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    EQ              reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    GE              reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    LE              reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    NE              reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    CMP             reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    SEQ             reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    SNE             reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    SLT             reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    SGT             reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    SLE             reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    SGE             reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)
    COMMA           reduce using rule 72 (exp3 -> LPAREN arithmetic RPAREN .)


state 129

    (14) if -> IF LPAREN exp_condition RPAREN . LBRACE blockcode RBRACE
    (16) if -> IF LPAREN exp_condition RPAREN . LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if -> IF LPAREN exp_condition RPAREN . LBRACE blockcode RBRACE elsif

    LBRACE          shift and go to state 142


state 130

    (25) for -> FOR LPAREN for_assignments SEMICOLON . exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (34) exp_condition -> . attcond GT attcond
    (35) exp_condition -> . attcond LT attcond
    (36) exp_condition -> . attcond EQ attcond
    (37) exp_condition -> . attcond GE attcond
    (38) exp_condition -> . attcond LE attcond
    (39) exp_condition -> . attcond NE attcond
    (40) exp_condition -> . attcond
    (41) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (42) exp_condition -> . attcond CMP attcond
    (43) exp_condition -> . attcond SEQ attcond
    (44) exp_condition -> . attcond SNE attcond
    (45) exp_condition -> . attcond SLT attcond
    (46) exp_condition -> . attcond SGT attcond
    (47) exp_condition -> . attcond SLE attcond
    (48) exp_condition -> . attcond SGE attcond
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE

    LPAREN          shift and go to state 31
    NUMBER          shift and go to state 35
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    exp_condition                  shift and go to state 143
    attcond                        shift and go to state 33
    exp_assignment                 shift and go to state 34
    true                           shift and go to state 36
    false                          shift and go to state 37

state 131

    (27) for_assignments -> exp_assignment COMMA . for_assignments
    (26) for_assignments -> . exp_assignment
    (27) for_assignments -> . exp_assignment COMMA for_assignments
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT

    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22

    exp_assignment                 shift and go to state 99
    for_assignments                shift and go to state 144

state 132

    (28) dowhile -> DO LBRACE blockcode RBRACE . WHILE LPAREN exp_condition RPAREN

    WHILE           shift and go to state 145


state 133

    (15) if -> command IF LPAREN exp_condition RPAREN .
    (14) if -> IF LPAREN exp_condition RPAREN . LBRACE blockcode RBRACE
    (16) if -> IF LPAREN exp_condition RPAREN . LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if -> IF LPAREN exp_condition RPAREN . LBRACE blockcode RBRACE elsif

    IF              reduce using rule 15 (if -> command IF LPAREN exp_condition RPAREN .)
    RETURN          reduce using rule 15 (if -> command IF LPAREN exp_condition RPAREN .)
    BREAK           reduce using rule 15 (if -> command IF LPAREN exp_condition RPAREN .)
    CONTINUE        reduce using rule 15 (if -> command IF LPAREN exp_condition RPAREN .)
    ID_SC           reduce using rule 15 (if -> command IF LPAREN exp_condition RPAREN .)
    ID_LI           reduce using rule 15 (if -> command IF LPAREN exp_condition RPAREN .)
    INCREMENT       reduce using rule 15 (if -> command IF LPAREN exp_condition RPAREN .)
    DECREMENT       reduce using rule 15 (if -> command IF LPAREN exp_condition RPAREN .)
    ID              reduce using rule 15 (if -> command IF LPAREN exp_condition RPAREN .)
    FOR             reduce using rule 15 (if -> command IF LPAREN exp_condition RPAREN .)
    DO              reduce using rule 15 (if -> command IF LPAREN exp_condition RPAREN .)
    LPAREN          reduce using rule 15 (if -> command IF LPAREN exp_condition RPAREN .)
    SUB             reduce using rule 15 (if -> command IF LPAREN exp_condition RPAREN .)
    $end            reduce using rule 15 (if -> command IF LPAREN exp_condition RPAREN .)
    RBRACE          reduce using rule 15 (if -> command IF LPAREN exp_condition RPAREN .)
    LBRACE          shift and go to state 142


state 134

    (30) function -> SUB ID LPAREN RPAREN LBRACE . blockcode RBRACE
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (15) if -> . command IF LPAREN exp_condition RPAREN
    (16) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE

    RETURN          shift and go to state 12
    BREAK           shift and go to state 13
    CONTINUE        shift and go to state 14
    IF              shift and go to state 18
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    ID              shift and go to state 6
    FOR             shift and go to state 23
    DO              shift and go to state 24
    LPAREN          shift and go to state 7

    blockcode                      shift and go to state 146
    command                        shift and go to state 4
    interations                    shift and go to state 8
    if                             shift and go to state 9
    exp_assignment                 shift and go to state 10
    call                           shift and go to state 11
    for                            shift and go to state 15
    dowhile                        shift and go to state 16
    while                          shift and go to state 17

state 135

    (31) function -> SUB ID LPAREN function_assignments RPAREN . LBRACE blockcode RBRACE

    LBRACE          shift and go to state 147


state 136

    (33) function_assignments -> exp_assignment COMMA function_assignments .

    RPAREN          reduce using rule 33 (function_assignments -> exp_assignment COMMA function_assignments .)


state 137

    (41) exp_condition -> LPAREN exp_condition RPAREN logic . exp_condition_logic
    (49) exp_condition_logic -> . LPAREN exp_condition RPAREN
    (50) exp_condition_logic -> . LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN

    LPAREN          shift and go to state 148

    exp_condition_logic            shift and go to state 149

state 138

    (51) logic -> LAND .

    LPAREN          reduce using rule 51 (logic -> LAND .)


state 139

    (52) logic -> LOR .

    LPAREN          reduce using rule 52 (logic -> LOR .)


state 140

    (53) logic -> LNOT .

    LPAREN          reduce using rule 53 (logic -> LNOT .)


state 141

    (29) while -> LPAREN exp_condition RPAREN LBRACE blockcode . RBRACE

    RBRACE          shift and go to state 150


state 142

    (14) if -> IF LPAREN exp_condition RPAREN LBRACE . blockcode RBRACE
    (16) if -> IF LPAREN exp_condition RPAREN LBRACE . blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if -> IF LPAREN exp_condition RPAREN LBRACE . blockcode RBRACE elsif
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (15) if -> . command IF LPAREN exp_condition RPAREN
    (16) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE

    RETURN          shift and go to state 12
    BREAK           shift and go to state 13
    CONTINUE        shift and go to state 14
    IF              shift and go to state 18
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    ID              shift and go to state 6
    FOR             shift and go to state 23
    DO              shift and go to state 24
    LPAREN          shift and go to state 7

    blockcode                      shift and go to state 151
    command                        shift and go to state 4
    interations                    shift and go to state 8
    if                             shift and go to state 9
    exp_assignment                 shift and go to state 10
    call                           shift and go to state 11
    for                            shift and go to state 15
    dowhile                        shift and go to state 16
    while                          shift and go to state 17

state 143

    (25) for -> FOR LPAREN for_assignments SEMICOLON exp_condition . SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE

    SEMICOLON       shift and go to state 152


state 144

    (27) for_assignments -> exp_assignment COMMA for_assignments .

    SEMICOLON       reduce using rule 27 (for_assignments -> exp_assignment COMMA for_assignments .)
    RPAREN          reduce using rule 27 (for_assignments -> exp_assignment COMMA for_assignments .)


state 145

    (28) dowhile -> DO LBRACE blockcode RBRACE WHILE . LPAREN exp_condition RPAREN

    LPAREN          shift and go to state 153


state 146

    (30) function -> SUB ID LPAREN RPAREN LBRACE blockcode . RBRACE

    RBRACE          shift and go to state 154


state 147

    (31) function -> SUB ID LPAREN function_assignments RPAREN LBRACE . blockcode RBRACE
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (15) if -> . command IF LPAREN exp_condition RPAREN
    (16) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE

    RETURN          shift and go to state 12
    BREAK           shift and go to state 13
    CONTINUE        shift and go to state 14
    IF              shift and go to state 18
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    ID              shift and go to state 6
    FOR             shift and go to state 23
    DO              shift and go to state 24
    LPAREN          shift and go to state 7

    blockcode                      shift and go to state 155
    command                        shift and go to state 4
    interations                    shift and go to state 8
    if                             shift and go to state 9
    exp_assignment                 shift and go to state 10
    call                           shift and go to state 11
    for                            shift and go to state 15
    dowhile                        shift and go to state 16
    while                          shift and go to state 17

state 148

    (49) exp_condition_logic -> LPAREN . exp_condition RPAREN
    (50) exp_condition_logic -> LPAREN . exp_condition RPAREN logic LPAREN exp_condition RPAREN
    (34) exp_condition -> . attcond GT attcond
    (35) exp_condition -> . attcond LT attcond
    (36) exp_condition -> . attcond EQ attcond
    (37) exp_condition -> . attcond GE attcond
    (38) exp_condition -> . attcond LE attcond
    (39) exp_condition -> . attcond NE attcond
    (40) exp_condition -> . attcond
    (41) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (42) exp_condition -> . attcond CMP attcond
    (43) exp_condition -> . attcond SEQ attcond
    (44) exp_condition -> . attcond SNE attcond
    (45) exp_condition -> . attcond SLT attcond
    (46) exp_condition -> . attcond SGT attcond
    (47) exp_condition -> . attcond SLE attcond
    (48) exp_condition -> . attcond SGE attcond
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE

    LPAREN          shift and go to state 31
    NUMBER          shift and go to state 35
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    exp_condition                  shift and go to state 156
    attcond                        shift and go to state 33
    exp_assignment                 shift and go to state 34
    true                           shift and go to state 36
    false                          shift and go to state 37

state 149

    (41) exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .

    RPAREN          reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    XOR             reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    TIMES           reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    DIVIDE          reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    MODULO          reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    PLUS            reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    MINUS           reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    SEMICOLON       reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    IF              reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    RETURN          reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    BREAK           reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    CONTINUE        reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    ID_SC           reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    ID_LI           reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    INCREMENT       reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    DECREMENT       reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    ID              reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    FOR             reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    DO              reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    LPAREN          reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    SUB             reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    $end            reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    RBRACE          reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    GT              reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    LT              reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    EQ              reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    GE              reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    LE              reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    NE              reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    CMP             reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    SEQ             reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    SNE             reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    SLT             reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    SGT             reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    SLE             reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    SGE             reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    COMMA           reduce using rule 41 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)


state 150

    (29) while -> LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .

    IF              reduce using rule 29 (while -> LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    RETURN          reduce using rule 29 (while -> LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    BREAK           reduce using rule 29 (while -> LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    CONTINUE        reduce using rule 29 (while -> LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    ID_SC           reduce using rule 29 (while -> LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    ID_LI           reduce using rule 29 (while -> LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    INCREMENT       reduce using rule 29 (while -> LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    DECREMENT       reduce using rule 29 (while -> LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    ID              reduce using rule 29 (while -> LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    FOR             reduce using rule 29 (while -> LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    DO              reduce using rule 29 (while -> LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    LPAREN          reduce using rule 29 (while -> LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    SUB             reduce using rule 29 (while -> LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    $end            reduce using rule 29 (while -> LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    RBRACE          reduce using rule 29 (while -> LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)


state 151

    (14) if -> IF LPAREN exp_condition RPAREN LBRACE blockcode . RBRACE
    (16) if -> IF LPAREN exp_condition RPAREN LBRACE blockcode . RBRACE ELSE LBRACE blockcode RBRACE
    (17) if -> IF LPAREN exp_condition RPAREN LBRACE blockcode . RBRACE elsif

    RBRACE          shift and go to state 157


state 152

    (25) for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON . for_assignments RPAREN LBRACE blockcode RBRACE
    (26) for_assignments -> . exp_assignment
    (27) for_assignments -> . exp_assignment COMMA for_assignments
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT

    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22

    for_assignments                shift and go to state 158
    exp_assignment                 shift and go to state 99

state 153

    (28) dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN . exp_condition RPAREN
    (34) exp_condition -> . attcond GT attcond
    (35) exp_condition -> . attcond LT attcond
    (36) exp_condition -> . attcond EQ attcond
    (37) exp_condition -> . attcond GE attcond
    (38) exp_condition -> . attcond LE attcond
    (39) exp_condition -> . attcond NE attcond
    (40) exp_condition -> . attcond
    (41) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (42) exp_condition -> . attcond CMP attcond
    (43) exp_condition -> . attcond SEQ attcond
    (44) exp_condition -> . attcond SNE attcond
    (45) exp_condition -> . attcond SLT attcond
    (46) exp_condition -> . attcond SGT attcond
    (47) exp_condition -> . attcond SLE attcond
    (48) exp_condition -> . attcond SGE attcond
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE

    LPAREN          shift and go to state 31
    NUMBER          shift and go to state 35
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    exp_condition                  shift and go to state 159
    attcond                        shift and go to state 33
    exp_assignment                 shift and go to state 34
    true                           shift and go to state 36
    false                          shift and go to state 37

state 154

    (30) function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .

    SUB             reduce using rule 30 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    RETURN          reduce using rule 30 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    BREAK           reduce using rule 30 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    CONTINUE        reduce using rule 30 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    IF              reduce using rule 30 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    ID_SC           reduce using rule 30 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    ID_LI           reduce using rule 30 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    INCREMENT       reduce using rule 30 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    DECREMENT       reduce using rule 30 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    ID              reduce using rule 30 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    FOR             reduce using rule 30 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    DO              reduce using rule 30 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    LPAREN          reduce using rule 30 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    $end            reduce using rule 30 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)


state 155

    (31) function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode . RBRACE

    RBRACE          shift and go to state 160


state 156

    (49) exp_condition_logic -> LPAREN exp_condition . RPAREN
    (50) exp_condition_logic -> LPAREN exp_condition . RPAREN logic LPAREN exp_condition RPAREN

    RPAREN          shift and go to state 161


state 157

    (14) if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .
    (16) if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE . ELSE LBRACE blockcode RBRACE
    (17) if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE . elsif
    (18) elsif -> . ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (19) elsif -> . ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2

    IF              reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    RETURN          reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    BREAK           reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    CONTINUE        reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    ID_SC           reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    ID_LI           reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    INCREMENT       reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    DECREMENT       reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    ID              reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    FOR             reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    DO              reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    LPAREN          reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    SUB             reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    $end            reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    RBRACE          reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    ELSE            shift and go to state 162
    ELSIF           shift and go to state 164

    elsif                          shift and go to state 163

state 158

    (25) for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments . RPAREN LBRACE blockcode RBRACE

    RPAREN          shift and go to state 165


state 159

    (28) dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition . RPAREN

    RPAREN          shift and go to state 166


state 160

    (31) function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .

    SUB             reduce using rule 31 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    RETURN          reduce using rule 31 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    BREAK           reduce using rule 31 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    CONTINUE        reduce using rule 31 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    IF              reduce using rule 31 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    ID_SC           reduce using rule 31 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    ID_LI           reduce using rule 31 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    INCREMENT       reduce using rule 31 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    DECREMENT       reduce using rule 31 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    ID              reduce using rule 31 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    FOR             reduce using rule 31 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    DO              reduce using rule 31 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    LPAREN          reduce using rule 31 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    $end            reduce using rule 31 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)


state 161

    (49) exp_condition_logic -> LPAREN exp_condition RPAREN .
    (50) exp_condition_logic -> LPAREN exp_condition RPAREN . logic LPAREN exp_condition RPAREN
    (51) logic -> . LAND
    (52) logic -> . LOR
    (53) logic -> . LNOT

    RPAREN          reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    XOR             reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    TIMES           reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    DIVIDE          reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    MODULO          reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    PLUS            reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    MINUS           reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    SEMICOLON       reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    IF              reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    RETURN          reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    BREAK           reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    CONTINUE        reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    ID_SC           reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    ID_LI           reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    INCREMENT       reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    DECREMENT       reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    ID              reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    FOR             reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    DO              reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    LPAREN          reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    SUB             reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    $end            reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    RBRACE          reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    GT              reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    LT              reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    EQ              reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    GE              reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    LE              reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    NE              reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    CMP             reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    SEQ             reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    SNE             reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    SLT             reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    SGT             reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    SLE             reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    SGE             reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    COMMA           reduce using rule 49 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    LAND            shift and go to state 138
    LOR             shift and go to state 139
    LNOT            shift and go to state 140

    logic                          shift and go to state 167

state 162

    (16) if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE . LBRACE blockcode RBRACE

    LBRACE          shift and go to state 168


state 163

    (17) if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif .

    IF              reduce using rule 17 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif .)
    RETURN          reduce using rule 17 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif .)
    BREAK           reduce using rule 17 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif .)
    CONTINUE        reduce using rule 17 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif .)
    ID_SC           reduce using rule 17 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif .)
    ID_LI           reduce using rule 17 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif .)
    INCREMENT       reduce using rule 17 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif .)
    DECREMENT       reduce using rule 17 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif .)
    ID              reduce using rule 17 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif .)
    FOR             reduce using rule 17 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif .)
    DO              reduce using rule 17 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif .)
    LPAREN          reduce using rule 17 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif .)
    SUB             reduce using rule 17 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif .)
    $end            reduce using rule 17 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif .)
    RBRACE          reduce using rule 17 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif .)


state 164

    (18) elsif -> ELSIF . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (19) elsif -> ELSIF . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2

    LPAREN          shift and go to state 169


state 165

    (25) for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN . LBRACE blockcode RBRACE

    LBRACE          shift and go to state 170


state 166

    (28) dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .

    IF              reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    RETURN          reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    BREAK           reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    CONTINUE        reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    ID_SC           reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    ID_LI           reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    INCREMENT       reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    DECREMENT       reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    ID              reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    FOR             reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    DO              reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    LPAREN          reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    SUB             reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    $end            reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    RBRACE          reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)


state 167

    (50) exp_condition_logic -> LPAREN exp_condition RPAREN logic . LPAREN exp_condition RPAREN

    LPAREN          shift and go to state 171


state 168

    (16) if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE . blockcode RBRACE
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (15) if -> . command IF LPAREN exp_condition RPAREN
    (16) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE

    RETURN          shift and go to state 12
    BREAK           shift and go to state 13
    CONTINUE        shift and go to state 14
    IF              shift and go to state 18
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    ID              shift and go to state 6
    FOR             shift and go to state 23
    DO              shift and go to state 24
    LPAREN          shift and go to state 7

    blockcode                      shift and go to state 172
    command                        shift and go to state 4
    interations                    shift and go to state 8
    if                             shift and go to state 9
    exp_assignment                 shift and go to state 10
    call                           shift and go to state 11
    for                            shift and go to state 15
    dowhile                        shift and go to state 16
    while                          shift and go to state 17

state 169

    (18) elsif -> ELSIF LPAREN . exp_condition RPAREN LBRACE blockcode RBRACE
    (19) elsif -> ELSIF LPAREN . exp_condition RPAREN LBRACE blockcode RBRACE elsif2
    (34) exp_condition -> . attcond GT attcond
    (35) exp_condition -> . attcond LT attcond
    (36) exp_condition -> . attcond EQ attcond
    (37) exp_condition -> . attcond GE attcond
    (38) exp_condition -> . attcond LE attcond
    (39) exp_condition -> . attcond NE attcond
    (40) exp_condition -> . attcond
    (41) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (42) exp_condition -> . attcond CMP attcond
    (43) exp_condition -> . attcond SEQ attcond
    (44) exp_condition -> . attcond SNE attcond
    (45) exp_condition -> . attcond SLT attcond
    (46) exp_condition -> . attcond SGT attcond
    (47) exp_condition -> . attcond SLE attcond
    (48) exp_condition -> . attcond SGE attcond
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE

    LPAREN          shift and go to state 31
    NUMBER          shift and go to state 35
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    exp_condition                  shift and go to state 173
    attcond                        shift and go to state 33
    exp_assignment                 shift and go to state 34
    true                           shift and go to state 36
    false                          shift and go to state 37

state 170

    (25) for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE . blockcode RBRACE
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (15) if -> . command IF LPAREN exp_condition RPAREN
    (16) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE

    RETURN          shift and go to state 12
    BREAK           shift and go to state 13
    CONTINUE        shift and go to state 14
    IF              shift and go to state 18
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    ID              shift and go to state 6
    FOR             shift and go to state 23
    DO              shift and go to state 24
    LPAREN          shift and go to state 7

    blockcode                      shift and go to state 174
    command                        shift and go to state 4
    interations                    shift and go to state 8
    if                             shift and go to state 9
    exp_assignment                 shift and go to state 10
    call                           shift and go to state 11
    for                            shift and go to state 15
    dowhile                        shift and go to state 16
    while                          shift and go to state 17

state 171

    (50) exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN . exp_condition RPAREN
    (34) exp_condition -> . attcond GT attcond
    (35) exp_condition -> . attcond LT attcond
    (36) exp_condition -> . attcond EQ attcond
    (37) exp_condition -> . attcond GE attcond
    (38) exp_condition -> . attcond LE attcond
    (39) exp_condition -> . attcond NE attcond
    (40) exp_condition -> . attcond
    (41) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (42) exp_condition -> . attcond CMP attcond
    (43) exp_condition -> . attcond SEQ attcond
    (44) exp_condition -> . attcond SNE attcond
    (45) exp_condition -> . attcond SLT attcond
    (46) exp_condition -> . attcond SGT attcond
    (47) exp_condition -> . attcond SLE attcond
    (48) exp_condition -> . attcond SGE attcond
    (78) attcond -> . exp_assignment
    (79) attcond -> . NUMBER
    (80) attcond -> . true
    (81) attcond -> . false
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (86) true -> . TRUE
    (87) false -> . FALSE

    LPAREN          shift and go to state 31
    NUMBER          shift and go to state 35
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39

    exp_condition                  shift and go to state 175
    attcond                        shift and go to state 33
    exp_assignment                 shift and go to state 34
    true                           shift and go to state 36
    false                          shift and go to state 37

state 172

    (16) if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode . RBRACE

    RBRACE          shift and go to state 176


state 173

    (18) elsif -> ELSIF LPAREN exp_condition . RPAREN LBRACE blockcode RBRACE
    (19) elsif -> ELSIF LPAREN exp_condition . RPAREN LBRACE blockcode RBRACE elsif2

    RPAREN          shift and go to state 177


state 174

    (25) for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode . RBRACE

    RBRACE          shift and go to state 178


state 175

    (50) exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition . RPAREN

    RPAREN          shift and go to state 179


state 176

    (16) if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .

    IF              reduce using rule 16 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    RETURN          reduce using rule 16 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    BREAK           reduce using rule 16 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    CONTINUE        reduce using rule 16 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    ID_SC           reduce using rule 16 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    ID_LI           reduce using rule 16 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    INCREMENT       reduce using rule 16 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    DECREMENT       reduce using rule 16 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    ID              reduce using rule 16 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    FOR             reduce using rule 16 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    DO              reduce using rule 16 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    LPAREN          reduce using rule 16 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    SUB             reduce using rule 16 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    $end            reduce using rule 16 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    RBRACE          reduce using rule 16 (if -> IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)


state 177

    (18) elsif -> ELSIF LPAREN exp_condition RPAREN . LBRACE blockcode RBRACE
    (19) elsif -> ELSIF LPAREN exp_condition RPAREN . LBRACE blockcode RBRACE elsif2

    LBRACE          shift and go to state 180


state 178

    (25) for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .

    IF              reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    RETURN          reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    BREAK           reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    CONTINUE        reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    ID_SC           reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    ID_LI           reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    INCREMENT       reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    DECREMENT       reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    ID              reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    FOR             reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    DO              reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    LPAREN          reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    SUB             reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    $end            reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    RBRACE          reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)


state 179

    (50) exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .

    RPAREN          reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    XOR             reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    TIMES           reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    DIVIDE          reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    MODULO          reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    PLUS            reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    MINUS           reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    SEMICOLON       reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    IF              reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    RETURN          reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    BREAK           reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    CONTINUE        reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    ID_SC           reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    ID_LI           reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    INCREMENT       reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    DECREMENT       reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    ID              reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    FOR             reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    DO              reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    LPAREN          reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    SUB             reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    $end            reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    RBRACE          reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    GT              reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    LT              reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    EQ              reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    GE              reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    LE              reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    NE              reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    CMP             reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    SEQ             reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    SNE             reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    SLT             reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    SGT             reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    SLE             reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    SGE             reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    COMMA           reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)


state 180

    (18) elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE . blockcode RBRACE
    (19) elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE . blockcode RBRACE elsif2
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (15) if -> . command IF LPAREN exp_condition RPAREN
    (16) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE

    RETURN          shift and go to state 12
    BREAK           shift and go to state 13
    CONTINUE        shift and go to state 14
    IF              shift and go to state 18
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    ID              shift and go to state 6
    FOR             shift and go to state 23
    DO              shift and go to state 24
    LPAREN          shift and go to state 7

    blockcode                      shift and go to state 181
    command                        shift and go to state 4
    interations                    shift and go to state 8
    if                             shift and go to state 9
    exp_assignment                 shift and go to state 10
    call                           shift and go to state 11
    for                            shift and go to state 15
    dowhile                        shift and go to state 16
    while                          shift and go to state 17

state 181

    (18) elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode . RBRACE
    (19) elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode . RBRACE elsif2

    RBRACE          shift and go to state 182


state 182

    (18) elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .
    (19) elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE . elsif2
    (20) elsif2 -> . elsif
    (21) elsif2 -> . ELSE LBRACE blockcode RBRACE
    (18) elsif -> . ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (19) elsif -> . ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2

    IF              reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    RETURN          reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    BREAK           reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    CONTINUE        reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    ID_SC           reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    ID_LI           reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    INCREMENT       reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    DECREMENT       reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    ID              reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    FOR             reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    DO              reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    LPAREN          reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    SUB             reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    $end            reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    RBRACE          reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    ELSE            shift and go to state 185
    ELSIF           shift and go to state 164

    elsif2                         shift and go to state 183
    elsif                          shift and go to state 184

state 183

    (19) elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .

    IF              reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    RETURN          reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    BREAK           reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    CONTINUE        reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    ID_SC           reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    ID_LI           reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    INCREMENT       reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    DECREMENT       reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    ID              reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    FOR             reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    DO              reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    LPAREN          reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    SUB             reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    $end            reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    RBRACE          reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)


state 184

    (20) elsif2 -> elsif .

    IF              reduce using rule 20 (elsif2 -> elsif .)
    RETURN          reduce using rule 20 (elsif2 -> elsif .)
    BREAK           reduce using rule 20 (elsif2 -> elsif .)
    CONTINUE        reduce using rule 20 (elsif2 -> elsif .)
    ID_SC           reduce using rule 20 (elsif2 -> elsif .)
    ID_LI           reduce using rule 20 (elsif2 -> elsif .)
    INCREMENT       reduce using rule 20 (elsif2 -> elsif .)
    DECREMENT       reduce using rule 20 (elsif2 -> elsif .)
    ID              reduce using rule 20 (elsif2 -> elsif .)
    FOR             reduce using rule 20 (elsif2 -> elsif .)
    DO              reduce using rule 20 (elsif2 -> elsif .)
    LPAREN          reduce using rule 20 (elsif2 -> elsif .)
    SUB             reduce using rule 20 (elsif2 -> elsif .)
    $end            reduce using rule 20 (elsif2 -> elsif .)
    RBRACE          reduce using rule 20 (elsif2 -> elsif .)


state 185

    (21) elsif2 -> ELSE . LBRACE blockcode RBRACE

    LBRACE          shift and go to state 186


state 186

    (21) elsif2 -> ELSE LBRACE . blockcode RBRACE
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (15) if -> . command IF LPAREN exp_condition RPAREN
    (16) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if -> . IF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif
    (54) exp_assignment -> . ID_SC EQUALS arithmetic
    (55) exp_assignment -> . ID_LI EQUALS arithmetic
    (56) exp_assignment -> . ID_SC
    (57) exp_assignment -> . ID_LI
    (58) exp_assignment -> . INCREMENT ID_SC
    (59) exp_assignment -> . DECREMENT ID_SC
    (60) exp_assignment -> . ID_SC INCREMENT
    (61) exp_assignment -> . ID_SC DECREMENT
    (82) call -> . ID LPAREN RPAREN
    (83) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE

    RETURN          shift and go to state 12
    BREAK           shift and go to state 13
    CONTINUE        shift and go to state 14
    IF              shift and go to state 18
    ID_SC           shift and go to state 19
    ID_LI           shift and go to state 20
    INCREMENT       shift and go to state 21
    DECREMENT       shift and go to state 22
    ID              shift and go to state 6
    FOR             shift and go to state 23
    DO              shift and go to state 24
    LPAREN          shift and go to state 7

    blockcode                      shift and go to state 187
    command                        shift and go to state 4
    interations                    shift and go to state 8
    if                             shift and go to state 9
    exp_assignment                 shift and go to state 10
    call                           shift and go to state 11
    for                            shift and go to state 15
    dowhile                        shift and go to state 16
    while                          shift and go to state 17

state 187

    (21) elsif2 -> ELSE LBRACE blockcode . RBRACE

    RBRACE          shift and go to state 188


state 188

    (21) elsif2 -> ELSE LBRACE blockcode RBRACE .

    IF              reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    RETURN          reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    BREAK           reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    CONTINUE        reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    ID_SC           reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    ID_LI           reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    INCREMENT       reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    DECREMENT       reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    ID              reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    FOR             reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    DO              reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    LPAREN          reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    SUB             reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    $end            reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    RBRACE          reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IF in state 4 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 4 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 4 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 4 resolved as shift
WARNING: shift/reduce conflict for ID_SC in state 4 resolved as shift
WARNING: shift/reduce conflict for ID_LI in state 4 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 4 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 4 resolved as shift
WARNING: shift/reduce conflict for ID in state 4 resolved as shift
WARNING: shift/reduce conflict for FOR in state 4 resolved as shift
WARNING: shift/reduce conflict for DO in state 4 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 4 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 19 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 19 resolved as shift
WARNING: shift/reduce conflict for GT in state 33 resolved as shift
WARNING: shift/reduce conflict for LT in state 33 resolved as shift
WARNING: shift/reduce conflict for EQ in state 33 resolved as shift
WARNING: shift/reduce conflict for GE in state 33 resolved as shift
WARNING: shift/reduce conflict for LE in state 33 resolved as shift
WARNING: shift/reduce conflict for NE in state 33 resolved as shift
WARNING: shift/reduce conflict for CMP in state 33 resolved as shift
WARNING: shift/reduce conflict for SEQ in state 33 resolved as shift
WARNING: shift/reduce conflict for SNE in state 33 resolved as shift
WARNING: shift/reduce conflict for SLT in state 33 resolved as shift
WARNING: shift/reduce conflict for SGT in state 33 resolved as shift
WARNING: shift/reduce conflict for SLE in state 33 resolved as shift
WARNING: shift/reduce conflict for SGE in state 33 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 45 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 45 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 45 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 45 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 46 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 46 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 46 resolved as shift
WARNING: shift/reduce conflict for XOR in state 48 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 92 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 121 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 121 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 122 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 122 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 122 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 122 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 122 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 122 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 123 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 123 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 123 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 123 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 123 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 123 resolved as shift
WARNING: reduce/reduce conflict in state 41 resolved using rule (exp_condition -> attcond)
WARNING: rejected rule (return -> attcond) in state 41
WARNING: reduce/reduce conflict in state 43 resolved using rule (exp3 -> exp_assignment)
WARNING: rejected rule (attcond -> exp_assignment) in state 43
WARNING: reduce/reduce conflict in state 44 resolved using rule (exp3 -> NUMBER)
WARNING: rejected rule (attcond -> NUMBER) in state 44
WARNING: reduce/reduce conflict in state 45 resolved using rule (arithmetic -> exp)
WARNING: rejected rule (exp3 -> exp) in state 45
WARNING: reduce/reduce conflict in state 95 resolved using rule (exp3 -> NUMBER)
WARNING: rejected rule (attcond -> NUMBER) in state 95
WARNING: reduce/reduce conflict in state 96 resolved using rule (exp3 -> exp_assignment)
WARNING: rejected rule (attcond -> exp_assignment) in state 96
WARNING: reduce/reduce conflict in state 122 resolved using rule (exp -> exp PLUS exp1)
WARNING: rejected rule (exp -> exp1) in state 122
WARNING: reduce/reduce conflict in state 123 resolved using rule (exp -> exp MINUS exp1)
WARNING: rejected rule (exp -> exp1) in state 123
WARNING: reduce/reduce conflict in state 124 resolved using rule (exp1 -> exp1 TIMES exp2)
WARNING: rejected rule (exp1 -> exp2) in state 124
WARNING: reduce/reduce conflict in state 125 resolved using rule (exp1 -> exp1 DIVIDE exp2)
WARNING: rejected rule (exp1 -> exp2) in state 125
WARNING: reduce/reduce conflict in state 126 resolved using rule (exp1 -> exp1 MODULO exp2)
WARNING: rejected rule (exp1 -> exp2) in state 126
WARNING: reduce/reduce conflict in state 127 resolved using rule (exp1 -> exp2)
WARNING: rejected rule (exp2 -> exp3 XOR exp2) in state 127
WARNING: Rule (return -> attcond) is never reduced
WARNING: Rule (exp2 -> exp3 XOR exp2) is never reduced
