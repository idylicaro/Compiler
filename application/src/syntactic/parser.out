Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    ANDEQUAL
    COLON
    DIVEQUAL
    EXP
    LBRACKET
    LSHIFT
    LSHIFTEQUAL
    MINUSEQUAL
    MODEQUAL
    NO
    OR
    OREQUAL
    PERIOD
    PLUSEQUAL
    Q
    QQ
    QR
    QW
    QX
    RBRACKET
    RSHIFT
    RSHIFTEQUAL
    S
    TERNARY
    TIMESEQUAL
    TR
    UNLESS
    UNTIL
    XOREQUAL

Grammar

Rule 0     S' -> init
Rule 1     init -> blockcode init
Rule 2     init -> function init
Rule 3     init -> blockcode
Rule 4     init -> function
Rule 5     blockcode -> command
Rule 6     blockcode -> command blockcode
Rule 7     command -> interations
Rule 8     command -> if
Rule 9     command -> exp_assignment
Rule 10    command -> call
Rule 11    command -> RETURN return SEMICOLON
Rule 12    command -> BREAK SEMICOLON
Rule 13    command -> CONTINUE SEMICOLON
Rule 14    if -> IF LPAREN exp_condition RPAREN if_statement
Rule 15    if_statement -> LBRACE blockcode RBRACE
Rule 16    if_statement -> LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
Rule 17    if_statement -> LBRACE blockcode RBRACE elsif
Rule 18    elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
Rule 19    elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2
Rule 20    elsif2 -> elsif
Rule 21    elsif2 -> ELSE LBRACE blockcode RBRACE
Rule 22    interations -> for
Rule 23    interations -> dowhile
Rule 24    interations -> while
Rule 25    for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
Rule 26    for_assignments -> exp_assignment
Rule 27    for_assignments -> exp_assignment COMMA for_assignments
Rule 28    dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
Rule 29    while -> WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
Rule 30    while -> WHILE LPAREN exp_condition RPAREN LBRACE RBRACE
Rule 31    function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE
Rule 32    function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE
Rule 33    function_assignments -> exp_assignment
Rule 34    function_assignments -> exp_assignment COMMA function_assignments
Rule 35    exp_condition -> attcond GT attcond
Rule 36    exp_condition -> attcond LT attcond
Rule 37    exp_condition -> attcond EQ attcond
Rule 38    exp_condition -> attcond GE attcond
Rule 39    exp_condition -> attcond LE attcond
Rule 40    exp_condition -> attcond NE attcond
Rule 41    exp_condition -> attcond
Rule 42    exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic
Rule 43    exp_condition -> attcond CMP attcond
Rule 44    exp_condition -> attcond SEQ attcond
Rule 45    exp_condition -> attcond SNE attcond
Rule 46    exp_condition -> attcond SLT attcond
Rule 47    exp_condition -> attcond SGT attcond
Rule 48    exp_condition -> attcond SLE attcond
Rule 49    exp_condition -> attcond SGE attcond
Rule 50    exp_condition_logic -> LPAREN exp_condition RPAREN
Rule 51    exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN
Rule 52    logic -> LAND
Rule 53    logic -> LOR
Rule 54    logic -> LNOT
Rule 55    exp_assignment -> ID_SC EQUALS arithmetic
Rule 56    exp_assignment -> ID_LI EQUALS arithmetic
Rule 57    exp_assignment -> ID_SC
Rule 58    exp_assignment -> ID_LI
Rule 59    exp_assignment -> INCREMENT ID_SC
Rule 60    exp_assignment -> DECREMENT ID_SC
Rule 61    exp_assignment -> ID_SC INCREMENT
Rule 62    exp_assignment -> ID_SC DECREMENT
Rule 63    arithmetic -> exp
Rule 64    exp -> exp PLUS exp1
Rule 65    exp -> exp MINUS exp1
Rule 66    exp -> exp1
Rule 67    exp1 -> exp1 TIMES exp2
Rule 68    exp1 -> exp1 DIVIDE exp2
Rule 69    exp1 -> exp1 MODULO exp2
Rule 70    exp1 -> exp2
Rule 71    exp2 -> exp3 XOR exp2
Rule 72    exp2 -> exp3
Rule 73    exp3 -> LPAREN arithmetic RPAREN
Rule 74    exp3 -> NUMBER
Rule 75    exp3 -> exp_assignment
Rule 76    exp3 -> exp_condition
Rule 77    exp3 -> call
Rule 78    exp3 -> exp
Rule 79    exp3 -> TRUE
Rule 80    exp3 -> FALSE
Rule 81    attcond -> exp_assignment
Rule 82    attcond -> NUMBER
Rule 83    attcond -> TRUE
Rule 84    attcond -> FALSE
Rule 85    call -> ID LPAREN RPAREN
Rule 86    call -> ID LPAREN function_assignments RPAREN
Rule 87    return -> attcond
Rule 88    return -> arithmetic

Terminals, with rules where they appear

AND                  : 
ANDEQUAL             : 
BREAK                : 12
CMP                  : 43
COLON                : 
COMMA                : 27 34
CONTINUE             : 13
DECREMENT            : 60 62
DIVEQUAL             : 
DIVIDE               : 68
DO                   : 28
ELSE                 : 16 21
ELSIF                : 18 19
EQ                   : 37
EQUALS               : 55 56
EXP                  : 
FALSE                : 80 84
FOR                  : 25
GE                   : 38
GT                   : 35
ID                   : 31 32 85 86
ID_LI                : 56 58
ID_SC                : 55 57 59 60 61 62
IF                   : 14
INCREMENT            : 59 61
LAND                 : 52
LBRACE               : 15 16 16 17 18 19 21 25 28 29 30 31 32
LBRACKET             : 
LE                   : 39
LNOT                 : 54
LOR                  : 53
LPAREN               : 14 18 19 25 28 29 30 31 32 42 50 51 51 73 85 86
LSHIFT               : 
LSHIFTEQUAL          : 
LT                   : 36
MINUS                : 65
MINUSEQUAL           : 
MODEQUAL             : 
MODULO               : 69
NE                   : 40
NO                   : 
NUMBER               : 74 82
OR                   : 
OREQUAL              : 
PERIOD               : 
PLUS                 : 64
PLUSEQUAL            : 
Q                    : 
QQ                   : 
QR                   : 
QW                   : 
QX                   : 
RBRACE               : 15 16 16 17 18 19 21 25 28 29 30 31 32
RBRACKET             : 
RETURN               : 11
RPAREN               : 14 18 19 25 28 29 30 31 32 42 50 51 51 73 85 86
RSHIFT               : 
RSHIFTEQUAL          : 
S                    : 
SEMICOLON            : 11 12 13 25 25
SEQ                  : 44
SGE                  : 49
SGT                  : 47
SLE                  : 48
SLT                  : 46
SNE                  : 45
SUB                  : 31 32
TERNARY              : 
TIMES                : 67
TIMESEQUAL           : 
TR                   : 
TRUE                 : 79 83
UNLESS               : 
UNTIL                : 
WHILE                : 28 29 30
XOR                  : 71
XOREQUAL             : 
error                : 

Nonterminals, with rules where they appear

arithmetic           : 55 56 73 88
attcond              : 35 35 36 36 37 37 38 38 39 39 40 40 41 43 43 44 44 45 45 46 46 47 47 48 48 49 49 87
blockcode            : 1 3 6 15 16 16 17 18 19 21 25 28 29 31 32
call                 : 10 77
command              : 5 6
dowhile              : 23
elsif                : 17 20
elsif2               : 19
exp                  : 63 64 65 78
exp1                 : 64 65 66 67 68 69
exp2                 : 67 68 69 70 71
exp3                 : 71 72
exp_assignment       : 9 26 27 33 34 75 81
exp_condition        : 14 18 19 25 28 29 30 42 50 51 51 76
exp_condition_logic  : 42
for                  : 22
for_assignments      : 25 25 27
function             : 2 4
function_assignments : 32 34 86
if                   : 8
if_statement         : 14
init                 : 1 2 0
interations          : 7
logic                : 42 51
return               : 11
while                : 24

Parsing method: LALR

state 0

    (0) S' -> . init
    (1) init -> . blockcode init
    (2) init -> . function init
    (3) init -> . blockcode
    (4) init -> . function
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (31) function -> . SUB ID LPAREN RPAREN LBRACE blockcode RBRACE
    (32) function -> . SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN if_statement
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (30) while -> . WHILE LPAREN exp_condition RPAREN LBRACE RBRACE

    SUB             shift and go to state 5
    RETURN          shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    IF              shift and go to state 17
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    ID              shift and go to state 6
    FOR             shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24

    init                           shift and go to state 1
    blockcode                      shift and go to state 2
    function                       shift and go to state 3
    command                        shift and go to state 4
    interations                    shift and go to state 7
    if                             shift and go to state 8
    exp_assignment                 shift and go to state 9
    call                           shift and go to state 10
    for                            shift and go to state 14
    dowhile                        shift and go to state 15
    while                          shift and go to state 16

state 1

    (0) S' -> init .



state 2

    (1) init -> blockcode . init
    (3) init -> blockcode .
    (1) init -> . blockcode init
    (2) init -> . function init
    (3) init -> . blockcode
    (4) init -> . function
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (31) function -> . SUB ID LPAREN RPAREN LBRACE blockcode RBRACE
    (32) function -> . SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN if_statement
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (30) while -> . WHILE LPAREN exp_condition RPAREN LBRACE RBRACE

    $end            reduce using rule 3 (init -> blockcode .)
    SUB             shift and go to state 5
    RETURN          shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    IF              shift and go to state 17
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    ID              shift and go to state 6
    FOR             shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24

    blockcode                      shift and go to state 2
    init                           shift and go to state 25
    function                       shift and go to state 3
    command                        shift and go to state 4
    interations                    shift and go to state 7
    if                             shift and go to state 8
    exp_assignment                 shift and go to state 9
    call                           shift and go to state 10
    for                            shift and go to state 14
    dowhile                        shift and go to state 15
    while                          shift and go to state 16

state 3

    (2) init -> function . init
    (4) init -> function .
    (1) init -> . blockcode init
    (2) init -> . function init
    (3) init -> . blockcode
    (4) init -> . function
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (31) function -> . SUB ID LPAREN RPAREN LBRACE blockcode RBRACE
    (32) function -> . SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN if_statement
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (30) while -> . WHILE LPAREN exp_condition RPAREN LBRACE RBRACE

    $end            reduce using rule 4 (init -> function .)
    SUB             shift and go to state 5
    RETURN          shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    IF              shift and go to state 17
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    ID              shift and go to state 6
    FOR             shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24

    function                       shift and go to state 3
    init                           shift and go to state 26
    blockcode                      shift and go to state 2
    command                        shift and go to state 4
    interations                    shift and go to state 7
    if                             shift and go to state 8
    exp_assignment                 shift and go to state 9
    call                           shift and go to state 10
    for                            shift and go to state 14
    dowhile                        shift and go to state 15
    while                          shift and go to state 16

state 4

    (5) blockcode -> command .
    (6) blockcode -> command . blockcode
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN if_statement
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (30) while -> . WHILE LPAREN exp_condition RPAREN LBRACE RBRACE

  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for ID_SC resolved as shift
  ! shift/reduce conflict for ID_LI resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DO resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
    SUB             reduce using rule 5 (blockcode -> command .)
    $end            reduce using rule 5 (blockcode -> command .)
    RBRACE          reduce using rule 5 (blockcode -> command .)
    RETURN          shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    IF              shift and go to state 17
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    ID              shift and go to state 6
    FOR             shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24

  ! RETURN          [ reduce using rule 5 (blockcode -> command .) ]
  ! BREAK           [ reduce using rule 5 (blockcode -> command .) ]
  ! CONTINUE        [ reduce using rule 5 (blockcode -> command .) ]
  ! IF              [ reduce using rule 5 (blockcode -> command .) ]
  ! ID_SC           [ reduce using rule 5 (blockcode -> command .) ]
  ! ID_LI           [ reduce using rule 5 (blockcode -> command .) ]
  ! INCREMENT       [ reduce using rule 5 (blockcode -> command .) ]
  ! DECREMENT       [ reduce using rule 5 (blockcode -> command .) ]
  ! ID              [ reduce using rule 5 (blockcode -> command .) ]
  ! FOR             [ reduce using rule 5 (blockcode -> command .) ]
  ! DO              [ reduce using rule 5 (blockcode -> command .) ]
  ! WHILE           [ reduce using rule 5 (blockcode -> command .) ]

    command                        shift and go to state 4
    blockcode                      shift and go to state 27
    interations                    shift and go to state 7
    if                             shift and go to state 8
    exp_assignment                 shift and go to state 9
    call                           shift and go to state 10
    for                            shift and go to state 14
    dowhile                        shift and go to state 15
    while                          shift and go to state 16

state 5

    (31) function -> SUB . ID LPAREN RPAREN LBRACE blockcode RBRACE
    (32) function -> SUB . ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE

    ID              shift and go to state 28


state 6

    (85) call -> ID . LPAREN RPAREN
    (86) call -> ID . LPAREN function_assignments RPAREN

    LPAREN          shift and go to state 29


state 7

    (7) command -> interations .

    RETURN          reduce using rule 7 (command -> interations .)
    BREAK           reduce using rule 7 (command -> interations .)
    CONTINUE        reduce using rule 7 (command -> interations .)
    IF              reduce using rule 7 (command -> interations .)
    ID_SC           reduce using rule 7 (command -> interations .)
    ID_LI           reduce using rule 7 (command -> interations .)
    INCREMENT       reduce using rule 7 (command -> interations .)
    DECREMENT       reduce using rule 7 (command -> interations .)
    ID              reduce using rule 7 (command -> interations .)
    FOR             reduce using rule 7 (command -> interations .)
    DO              reduce using rule 7 (command -> interations .)
    WHILE           reduce using rule 7 (command -> interations .)
    SUB             reduce using rule 7 (command -> interations .)
    $end            reduce using rule 7 (command -> interations .)
    RBRACE          reduce using rule 7 (command -> interations .)


state 8

    (8) command -> if .

    RETURN          reduce using rule 8 (command -> if .)
    BREAK           reduce using rule 8 (command -> if .)
    CONTINUE        reduce using rule 8 (command -> if .)
    IF              reduce using rule 8 (command -> if .)
    ID_SC           reduce using rule 8 (command -> if .)
    ID_LI           reduce using rule 8 (command -> if .)
    INCREMENT       reduce using rule 8 (command -> if .)
    DECREMENT       reduce using rule 8 (command -> if .)
    ID              reduce using rule 8 (command -> if .)
    FOR             reduce using rule 8 (command -> if .)
    DO              reduce using rule 8 (command -> if .)
    WHILE           reduce using rule 8 (command -> if .)
    SUB             reduce using rule 8 (command -> if .)
    $end            reduce using rule 8 (command -> if .)
    RBRACE          reduce using rule 8 (command -> if .)


state 9

    (9) command -> exp_assignment .

    RETURN          reduce using rule 9 (command -> exp_assignment .)
    BREAK           reduce using rule 9 (command -> exp_assignment .)
    CONTINUE        reduce using rule 9 (command -> exp_assignment .)
    IF              reduce using rule 9 (command -> exp_assignment .)
    ID_SC           reduce using rule 9 (command -> exp_assignment .)
    ID_LI           reduce using rule 9 (command -> exp_assignment .)
    INCREMENT       reduce using rule 9 (command -> exp_assignment .)
    DECREMENT       reduce using rule 9 (command -> exp_assignment .)
    ID              reduce using rule 9 (command -> exp_assignment .)
    FOR             reduce using rule 9 (command -> exp_assignment .)
    DO              reduce using rule 9 (command -> exp_assignment .)
    WHILE           reduce using rule 9 (command -> exp_assignment .)
    SUB             reduce using rule 9 (command -> exp_assignment .)
    $end            reduce using rule 9 (command -> exp_assignment .)
    RBRACE          reduce using rule 9 (command -> exp_assignment .)


state 10

    (10) command -> call .

    RETURN          reduce using rule 10 (command -> call .)
    BREAK           reduce using rule 10 (command -> call .)
    CONTINUE        reduce using rule 10 (command -> call .)
    IF              reduce using rule 10 (command -> call .)
    ID_SC           reduce using rule 10 (command -> call .)
    ID_LI           reduce using rule 10 (command -> call .)
    INCREMENT       reduce using rule 10 (command -> call .)
    DECREMENT       reduce using rule 10 (command -> call .)
    ID              reduce using rule 10 (command -> call .)
    FOR             reduce using rule 10 (command -> call .)
    DO              reduce using rule 10 (command -> call .)
    WHILE           reduce using rule 10 (command -> call .)
    SUB             reduce using rule 10 (command -> call .)
    $end            reduce using rule 10 (command -> call .)
    RBRACE          reduce using rule 10 (command -> call .)


state 11

    (11) command -> RETURN . return SEMICOLON
    (87) return -> . attcond
    (88) return -> . arithmetic
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (63) arithmetic -> . exp
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (64) exp -> . exp PLUS exp1
    (65) exp -> . exp MINUS exp1
    (66) exp -> . exp1
    (67) exp1 -> . exp1 TIMES exp2
    (68) exp1 -> . exp1 DIVIDE exp2
    (69) exp1 -> . exp1 MODULO exp2
    (70) exp1 -> . exp2
    (71) exp2 -> . exp3 XOR exp2
    (72) exp2 -> . exp3
    (73) exp3 -> . LPAREN arithmetic RPAREN
    (74) exp3 -> . NUMBER
    (75) exp3 -> . exp_assignment
    (76) exp3 -> . exp_condition
    (77) exp3 -> . call
    (78) exp3 -> . exp
    (79) exp3 -> . TRUE
    (80) exp3 -> . FALSE
    (35) exp_condition -> . attcond GT attcond
    (36) exp_condition -> . attcond LT attcond
    (37) exp_condition -> . attcond EQ attcond
    (38) exp_condition -> . attcond GE attcond
    (39) exp_condition -> . attcond LE attcond
    (40) exp_condition -> . attcond NE attcond
    (41) exp_condition -> . attcond
    (42) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (43) exp_condition -> . attcond CMP attcond
    (44) exp_condition -> . attcond SEQ attcond
    (45) exp_condition -> . attcond SNE attcond
    (46) exp_condition -> . attcond SLT attcond
    (47) exp_condition -> . attcond SGT attcond
    (48) exp_condition -> . attcond SLE attcond
    (49) exp_condition -> . attcond SGE attcond
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN

    NUMBER          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    LPAREN          shift and go to state 41
    ID              shift and go to state 6

    return                         shift and go to state 30
    attcond                        shift and go to state 31
    arithmetic                     shift and go to state 32
    exp_assignment                 shift and go to state 33
    exp                            shift and go to state 37
    exp1                           shift and go to state 38
    exp2                           shift and go to state 39
    exp3                           shift and go to state 40
    exp_condition                  shift and go to state 42
    call                           shift and go to state 43

state 12

    (12) command -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 44


state 13

    (13) command -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 45


state 14

    (22) interations -> for .

    RETURN          reduce using rule 22 (interations -> for .)
    BREAK           reduce using rule 22 (interations -> for .)
    CONTINUE        reduce using rule 22 (interations -> for .)
    IF              reduce using rule 22 (interations -> for .)
    ID_SC           reduce using rule 22 (interations -> for .)
    ID_LI           reduce using rule 22 (interations -> for .)
    INCREMENT       reduce using rule 22 (interations -> for .)
    DECREMENT       reduce using rule 22 (interations -> for .)
    ID              reduce using rule 22 (interations -> for .)
    FOR             reduce using rule 22 (interations -> for .)
    DO              reduce using rule 22 (interations -> for .)
    WHILE           reduce using rule 22 (interations -> for .)
    SUB             reduce using rule 22 (interations -> for .)
    $end            reduce using rule 22 (interations -> for .)
    RBRACE          reduce using rule 22 (interations -> for .)


state 15

    (23) interations -> dowhile .

    RETURN          reduce using rule 23 (interations -> dowhile .)
    BREAK           reduce using rule 23 (interations -> dowhile .)
    CONTINUE        reduce using rule 23 (interations -> dowhile .)
    IF              reduce using rule 23 (interations -> dowhile .)
    ID_SC           reduce using rule 23 (interations -> dowhile .)
    ID_LI           reduce using rule 23 (interations -> dowhile .)
    INCREMENT       reduce using rule 23 (interations -> dowhile .)
    DECREMENT       reduce using rule 23 (interations -> dowhile .)
    ID              reduce using rule 23 (interations -> dowhile .)
    FOR             reduce using rule 23 (interations -> dowhile .)
    DO              reduce using rule 23 (interations -> dowhile .)
    WHILE           reduce using rule 23 (interations -> dowhile .)
    SUB             reduce using rule 23 (interations -> dowhile .)
    $end            reduce using rule 23 (interations -> dowhile .)
    RBRACE          reduce using rule 23 (interations -> dowhile .)


state 16

    (24) interations -> while .

    RETURN          reduce using rule 24 (interations -> while .)
    BREAK           reduce using rule 24 (interations -> while .)
    CONTINUE        reduce using rule 24 (interations -> while .)
    IF              reduce using rule 24 (interations -> while .)
    ID_SC           reduce using rule 24 (interations -> while .)
    ID_LI           reduce using rule 24 (interations -> while .)
    INCREMENT       reduce using rule 24 (interations -> while .)
    DECREMENT       reduce using rule 24 (interations -> while .)
    ID              reduce using rule 24 (interations -> while .)
    FOR             reduce using rule 24 (interations -> while .)
    DO              reduce using rule 24 (interations -> while .)
    WHILE           reduce using rule 24 (interations -> while .)
    SUB             reduce using rule 24 (interations -> while .)
    $end            reduce using rule 24 (interations -> while .)
    RBRACE          reduce using rule 24 (interations -> while .)


state 17

    (14) if -> IF . LPAREN exp_condition RPAREN if_statement

    LPAREN          shift and go to state 46


state 18

    (55) exp_assignment -> ID_SC . EQUALS arithmetic
    (57) exp_assignment -> ID_SC .
    (61) exp_assignment -> ID_SC . INCREMENT
    (62) exp_assignment -> ID_SC . DECREMENT

  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
    EQUALS          shift and go to state 47
    RETURN          reduce using rule 57 (exp_assignment -> ID_SC .)
    BREAK           reduce using rule 57 (exp_assignment -> ID_SC .)
    CONTINUE        reduce using rule 57 (exp_assignment -> ID_SC .)
    IF              reduce using rule 57 (exp_assignment -> ID_SC .)
    ID_SC           reduce using rule 57 (exp_assignment -> ID_SC .)
    ID_LI           reduce using rule 57 (exp_assignment -> ID_SC .)
    ID              reduce using rule 57 (exp_assignment -> ID_SC .)
    FOR             reduce using rule 57 (exp_assignment -> ID_SC .)
    DO              reduce using rule 57 (exp_assignment -> ID_SC .)
    WHILE           reduce using rule 57 (exp_assignment -> ID_SC .)
    SUB             reduce using rule 57 (exp_assignment -> ID_SC .)
    $end            reduce using rule 57 (exp_assignment -> ID_SC .)
    RBRACE          reduce using rule 57 (exp_assignment -> ID_SC .)
    GT              reduce using rule 57 (exp_assignment -> ID_SC .)
    LT              reduce using rule 57 (exp_assignment -> ID_SC .)
    EQ              reduce using rule 57 (exp_assignment -> ID_SC .)
    GE              reduce using rule 57 (exp_assignment -> ID_SC .)
    LE              reduce using rule 57 (exp_assignment -> ID_SC .)
    NE              reduce using rule 57 (exp_assignment -> ID_SC .)
    CMP             reduce using rule 57 (exp_assignment -> ID_SC .)
    SEQ             reduce using rule 57 (exp_assignment -> ID_SC .)
    SNE             reduce using rule 57 (exp_assignment -> ID_SC .)
    SLT             reduce using rule 57 (exp_assignment -> ID_SC .)
    SGT             reduce using rule 57 (exp_assignment -> ID_SC .)
    SLE             reduce using rule 57 (exp_assignment -> ID_SC .)
    SGE             reduce using rule 57 (exp_assignment -> ID_SC .)
    SEMICOLON       reduce using rule 57 (exp_assignment -> ID_SC .)
    XOR             reduce using rule 57 (exp_assignment -> ID_SC .)
    TIMES           reduce using rule 57 (exp_assignment -> ID_SC .)
    DIVIDE          reduce using rule 57 (exp_assignment -> ID_SC .)
    MODULO          reduce using rule 57 (exp_assignment -> ID_SC .)
    PLUS            reduce using rule 57 (exp_assignment -> ID_SC .)
    MINUS           reduce using rule 57 (exp_assignment -> ID_SC .)
    COMMA           reduce using rule 57 (exp_assignment -> ID_SC .)
    RPAREN          reduce using rule 57 (exp_assignment -> ID_SC .)
    INCREMENT       shift and go to state 48
    DECREMENT       shift and go to state 49

  ! INCREMENT       [ reduce using rule 57 (exp_assignment -> ID_SC .) ]
  ! DECREMENT       [ reduce using rule 57 (exp_assignment -> ID_SC .) ]


state 19

    (56) exp_assignment -> ID_LI . EQUALS arithmetic
    (58) exp_assignment -> ID_LI .

    EQUALS          shift and go to state 50
    RETURN          reduce using rule 58 (exp_assignment -> ID_LI .)
    BREAK           reduce using rule 58 (exp_assignment -> ID_LI .)
    CONTINUE        reduce using rule 58 (exp_assignment -> ID_LI .)
    IF              reduce using rule 58 (exp_assignment -> ID_LI .)
    ID_SC           reduce using rule 58 (exp_assignment -> ID_LI .)
    ID_LI           reduce using rule 58 (exp_assignment -> ID_LI .)
    INCREMENT       reduce using rule 58 (exp_assignment -> ID_LI .)
    DECREMENT       reduce using rule 58 (exp_assignment -> ID_LI .)
    ID              reduce using rule 58 (exp_assignment -> ID_LI .)
    FOR             reduce using rule 58 (exp_assignment -> ID_LI .)
    DO              reduce using rule 58 (exp_assignment -> ID_LI .)
    WHILE           reduce using rule 58 (exp_assignment -> ID_LI .)
    SUB             reduce using rule 58 (exp_assignment -> ID_LI .)
    $end            reduce using rule 58 (exp_assignment -> ID_LI .)
    RBRACE          reduce using rule 58 (exp_assignment -> ID_LI .)
    GT              reduce using rule 58 (exp_assignment -> ID_LI .)
    LT              reduce using rule 58 (exp_assignment -> ID_LI .)
    EQ              reduce using rule 58 (exp_assignment -> ID_LI .)
    GE              reduce using rule 58 (exp_assignment -> ID_LI .)
    LE              reduce using rule 58 (exp_assignment -> ID_LI .)
    NE              reduce using rule 58 (exp_assignment -> ID_LI .)
    CMP             reduce using rule 58 (exp_assignment -> ID_LI .)
    SEQ             reduce using rule 58 (exp_assignment -> ID_LI .)
    SNE             reduce using rule 58 (exp_assignment -> ID_LI .)
    SLT             reduce using rule 58 (exp_assignment -> ID_LI .)
    SGT             reduce using rule 58 (exp_assignment -> ID_LI .)
    SLE             reduce using rule 58 (exp_assignment -> ID_LI .)
    SGE             reduce using rule 58 (exp_assignment -> ID_LI .)
    SEMICOLON       reduce using rule 58 (exp_assignment -> ID_LI .)
    XOR             reduce using rule 58 (exp_assignment -> ID_LI .)
    TIMES           reduce using rule 58 (exp_assignment -> ID_LI .)
    DIVIDE          reduce using rule 58 (exp_assignment -> ID_LI .)
    MODULO          reduce using rule 58 (exp_assignment -> ID_LI .)
    PLUS            reduce using rule 58 (exp_assignment -> ID_LI .)
    MINUS           reduce using rule 58 (exp_assignment -> ID_LI .)
    COMMA           reduce using rule 58 (exp_assignment -> ID_LI .)
    RPAREN          reduce using rule 58 (exp_assignment -> ID_LI .)


state 20

    (59) exp_assignment -> INCREMENT . ID_SC

    ID_SC           shift and go to state 51


state 21

    (60) exp_assignment -> DECREMENT . ID_SC

    ID_SC           shift and go to state 52


state 22

    (25) for -> FOR . LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE

    LPAREN          shift and go to state 53


state 23

    (28) dowhile -> DO . LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN

    LBRACE          shift and go to state 54


state 24

    (29) while -> WHILE . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (30) while -> WHILE . LPAREN exp_condition RPAREN LBRACE RBRACE

    LPAREN          shift and go to state 55


state 25

    (1) init -> blockcode init .

    $end            reduce using rule 1 (init -> blockcode init .)


state 26

    (2) init -> function init .

    $end            reduce using rule 2 (init -> function init .)


state 27

    (6) blockcode -> command blockcode .

    SUB             reduce using rule 6 (blockcode -> command blockcode .)
    RETURN          reduce using rule 6 (blockcode -> command blockcode .)
    BREAK           reduce using rule 6 (blockcode -> command blockcode .)
    CONTINUE        reduce using rule 6 (blockcode -> command blockcode .)
    IF              reduce using rule 6 (blockcode -> command blockcode .)
    ID_SC           reduce using rule 6 (blockcode -> command blockcode .)
    ID_LI           reduce using rule 6 (blockcode -> command blockcode .)
    INCREMENT       reduce using rule 6 (blockcode -> command blockcode .)
    DECREMENT       reduce using rule 6 (blockcode -> command blockcode .)
    ID              reduce using rule 6 (blockcode -> command blockcode .)
    FOR             reduce using rule 6 (blockcode -> command blockcode .)
    DO              reduce using rule 6 (blockcode -> command blockcode .)
    WHILE           reduce using rule 6 (blockcode -> command blockcode .)
    $end            reduce using rule 6 (blockcode -> command blockcode .)
    RBRACE          reduce using rule 6 (blockcode -> command blockcode .)


state 28

    (31) function -> SUB ID . LPAREN RPAREN LBRACE blockcode RBRACE
    (32) function -> SUB ID . LPAREN function_assignments RPAREN LBRACE blockcode RBRACE

    LPAREN          shift and go to state 56


state 29

    (85) call -> ID LPAREN . RPAREN
    (86) call -> ID LPAREN . function_assignments RPAREN
    (33) function_assignments -> . exp_assignment
    (34) function_assignments -> . exp_assignment COMMA function_assignments
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    RPAREN          shift and go to state 57
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    function_assignments           shift and go to state 58
    exp_assignment                 shift and go to state 59

state 30

    (11) command -> RETURN return . SEMICOLON

    SEMICOLON       shift and go to state 60


state 31

    (87) return -> attcond .
    (35) exp_condition -> attcond . GT attcond
    (36) exp_condition -> attcond . LT attcond
    (37) exp_condition -> attcond . EQ attcond
    (38) exp_condition -> attcond . GE attcond
    (39) exp_condition -> attcond . LE attcond
    (40) exp_condition -> attcond . NE attcond
    (41) exp_condition -> attcond .
    (43) exp_condition -> attcond . CMP attcond
    (44) exp_condition -> attcond . SEQ attcond
    (45) exp_condition -> attcond . SNE attcond
    (46) exp_condition -> attcond . SLT attcond
    (47) exp_condition -> attcond . SGT attcond
    (48) exp_condition -> attcond . SLE attcond
    (49) exp_condition -> attcond . SGE attcond

  ! reduce/reduce conflict for SEMICOLON resolved using rule 41 (exp_condition -> attcond .)
    GT              shift and go to state 61
    LT              shift and go to state 62
    EQ              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    NE              shift and go to state 66
    XOR             reduce using rule 41 (exp_condition -> attcond .)
    TIMES           reduce using rule 41 (exp_condition -> attcond .)
    DIVIDE          reduce using rule 41 (exp_condition -> attcond .)
    MODULO          reduce using rule 41 (exp_condition -> attcond .)
    PLUS            reduce using rule 41 (exp_condition -> attcond .)
    MINUS           reduce using rule 41 (exp_condition -> attcond .)
    SEMICOLON       reduce using rule 41 (exp_condition -> attcond .)
    CMP             shift and go to state 67
    SEQ             shift and go to state 68
    SNE             shift and go to state 69
    SLT             shift and go to state 70
    SGT             shift and go to state 71
    SLE             shift and go to state 72
    SGE             shift and go to state 73

  ! SEMICOLON       [ reduce using rule 87 (return -> attcond .) ]


state 32

    (88) return -> arithmetic .

    SEMICOLON       reduce using rule 88 (return -> arithmetic .)


state 33

    (81) attcond -> exp_assignment .
    (75) exp3 -> exp_assignment .

  ! reduce/reduce conflict for XOR resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for TIMES resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for MODULO resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for PLUS resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for MINUS resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for RPAREN resolved using rule 75 (exp3 -> exp_assignment .)
    GT              reduce using rule 81 (attcond -> exp_assignment .)
    LT              reduce using rule 81 (attcond -> exp_assignment .)
    EQ              reduce using rule 81 (attcond -> exp_assignment .)
    GE              reduce using rule 81 (attcond -> exp_assignment .)
    LE              reduce using rule 81 (attcond -> exp_assignment .)
    NE              reduce using rule 81 (attcond -> exp_assignment .)
    CMP             reduce using rule 81 (attcond -> exp_assignment .)
    SEQ             reduce using rule 81 (attcond -> exp_assignment .)
    SNE             reduce using rule 81 (attcond -> exp_assignment .)
    SLT             reduce using rule 81 (attcond -> exp_assignment .)
    SGT             reduce using rule 81 (attcond -> exp_assignment .)
    SLE             reduce using rule 81 (attcond -> exp_assignment .)
    SGE             reduce using rule 81 (attcond -> exp_assignment .)
    XOR             reduce using rule 75 (exp3 -> exp_assignment .)
    TIMES           reduce using rule 75 (exp3 -> exp_assignment .)
    DIVIDE          reduce using rule 75 (exp3 -> exp_assignment .)
    MODULO          reduce using rule 75 (exp3 -> exp_assignment .)
    PLUS            reduce using rule 75 (exp3 -> exp_assignment .)
    MINUS           reduce using rule 75 (exp3 -> exp_assignment .)
    SEMICOLON       reduce using rule 75 (exp3 -> exp_assignment .)
    RPAREN          reduce using rule 75 (exp3 -> exp_assignment .)

  ! SEMICOLON       [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! XOR             [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! TIMES           [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! DIVIDE          [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! MODULO          [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! PLUS            [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! MINUS           [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! RPAREN          [ reduce using rule 81 (attcond -> exp_assignment .) ]


state 34

    (82) attcond -> NUMBER .
    (74) exp3 -> NUMBER .

  ! reduce/reduce conflict for XOR resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for TIMES resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for MODULO resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for PLUS resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for MINUS resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 74 (exp3 -> NUMBER .)
    GT              reduce using rule 82 (attcond -> NUMBER .)
    LT              reduce using rule 82 (attcond -> NUMBER .)
    EQ              reduce using rule 82 (attcond -> NUMBER .)
    GE              reduce using rule 82 (attcond -> NUMBER .)
    LE              reduce using rule 82 (attcond -> NUMBER .)
    NE              reduce using rule 82 (attcond -> NUMBER .)
    CMP             reduce using rule 82 (attcond -> NUMBER .)
    SEQ             reduce using rule 82 (attcond -> NUMBER .)
    SNE             reduce using rule 82 (attcond -> NUMBER .)
    SLT             reduce using rule 82 (attcond -> NUMBER .)
    SGT             reduce using rule 82 (attcond -> NUMBER .)
    SLE             reduce using rule 82 (attcond -> NUMBER .)
    SGE             reduce using rule 82 (attcond -> NUMBER .)
    XOR             reduce using rule 74 (exp3 -> NUMBER .)
    TIMES           reduce using rule 74 (exp3 -> NUMBER .)
    DIVIDE          reduce using rule 74 (exp3 -> NUMBER .)
    MODULO          reduce using rule 74 (exp3 -> NUMBER .)
    PLUS            reduce using rule 74 (exp3 -> NUMBER .)
    MINUS           reduce using rule 74 (exp3 -> NUMBER .)
    SEMICOLON       reduce using rule 74 (exp3 -> NUMBER .)
    RPAREN          reduce using rule 74 (exp3 -> NUMBER .)

  ! SEMICOLON       [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! XOR             [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! TIMES           [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! DIVIDE          [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! MODULO          [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! PLUS            [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! MINUS           [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! RPAREN          [ reduce using rule 82 (attcond -> NUMBER .) ]


state 35

    (83) attcond -> TRUE .
    (79) exp3 -> TRUE .

  ! reduce/reduce conflict for XOR resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for TIMES resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for MODULO resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for PLUS resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for MINUS resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for RPAREN resolved using rule 79 (exp3 -> TRUE .)
    GT              reduce using rule 83 (attcond -> TRUE .)
    LT              reduce using rule 83 (attcond -> TRUE .)
    EQ              reduce using rule 83 (attcond -> TRUE .)
    GE              reduce using rule 83 (attcond -> TRUE .)
    LE              reduce using rule 83 (attcond -> TRUE .)
    NE              reduce using rule 83 (attcond -> TRUE .)
    CMP             reduce using rule 83 (attcond -> TRUE .)
    SEQ             reduce using rule 83 (attcond -> TRUE .)
    SNE             reduce using rule 83 (attcond -> TRUE .)
    SLT             reduce using rule 83 (attcond -> TRUE .)
    SGT             reduce using rule 83 (attcond -> TRUE .)
    SLE             reduce using rule 83 (attcond -> TRUE .)
    SGE             reduce using rule 83 (attcond -> TRUE .)
    XOR             reduce using rule 79 (exp3 -> TRUE .)
    TIMES           reduce using rule 79 (exp3 -> TRUE .)
    DIVIDE          reduce using rule 79 (exp3 -> TRUE .)
    MODULO          reduce using rule 79 (exp3 -> TRUE .)
    PLUS            reduce using rule 79 (exp3 -> TRUE .)
    MINUS           reduce using rule 79 (exp3 -> TRUE .)
    SEMICOLON       reduce using rule 79 (exp3 -> TRUE .)
    RPAREN          reduce using rule 79 (exp3 -> TRUE .)

  ! SEMICOLON       [ reduce using rule 83 (attcond -> TRUE .) ]
  ! XOR             [ reduce using rule 83 (attcond -> TRUE .) ]
  ! TIMES           [ reduce using rule 83 (attcond -> TRUE .) ]
  ! DIVIDE          [ reduce using rule 83 (attcond -> TRUE .) ]
  ! MODULO          [ reduce using rule 83 (attcond -> TRUE .) ]
  ! PLUS            [ reduce using rule 83 (attcond -> TRUE .) ]
  ! MINUS           [ reduce using rule 83 (attcond -> TRUE .) ]
  ! RPAREN          [ reduce using rule 83 (attcond -> TRUE .) ]


state 36

    (84) attcond -> FALSE .
    (80) exp3 -> FALSE .

  ! reduce/reduce conflict for XOR resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for TIMES resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for MODULO resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for PLUS resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for MINUS resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for RPAREN resolved using rule 80 (exp3 -> FALSE .)
    GT              reduce using rule 84 (attcond -> FALSE .)
    LT              reduce using rule 84 (attcond -> FALSE .)
    EQ              reduce using rule 84 (attcond -> FALSE .)
    GE              reduce using rule 84 (attcond -> FALSE .)
    LE              reduce using rule 84 (attcond -> FALSE .)
    NE              reduce using rule 84 (attcond -> FALSE .)
    CMP             reduce using rule 84 (attcond -> FALSE .)
    SEQ             reduce using rule 84 (attcond -> FALSE .)
    SNE             reduce using rule 84 (attcond -> FALSE .)
    SLT             reduce using rule 84 (attcond -> FALSE .)
    SGT             reduce using rule 84 (attcond -> FALSE .)
    SLE             reduce using rule 84 (attcond -> FALSE .)
    SGE             reduce using rule 84 (attcond -> FALSE .)
    XOR             reduce using rule 80 (exp3 -> FALSE .)
    TIMES           reduce using rule 80 (exp3 -> FALSE .)
    DIVIDE          reduce using rule 80 (exp3 -> FALSE .)
    MODULO          reduce using rule 80 (exp3 -> FALSE .)
    PLUS            reduce using rule 80 (exp3 -> FALSE .)
    MINUS           reduce using rule 80 (exp3 -> FALSE .)
    SEMICOLON       reduce using rule 80 (exp3 -> FALSE .)
    RPAREN          reduce using rule 80 (exp3 -> FALSE .)

  ! SEMICOLON       [ reduce using rule 84 (attcond -> FALSE .) ]
  ! XOR             [ reduce using rule 84 (attcond -> FALSE .) ]
  ! TIMES           [ reduce using rule 84 (attcond -> FALSE .) ]
  ! DIVIDE          [ reduce using rule 84 (attcond -> FALSE .) ]
  ! MODULO          [ reduce using rule 84 (attcond -> FALSE .) ]
  ! PLUS            [ reduce using rule 84 (attcond -> FALSE .) ]
  ! MINUS           [ reduce using rule 84 (attcond -> FALSE .) ]
  ! RPAREN          [ reduce using rule 84 (attcond -> FALSE .) ]


state 37

    (63) arithmetic -> exp .
    (64) exp -> exp . PLUS exp1
    (65) exp -> exp . MINUS exp1
    (78) exp3 -> exp .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for XOR resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for TIMES resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for MODULO resolved using rule 63 (arithmetic -> exp .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for RPAREN resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for RETURN resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for BREAK resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for IF resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for ID_SC resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for ID_LI resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for INCREMENT resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for DECREMENT resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for ID resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for FOR resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for DO resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for WHILE resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for SUB resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for $end resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for RBRACE resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for GT resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for LT resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for EQ resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for GE resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for LE resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for NE resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for CMP resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for SEQ resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for SNE resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for SLT resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for SGT resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for SLE resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for SGE resolved using rule 63 (arithmetic -> exp .)
  ! reduce/reduce conflict for COMMA resolved using rule 63 (arithmetic -> exp .)
    SEMICOLON       reduce using rule 63 (arithmetic -> exp .)
    RPAREN          reduce using rule 63 (arithmetic -> exp .)
    RETURN          reduce using rule 63 (arithmetic -> exp .)
    BREAK           reduce using rule 63 (arithmetic -> exp .)
    CONTINUE        reduce using rule 63 (arithmetic -> exp .)
    IF              reduce using rule 63 (arithmetic -> exp .)
    ID_SC           reduce using rule 63 (arithmetic -> exp .)
    ID_LI           reduce using rule 63 (arithmetic -> exp .)
    INCREMENT       reduce using rule 63 (arithmetic -> exp .)
    DECREMENT       reduce using rule 63 (arithmetic -> exp .)
    ID              reduce using rule 63 (arithmetic -> exp .)
    FOR             reduce using rule 63 (arithmetic -> exp .)
    DO              reduce using rule 63 (arithmetic -> exp .)
    WHILE           reduce using rule 63 (arithmetic -> exp .)
    SUB             reduce using rule 63 (arithmetic -> exp .)
    $end            reduce using rule 63 (arithmetic -> exp .)
    RBRACE          reduce using rule 63 (arithmetic -> exp .)
    GT              reduce using rule 63 (arithmetic -> exp .)
    LT              reduce using rule 63 (arithmetic -> exp .)
    EQ              reduce using rule 63 (arithmetic -> exp .)
    GE              reduce using rule 63 (arithmetic -> exp .)
    LE              reduce using rule 63 (arithmetic -> exp .)
    NE              reduce using rule 63 (arithmetic -> exp .)
    CMP             reduce using rule 63 (arithmetic -> exp .)
    SEQ             reduce using rule 63 (arithmetic -> exp .)
    SNE             reduce using rule 63 (arithmetic -> exp .)
    SLT             reduce using rule 63 (arithmetic -> exp .)
    SGT             reduce using rule 63 (arithmetic -> exp .)
    SLE             reduce using rule 63 (arithmetic -> exp .)
    SGE             reduce using rule 63 (arithmetic -> exp .)
    XOR             reduce using rule 63 (arithmetic -> exp .)
    TIMES           reduce using rule 63 (arithmetic -> exp .)
    DIVIDE          reduce using rule 63 (arithmetic -> exp .)
    MODULO          reduce using rule 63 (arithmetic -> exp .)
    COMMA           reduce using rule 63 (arithmetic -> exp .)
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75

  ! PLUS            [ reduce using rule 63 (arithmetic -> exp .) ]
  ! MINUS           [ reduce using rule 63 (arithmetic -> exp .) ]
  ! XOR             [ reduce using rule 78 (exp3 -> exp .) ]
  ! TIMES           [ reduce using rule 78 (exp3 -> exp .) ]
  ! DIVIDE          [ reduce using rule 78 (exp3 -> exp .) ]
  ! MODULO          [ reduce using rule 78 (exp3 -> exp .) ]
  ! PLUS            [ reduce using rule 78 (exp3 -> exp .) ]
  ! MINUS           [ reduce using rule 78 (exp3 -> exp .) ]
  ! SEMICOLON       [ reduce using rule 78 (exp3 -> exp .) ]
  ! RPAREN          [ reduce using rule 78 (exp3 -> exp .) ]
  ! RETURN          [ reduce using rule 78 (exp3 -> exp .) ]
  ! BREAK           [ reduce using rule 78 (exp3 -> exp .) ]
  ! CONTINUE        [ reduce using rule 78 (exp3 -> exp .) ]
  ! IF              [ reduce using rule 78 (exp3 -> exp .) ]
  ! ID_SC           [ reduce using rule 78 (exp3 -> exp .) ]
  ! ID_LI           [ reduce using rule 78 (exp3 -> exp .) ]
  ! INCREMENT       [ reduce using rule 78 (exp3 -> exp .) ]
  ! DECREMENT       [ reduce using rule 78 (exp3 -> exp .) ]
  ! ID              [ reduce using rule 78 (exp3 -> exp .) ]
  ! FOR             [ reduce using rule 78 (exp3 -> exp .) ]
  ! DO              [ reduce using rule 78 (exp3 -> exp .) ]
  ! WHILE           [ reduce using rule 78 (exp3 -> exp .) ]
  ! SUB             [ reduce using rule 78 (exp3 -> exp .) ]
  ! $end            [ reduce using rule 78 (exp3 -> exp .) ]
  ! RBRACE          [ reduce using rule 78 (exp3 -> exp .) ]
  ! GT              [ reduce using rule 78 (exp3 -> exp .) ]
  ! LT              [ reduce using rule 78 (exp3 -> exp .) ]
  ! EQ              [ reduce using rule 78 (exp3 -> exp .) ]
  ! GE              [ reduce using rule 78 (exp3 -> exp .) ]
  ! LE              [ reduce using rule 78 (exp3 -> exp .) ]
  ! NE              [ reduce using rule 78 (exp3 -> exp .) ]
  ! CMP             [ reduce using rule 78 (exp3 -> exp .) ]
  ! SEQ             [ reduce using rule 78 (exp3 -> exp .) ]
  ! SNE             [ reduce using rule 78 (exp3 -> exp .) ]
  ! SLT             [ reduce using rule 78 (exp3 -> exp .) ]
  ! SGT             [ reduce using rule 78 (exp3 -> exp .) ]
  ! SLE             [ reduce using rule 78 (exp3 -> exp .) ]
  ! SGE             [ reduce using rule 78 (exp3 -> exp .) ]
  ! COMMA           [ reduce using rule 78 (exp3 -> exp .) ]


state 38

    (66) exp -> exp1 .
    (67) exp1 -> exp1 . TIMES exp2
    (68) exp1 -> exp1 . DIVIDE exp2
    (69) exp1 -> exp1 . MODULO exp2

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
    XOR             reduce using rule 66 (exp -> exp1 .)
    PLUS            reduce using rule 66 (exp -> exp1 .)
    MINUS           reduce using rule 66 (exp -> exp1 .)
    SEMICOLON       reduce using rule 66 (exp -> exp1 .)
    RPAREN          reduce using rule 66 (exp -> exp1 .)
    RETURN          reduce using rule 66 (exp -> exp1 .)
    BREAK           reduce using rule 66 (exp -> exp1 .)
    CONTINUE        reduce using rule 66 (exp -> exp1 .)
    IF              reduce using rule 66 (exp -> exp1 .)
    ID_SC           reduce using rule 66 (exp -> exp1 .)
    ID_LI           reduce using rule 66 (exp -> exp1 .)
    INCREMENT       reduce using rule 66 (exp -> exp1 .)
    DECREMENT       reduce using rule 66 (exp -> exp1 .)
    ID              reduce using rule 66 (exp -> exp1 .)
    FOR             reduce using rule 66 (exp -> exp1 .)
    DO              reduce using rule 66 (exp -> exp1 .)
    WHILE           reduce using rule 66 (exp -> exp1 .)
    SUB             reduce using rule 66 (exp -> exp1 .)
    $end            reduce using rule 66 (exp -> exp1 .)
    RBRACE          reduce using rule 66 (exp -> exp1 .)
    GT              reduce using rule 66 (exp -> exp1 .)
    LT              reduce using rule 66 (exp -> exp1 .)
    EQ              reduce using rule 66 (exp -> exp1 .)
    GE              reduce using rule 66 (exp -> exp1 .)
    LE              reduce using rule 66 (exp -> exp1 .)
    NE              reduce using rule 66 (exp -> exp1 .)
    CMP             reduce using rule 66 (exp -> exp1 .)
    SEQ             reduce using rule 66 (exp -> exp1 .)
    SNE             reduce using rule 66 (exp -> exp1 .)
    SLT             reduce using rule 66 (exp -> exp1 .)
    SGT             reduce using rule 66 (exp -> exp1 .)
    SLE             reduce using rule 66 (exp -> exp1 .)
    SGE             reduce using rule 66 (exp -> exp1 .)
    COMMA           reduce using rule 66 (exp -> exp1 .)
    TIMES           shift and go to state 76
    DIVIDE          shift and go to state 77
    MODULO          shift and go to state 78

  ! TIMES           [ reduce using rule 66 (exp -> exp1 .) ]
  ! DIVIDE          [ reduce using rule 66 (exp -> exp1 .) ]
  ! MODULO          [ reduce using rule 66 (exp -> exp1 .) ]


state 39

    (70) exp1 -> exp2 .

    XOR             reduce using rule 70 (exp1 -> exp2 .)
    TIMES           reduce using rule 70 (exp1 -> exp2 .)
    DIVIDE          reduce using rule 70 (exp1 -> exp2 .)
    MODULO          reduce using rule 70 (exp1 -> exp2 .)
    PLUS            reduce using rule 70 (exp1 -> exp2 .)
    MINUS           reduce using rule 70 (exp1 -> exp2 .)
    SEMICOLON       reduce using rule 70 (exp1 -> exp2 .)
    RPAREN          reduce using rule 70 (exp1 -> exp2 .)
    RETURN          reduce using rule 70 (exp1 -> exp2 .)
    BREAK           reduce using rule 70 (exp1 -> exp2 .)
    CONTINUE        reduce using rule 70 (exp1 -> exp2 .)
    IF              reduce using rule 70 (exp1 -> exp2 .)
    ID_SC           reduce using rule 70 (exp1 -> exp2 .)
    ID_LI           reduce using rule 70 (exp1 -> exp2 .)
    INCREMENT       reduce using rule 70 (exp1 -> exp2 .)
    DECREMENT       reduce using rule 70 (exp1 -> exp2 .)
    ID              reduce using rule 70 (exp1 -> exp2 .)
    FOR             reduce using rule 70 (exp1 -> exp2 .)
    DO              reduce using rule 70 (exp1 -> exp2 .)
    WHILE           reduce using rule 70 (exp1 -> exp2 .)
    SUB             reduce using rule 70 (exp1 -> exp2 .)
    $end            reduce using rule 70 (exp1 -> exp2 .)
    RBRACE          reduce using rule 70 (exp1 -> exp2 .)
    GT              reduce using rule 70 (exp1 -> exp2 .)
    LT              reduce using rule 70 (exp1 -> exp2 .)
    EQ              reduce using rule 70 (exp1 -> exp2 .)
    GE              reduce using rule 70 (exp1 -> exp2 .)
    LE              reduce using rule 70 (exp1 -> exp2 .)
    NE              reduce using rule 70 (exp1 -> exp2 .)
    CMP             reduce using rule 70 (exp1 -> exp2 .)
    SEQ             reduce using rule 70 (exp1 -> exp2 .)
    SNE             reduce using rule 70 (exp1 -> exp2 .)
    SLT             reduce using rule 70 (exp1 -> exp2 .)
    SGT             reduce using rule 70 (exp1 -> exp2 .)
    SLE             reduce using rule 70 (exp1 -> exp2 .)
    SGE             reduce using rule 70 (exp1 -> exp2 .)
    COMMA           reduce using rule 70 (exp1 -> exp2 .)


state 40

    (71) exp2 -> exp3 . XOR exp2
    (72) exp2 -> exp3 .

  ! shift/reduce conflict for XOR resolved as shift
    XOR             shift and go to state 79
    TIMES           reduce using rule 72 (exp2 -> exp3 .)
    DIVIDE          reduce using rule 72 (exp2 -> exp3 .)
    MODULO          reduce using rule 72 (exp2 -> exp3 .)
    PLUS            reduce using rule 72 (exp2 -> exp3 .)
    MINUS           reduce using rule 72 (exp2 -> exp3 .)
    SEMICOLON       reduce using rule 72 (exp2 -> exp3 .)
    RPAREN          reduce using rule 72 (exp2 -> exp3 .)
    RETURN          reduce using rule 72 (exp2 -> exp3 .)
    BREAK           reduce using rule 72 (exp2 -> exp3 .)
    CONTINUE        reduce using rule 72 (exp2 -> exp3 .)
    IF              reduce using rule 72 (exp2 -> exp3 .)
    ID_SC           reduce using rule 72 (exp2 -> exp3 .)
    ID_LI           reduce using rule 72 (exp2 -> exp3 .)
    INCREMENT       reduce using rule 72 (exp2 -> exp3 .)
    DECREMENT       reduce using rule 72 (exp2 -> exp3 .)
    ID              reduce using rule 72 (exp2 -> exp3 .)
    FOR             reduce using rule 72 (exp2 -> exp3 .)
    DO              reduce using rule 72 (exp2 -> exp3 .)
    WHILE           reduce using rule 72 (exp2 -> exp3 .)
    SUB             reduce using rule 72 (exp2 -> exp3 .)
    $end            reduce using rule 72 (exp2 -> exp3 .)
    RBRACE          reduce using rule 72 (exp2 -> exp3 .)
    GT              reduce using rule 72 (exp2 -> exp3 .)
    LT              reduce using rule 72 (exp2 -> exp3 .)
    EQ              reduce using rule 72 (exp2 -> exp3 .)
    GE              reduce using rule 72 (exp2 -> exp3 .)
    LE              reduce using rule 72 (exp2 -> exp3 .)
    NE              reduce using rule 72 (exp2 -> exp3 .)
    CMP             reduce using rule 72 (exp2 -> exp3 .)
    SEQ             reduce using rule 72 (exp2 -> exp3 .)
    SNE             reduce using rule 72 (exp2 -> exp3 .)
    SLT             reduce using rule 72 (exp2 -> exp3 .)
    SGT             reduce using rule 72 (exp2 -> exp3 .)
    SLE             reduce using rule 72 (exp2 -> exp3 .)
    SGE             reduce using rule 72 (exp2 -> exp3 .)
    COMMA           reduce using rule 72 (exp2 -> exp3 .)

  ! XOR             [ reduce using rule 72 (exp2 -> exp3 .) ]


state 41

    (73) exp3 -> LPAREN . arithmetic RPAREN
    (42) exp_condition -> LPAREN . exp_condition RPAREN logic exp_condition_logic
    (63) arithmetic -> . exp
    (35) exp_condition -> . attcond GT attcond
    (36) exp_condition -> . attcond LT attcond
    (37) exp_condition -> . attcond EQ attcond
    (38) exp_condition -> . attcond GE attcond
    (39) exp_condition -> . attcond LE attcond
    (40) exp_condition -> . attcond NE attcond
    (41) exp_condition -> . attcond
    (42) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (43) exp_condition -> . attcond CMP attcond
    (44) exp_condition -> . attcond SEQ attcond
    (45) exp_condition -> . attcond SNE attcond
    (46) exp_condition -> . attcond SLT attcond
    (47) exp_condition -> . attcond SGT attcond
    (48) exp_condition -> . attcond SLE attcond
    (49) exp_condition -> . attcond SGE attcond
    (64) exp -> . exp PLUS exp1
    (65) exp -> . exp MINUS exp1
    (66) exp -> . exp1
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (67) exp1 -> . exp1 TIMES exp2
    (68) exp1 -> . exp1 DIVIDE exp2
    (69) exp1 -> . exp1 MODULO exp2
    (70) exp1 -> . exp2
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (71) exp2 -> . exp3 XOR exp2
    (72) exp2 -> . exp3
    (73) exp3 -> . LPAREN arithmetic RPAREN
    (74) exp3 -> . NUMBER
    (75) exp3 -> . exp_assignment
    (76) exp3 -> . exp_condition
    (77) exp3 -> . call
    (78) exp3 -> . exp
    (79) exp3 -> . TRUE
    (80) exp3 -> . FALSE
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN

    LPAREN          shift and go to state 80
    NUMBER          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    ID              shift and go to state 6

    arithmetic                     shift and go to state 81
    exp_condition                  shift and go to state 82
    exp                            shift and go to state 37
    attcond                        shift and go to state 83
    exp1                           shift and go to state 38
    exp_assignment                 shift and go to state 33
    exp2                           shift and go to state 39
    exp3                           shift and go to state 40
    call                           shift and go to state 43

state 42

    (76) exp3 -> exp_condition .

    XOR             reduce using rule 76 (exp3 -> exp_condition .)
    TIMES           reduce using rule 76 (exp3 -> exp_condition .)
    DIVIDE          reduce using rule 76 (exp3 -> exp_condition .)
    MODULO          reduce using rule 76 (exp3 -> exp_condition .)
    PLUS            reduce using rule 76 (exp3 -> exp_condition .)
    MINUS           reduce using rule 76 (exp3 -> exp_condition .)
    SEMICOLON       reduce using rule 76 (exp3 -> exp_condition .)
    RETURN          reduce using rule 76 (exp3 -> exp_condition .)
    BREAK           reduce using rule 76 (exp3 -> exp_condition .)
    CONTINUE        reduce using rule 76 (exp3 -> exp_condition .)
    IF              reduce using rule 76 (exp3 -> exp_condition .)
    ID_SC           reduce using rule 76 (exp3 -> exp_condition .)
    ID_LI           reduce using rule 76 (exp3 -> exp_condition .)
    INCREMENT       reduce using rule 76 (exp3 -> exp_condition .)
    DECREMENT       reduce using rule 76 (exp3 -> exp_condition .)
    ID              reduce using rule 76 (exp3 -> exp_condition .)
    FOR             reduce using rule 76 (exp3 -> exp_condition .)
    DO              reduce using rule 76 (exp3 -> exp_condition .)
    WHILE           reduce using rule 76 (exp3 -> exp_condition .)
    SUB             reduce using rule 76 (exp3 -> exp_condition .)
    $end            reduce using rule 76 (exp3 -> exp_condition .)
    RBRACE          reduce using rule 76 (exp3 -> exp_condition .)
    GT              reduce using rule 76 (exp3 -> exp_condition .)
    LT              reduce using rule 76 (exp3 -> exp_condition .)
    EQ              reduce using rule 76 (exp3 -> exp_condition .)
    GE              reduce using rule 76 (exp3 -> exp_condition .)
    LE              reduce using rule 76 (exp3 -> exp_condition .)
    NE              reduce using rule 76 (exp3 -> exp_condition .)
    CMP             reduce using rule 76 (exp3 -> exp_condition .)
    SEQ             reduce using rule 76 (exp3 -> exp_condition .)
    SNE             reduce using rule 76 (exp3 -> exp_condition .)
    SLT             reduce using rule 76 (exp3 -> exp_condition .)
    SGT             reduce using rule 76 (exp3 -> exp_condition .)
    SLE             reduce using rule 76 (exp3 -> exp_condition .)
    SGE             reduce using rule 76 (exp3 -> exp_condition .)
    COMMA           reduce using rule 76 (exp3 -> exp_condition .)
    RPAREN          reduce using rule 76 (exp3 -> exp_condition .)


state 43

    (77) exp3 -> call .

    XOR             reduce using rule 77 (exp3 -> call .)
    TIMES           reduce using rule 77 (exp3 -> call .)
    DIVIDE          reduce using rule 77 (exp3 -> call .)
    MODULO          reduce using rule 77 (exp3 -> call .)
    PLUS            reduce using rule 77 (exp3 -> call .)
    MINUS           reduce using rule 77 (exp3 -> call .)
    SEMICOLON       reduce using rule 77 (exp3 -> call .)
    RPAREN          reduce using rule 77 (exp3 -> call .)
    RETURN          reduce using rule 77 (exp3 -> call .)
    BREAK           reduce using rule 77 (exp3 -> call .)
    CONTINUE        reduce using rule 77 (exp3 -> call .)
    IF              reduce using rule 77 (exp3 -> call .)
    ID_SC           reduce using rule 77 (exp3 -> call .)
    ID_LI           reduce using rule 77 (exp3 -> call .)
    INCREMENT       reduce using rule 77 (exp3 -> call .)
    DECREMENT       reduce using rule 77 (exp3 -> call .)
    ID              reduce using rule 77 (exp3 -> call .)
    FOR             reduce using rule 77 (exp3 -> call .)
    DO              reduce using rule 77 (exp3 -> call .)
    WHILE           reduce using rule 77 (exp3 -> call .)
    SUB             reduce using rule 77 (exp3 -> call .)
    $end            reduce using rule 77 (exp3 -> call .)
    RBRACE          reduce using rule 77 (exp3 -> call .)
    GT              reduce using rule 77 (exp3 -> call .)
    LT              reduce using rule 77 (exp3 -> call .)
    EQ              reduce using rule 77 (exp3 -> call .)
    GE              reduce using rule 77 (exp3 -> call .)
    LE              reduce using rule 77 (exp3 -> call .)
    NE              reduce using rule 77 (exp3 -> call .)
    CMP             reduce using rule 77 (exp3 -> call .)
    SEQ             reduce using rule 77 (exp3 -> call .)
    SNE             reduce using rule 77 (exp3 -> call .)
    SLT             reduce using rule 77 (exp3 -> call .)
    SGT             reduce using rule 77 (exp3 -> call .)
    SLE             reduce using rule 77 (exp3 -> call .)
    SGE             reduce using rule 77 (exp3 -> call .)
    COMMA           reduce using rule 77 (exp3 -> call .)


state 44

    (12) command -> BREAK SEMICOLON .

    RETURN          reduce using rule 12 (command -> BREAK SEMICOLON .)
    BREAK           reduce using rule 12 (command -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 12 (command -> BREAK SEMICOLON .)
    IF              reduce using rule 12 (command -> BREAK SEMICOLON .)
    ID_SC           reduce using rule 12 (command -> BREAK SEMICOLON .)
    ID_LI           reduce using rule 12 (command -> BREAK SEMICOLON .)
    INCREMENT       reduce using rule 12 (command -> BREAK SEMICOLON .)
    DECREMENT       reduce using rule 12 (command -> BREAK SEMICOLON .)
    ID              reduce using rule 12 (command -> BREAK SEMICOLON .)
    FOR             reduce using rule 12 (command -> BREAK SEMICOLON .)
    DO              reduce using rule 12 (command -> BREAK SEMICOLON .)
    WHILE           reduce using rule 12 (command -> BREAK SEMICOLON .)
    SUB             reduce using rule 12 (command -> BREAK SEMICOLON .)
    $end            reduce using rule 12 (command -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 12 (command -> BREAK SEMICOLON .)


state 45

    (13) command -> CONTINUE SEMICOLON .

    RETURN          reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    IF              reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    ID_SC           reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    ID_LI           reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    INCREMENT       reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    DECREMENT       reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    ID              reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    DO              reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    SUB             reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    $end            reduce using rule 13 (command -> CONTINUE SEMICOLON .)
    RBRACE          reduce using rule 13 (command -> CONTINUE SEMICOLON .)


state 46

    (14) if -> IF LPAREN . exp_condition RPAREN if_statement
    (35) exp_condition -> . attcond GT attcond
    (36) exp_condition -> . attcond LT attcond
    (37) exp_condition -> . attcond EQ attcond
    (38) exp_condition -> . attcond GE attcond
    (39) exp_condition -> . attcond LE attcond
    (40) exp_condition -> . attcond NE attcond
    (41) exp_condition -> . attcond
    (42) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (43) exp_condition -> . attcond CMP attcond
    (44) exp_condition -> . attcond SEQ attcond
    (45) exp_condition -> . attcond SNE attcond
    (46) exp_condition -> . attcond SLT attcond
    (47) exp_condition -> . attcond SGT attcond
    (48) exp_condition -> . attcond SLE attcond
    (49) exp_condition -> . attcond SGE attcond
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    LPAREN          shift and go to state 84
    NUMBER          shift and go to state 87
    TRUE            shift and go to state 88
    FALSE           shift and go to state 89
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    exp_condition                  shift and go to state 85
    attcond                        shift and go to state 83
    exp_assignment                 shift and go to state 86

state 47

    (55) exp_assignment -> ID_SC EQUALS . arithmetic
    (63) arithmetic -> . exp
    (64) exp -> . exp PLUS exp1
    (65) exp -> . exp MINUS exp1
    (66) exp -> . exp1
    (67) exp1 -> . exp1 TIMES exp2
    (68) exp1 -> . exp1 DIVIDE exp2
    (69) exp1 -> . exp1 MODULO exp2
    (70) exp1 -> . exp2
    (71) exp2 -> . exp3 XOR exp2
    (72) exp2 -> . exp3
    (73) exp3 -> . LPAREN arithmetic RPAREN
    (74) exp3 -> . NUMBER
    (75) exp3 -> . exp_assignment
    (76) exp3 -> . exp_condition
    (77) exp3 -> . call
    (78) exp3 -> . exp
    (79) exp3 -> . TRUE
    (80) exp3 -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (35) exp_condition -> . attcond GT attcond
    (36) exp_condition -> . attcond LT attcond
    (37) exp_condition -> . attcond EQ attcond
    (38) exp_condition -> . attcond GE attcond
    (39) exp_condition -> . attcond LE attcond
    (40) exp_condition -> . attcond NE attcond
    (41) exp_condition -> . attcond
    (42) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (43) exp_condition -> . attcond CMP attcond
    (44) exp_condition -> . attcond SEQ attcond
    (45) exp_condition -> . attcond SNE attcond
    (46) exp_condition -> . attcond SLT attcond
    (47) exp_condition -> . attcond SGT attcond
    (48) exp_condition -> . attcond SLE attcond
    (49) exp_condition -> . attcond SGE attcond
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE

    LPAREN          shift and go to state 41
    NUMBER          shift and go to state 91
    TRUE            shift and go to state 93
    FALSE           shift and go to state 94
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    ID              shift and go to state 6

    arithmetic                     shift and go to state 90
    exp                            shift and go to state 37
    exp1                           shift and go to state 38
    exp2                           shift and go to state 39
    exp3                           shift and go to state 40
    exp_assignment                 shift and go to state 92
    exp_condition                  shift and go to state 42
    call                           shift and go to state 43
    attcond                        shift and go to state 83

state 48

    (61) exp_assignment -> ID_SC INCREMENT .

    RETURN          reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    BREAK           reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    CONTINUE        reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    IF              reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    ID_SC           reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    ID_LI           reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    INCREMENT       reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    DECREMENT       reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    ID              reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    FOR             reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    DO              reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    WHILE           reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    SUB             reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    $end            reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    RBRACE          reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    GT              reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    LT              reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    EQ              reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    GE              reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    LE              reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    NE              reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    CMP             reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    SEQ             reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    SNE             reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    SLT             reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    SGT             reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    SLE             reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    SGE             reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    SEMICOLON       reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    XOR             reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    TIMES           reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    DIVIDE          reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    MODULO          reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    PLUS            reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    MINUS           reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    COMMA           reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)
    RPAREN          reduce using rule 61 (exp_assignment -> ID_SC INCREMENT .)


state 49

    (62) exp_assignment -> ID_SC DECREMENT .

    RETURN          reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    BREAK           reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    CONTINUE        reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    IF              reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    ID_SC           reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    ID_LI           reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    INCREMENT       reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    DECREMENT       reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    ID              reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    FOR             reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    DO              reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    WHILE           reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    SUB             reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    $end            reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    RBRACE          reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    GT              reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    LT              reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    EQ              reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    GE              reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    LE              reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    NE              reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    CMP             reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    SEQ             reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    SNE             reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    SLT             reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    SGT             reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    SLE             reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    SGE             reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    SEMICOLON       reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    XOR             reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    TIMES           reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    DIVIDE          reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    MODULO          reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    PLUS            reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    MINUS           reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    COMMA           reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)
    RPAREN          reduce using rule 62 (exp_assignment -> ID_SC DECREMENT .)


state 50

    (56) exp_assignment -> ID_LI EQUALS . arithmetic
    (63) arithmetic -> . exp
    (64) exp -> . exp PLUS exp1
    (65) exp -> . exp MINUS exp1
    (66) exp -> . exp1
    (67) exp1 -> . exp1 TIMES exp2
    (68) exp1 -> . exp1 DIVIDE exp2
    (69) exp1 -> . exp1 MODULO exp2
    (70) exp1 -> . exp2
    (71) exp2 -> . exp3 XOR exp2
    (72) exp2 -> . exp3
    (73) exp3 -> . LPAREN arithmetic RPAREN
    (74) exp3 -> . NUMBER
    (75) exp3 -> . exp_assignment
    (76) exp3 -> . exp_condition
    (77) exp3 -> . call
    (78) exp3 -> . exp
    (79) exp3 -> . TRUE
    (80) exp3 -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (35) exp_condition -> . attcond GT attcond
    (36) exp_condition -> . attcond LT attcond
    (37) exp_condition -> . attcond EQ attcond
    (38) exp_condition -> . attcond GE attcond
    (39) exp_condition -> . attcond LE attcond
    (40) exp_condition -> . attcond NE attcond
    (41) exp_condition -> . attcond
    (42) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (43) exp_condition -> . attcond CMP attcond
    (44) exp_condition -> . attcond SEQ attcond
    (45) exp_condition -> . attcond SNE attcond
    (46) exp_condition -> . attcond SLT attcond
    (47) exp_condition -> . attcond SGT attcond
    (48) exp_condition -> . attcond SLE attcond
    (49) exp_condition -> . attcond SGE attcond
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE

    LPAREN          shift and go to state 41
    NUMBER          shift and go to state 91
    TRUE            shift and go to state 93
    FALSE           shift and go to state 94
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    ID              shift and go to state 6

    arithmetic                     shift and go to state 95
    exp                            shift and go to state 37
    exp1                           shift and go to state 38
    exp2                           shift and go to state 39
    exp3                           shift and go to state 40
    exp_assignment                 shift and go to state 92
    exp_condition                  shift and go to state 42
    call                           shift and go to state 43
    attcond                        shift and go to state 83

state 51

    (59) exp_assignment -> INCREMENT ID_SC .

    RETURN          reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    BREAK           reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    CONTINUE        reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    IF              reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    ID_SC           reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    ID_LI           reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    INCREMENT       reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    DECREMENT       reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    ID              reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    FOR             reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    DO              reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    WHILE           reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    SUB             reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    $end            reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    RBRACE          reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    GT              reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    LT              reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    EQ              reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    GE              reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    LE              reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    NE              reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    CMP             reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    SEQ             reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    SNE             reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    SLT             reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    SGT             reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    SLE             reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    SGE             reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    SEMICOLON       reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    XOR             reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    TIMES           reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    DIVIDE          reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    MODULO          reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    PLUS            reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    MINUS           reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    COMMA           reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)
    RPAREN          reduce using rule 59 (exp_assignment -> INCREMENT ID_SC .)


state 52

    (60) exp_assignment -> DECREMENT ID_SC .

    RETURN          reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    BREAK           reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    CONTINUE        reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    IF              reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    ID_SC           reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    ID_LI           reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    INCREMENT       reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    DECREMENT       reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    ID              reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    FOR             reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    DO              reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    WHILE           reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    SUB             reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    $end            reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    RBRACE          reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    GT              reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    LT              reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    EQ              reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    GE              reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    LE              reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    NE              reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    CMP             reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    SEQ             reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    SNE             reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    SLT             reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    SGT             reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    SLE             reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    SGE             reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    SEMICOLON       reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    XOR             reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    TIMES           reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    DIVIDE          reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    MODULO          reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    PLUS            reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    MINUS           reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    COMMA           reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)
    RPAREN          reduce using rule 60 (exp_assignment -> DECREMENT ID_SC .)


state 53

    (25) for -> FOR LPAREN . for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (26) for_assignments -> . exp_assignment
    (27) for_assignments -> . exp_assignment COMMA for_assignments
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    for_assignments                shift and go to state 96
    exp_assignment                 shift and go to state 97

state 54

    (28) dowhile -> DO LBRACE . blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN if_statement
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (30) while -> . WHILE LPAREN exp_condition RPAREN LBRACE RBRACE

    RETURN          shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    IF              shift and go to state 17
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    ID              shift and go to state 6
    FOR             shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24

    blockcode                      shift and go to state 98
    command                        shift and go to state 4
    interations                    shift and go to state 7
    if                             shift and go to state 8
    exp_assignment                 shift and go to state 9
    call                           shift and go to state 10
    for                            shift and go to state 14
    dowhile                        shift and go to state 15
    while                          shift and go to state 16

state 55

    (29) while -> WHILE LPAREN . exp_condition RPAREN LBRACE blockcode RBRACE
    (30) while -> WHILE LPAREN . exp_condition RPAREN LBRACE RBRACE
    (35) exp_condition -> . attcond GT attcond
    (36) exp_condition -> . attcond LT attcond
    (37) exp_condition -> . attcond EQ attcond
    (38) exp_condition -> . attcond GE attcond
    (39) exp_condition -> . attcond LE attcond
    (40) exp_condition -> . attcond NE attcond
    (41) exp_condition -> . attcond
    (42) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (43) exp_condition -> . attcond CMP attcond
    (44) exp_condition -> . attcond SEQ attcond
    (45) exp_condition -> . attcond SNE attcond
    (46) exp_condition -> . attcond SLT attcond
    (47) exp_condition -> . attcond SGT attcond
    (48) exp_condition -> . attcond SLE attcond
    (49) exp_condition -> . attcond SGE attcond
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    LPAREN          shift and go to state 84
    NUMBER          shift and go to state 87
    TRUE            shift and go to state 88
    FALSE           shift and go to state 89
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    exp_condition                  shift and go to state 99
    attcond                        shift and go to state 83
    exp_assignment                 shift and go to state 86

state 56

    (31) function -> SUB ID LPAREN . RPAREN LBRACE blockcode RBRACE
    (32) function -> SUB ID LPAREN . function_assignments RPAREN LBRACE blockcode RBRACE
    (33) function_assignments -> . exp_assignment
    (34) function_assignments -> . exp_assignment COMMA function_assignments
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    RPAREN          shift and go to state 100
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    function_assignments           shift and go to state 101
    exp_assignment                 shift and go to state 59

state 57

    (85) call -> ID LPAREN RPAREN .

    RETURN          reduce using rule 85 (call -> ID LPAREN RPAREN .)
    BREAK           reduce using rule 85 (call -> ID LPAREN RPAREN .)
    CONTINUE        reduce using rule 85 (call -> ID LPAREN RPAREN .)
    IF              reduce using rule 85 (call -> ID LPAREN RPAREN .)
    ID_SC           reduce using rule 85 (call -> ID LPAREN RPAREN .)
    ID_LI           reduce using rule 85 (call -> ID LPAREN RPAREN .)
    INCREMENT       reduce using rule 85 (call -> ID LPAREN RPAREN .)
    DECREMENT       reduce using rule 85 (call -> ID LPAREN RPAREN .)
    ID              reduce using rule 85 (call -> ID LPAREN RPAREN .)
    FOR             reduce using rule 85 (call -> ID LPAREN RPAREN .)
    DO              reduce using rule 85 (call -> ID LPAREN RPAREN .)
    WHILE           reduce using rule 85 (call -> ID LPAREN RPAREN .)
    SUB             reduce using rule 85 (call -> ID LPAREN RPAREN .)
    $end            reduce using rule 85 (call -> ID LPAREN RPAREN .)
    RBRACE          reduce using rule 85 (call -> ID LPAREN RPAREN .)
    XOR             reduce using rule 85 (call -> ID LPAREN RPAREN .)
    TIMES           reduce using rule 85 (call -> ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 85 (call -> ID LPAREN RPAREN .)
    MODULO          reduce using rule 85 (call -> ID LPAREN RPAREN .)
    PLUS            reduce using rule 85 (call -> ID LPAREN RPAREN .)
    MINUS           reduce using rule 85 (call -> ID LPAREN RPAREN .)
    SEMICOLON       reduce using rule 85 (call -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 85 (call -> ID LPAREN RPAREN .)
    GT              reduce using rule 85 (call -> ID LPAREN RPAREN .)
    LT              reduce using rule 85 (call -> ID LPAREN RPAREN .)
    EQ              reduce using rule 85 (call -> ID LPAREN RPAREN .)
    GE              reduce using rule 85 (call -> ID LPAREN RPAREN .)
    LE              reduce using rule 85 (call -> ID LPAREN RPAREN .)
    NE              reduce using rule 85 (call -> ID LPAREN RPAREN .)
    CMP             reduce using rule 85 (call -> ID LPAREN RPAREN .)
    SEQ             reduce using rule 85 (call -> ID LPAREN RPAREN .)
    SNE             reduce using rule 85 (call -> ID LPAREN RPAREN .)
    SLT             reduce using rule 85 (call -> ID LPAREN RPAREN .)
    SGT             reduce using rule 85 (call -> ID LPAREN RPAREN .)
    SLE             reduce using rule 85 (call -> ID LPAREN RPAREN .)
    SGE             reduce using rule 85 (call -> ID LPAREN RPAREN .)
    COMMA           reduce using rule 85 (call -> ID LPAREN RPAREN .)


state 58

    (86) call -> ID LPAREN function_assignments . RPAREN

    RPAREN          shift and go to state 102


state 59

    (33) function_assignments -> exp_assignment .
    (34) function_assignments -> exp_assignment . COMMA function_assignments

    RPAREN          reduce using rule 33 (function_assignments -> exp_assignment .)
    COMMA           shift and go to state 103


state 60

    (11) command -> RETURN return SEMICOLON .

    RETURN          reduce using rule 11 (command -> RETURN return SEMICOLON .)
    BREAK           reduce using rule 11 (command -> RETURN return SEMICOLON .)
    CONTINUE        reduce using rule 11 (command -> RETURN return SEMICOLON .)
    IF              reduce using rule 11 (command -> RETURN return SEMICOLON .)
    ID_SC           reduce using rule 11 (command -> RETURN return SEMICOLON .)
    ID_LI           reduce using rule 11 (command -> RETURN return SEMICOLON .)
    INCREMENT       reduce using rule 11 (command -> RETURN return SEMICOLON .)
    DECREMENT       reduce using rule 11 (command -> RETURN return SEMICOLON .)
    ID              reduce using rule 11 (command -> RETURN return SEMICOLON .)
    FOR             reduce using rule 11 (command -> RETURN return SEMICOLON .)
    DO              reduce using rule 11 (command -> RETURN return SEMICOLON .)
    WHILE           reduce using rule 11 (command -> RETURN return SEMICOLON .)
    SUB             reduce using rule 11 (command -> RETURN return SEMICOLON .)
    $end            reduce using rule 11 (command -> RETURN return SEMICOLON .)
    RBRACE          reduce using rule 11 (command -> RETURN return SEMICOLON .)


state 61

    (35) exp_condition -> attcond GT . attcond
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    NUMBER          shift and go to state 87
    TRUE            shift and go to state 88
    FALSE           shift and go to state 89
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    attcond                        shift and go to state 104
    exp_assignment                 shift and go to state 86

state 62

    (36) exp_condition -> attcond LT . attcond
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    NUMBER          shift and go to state 87
    TRUE            shift and go to state 88
    FALSE           shift and go to state 89
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    attcond                        shift and go to state 105
    exp_assignment                 shift and go to state 86

state 63

    (37) exp_condition -> attcond EQ . attcond
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    NUMBER          shift and go to state 87
    TRUE            shift and go to state 88
    FALSE           shift and go to state 89
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    attcond                        shift and go to state 106
    exp_assignment                 shift and go to state 86

state 64

    (38) exp_condition -> attcond GE . attcond
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    NUMBER          shift and go to state 87
    TRUE            shift and go to state 88
    FALSE           shift and go to state 89
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    attcond                        shift and go to state 107
    exp_assignment                 shift and go to state 86

state 65

    (39) exp_condition -> attcond LE . attcond
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    NUMBER          shift and go to state 87
    TRUE            shift and go to state 88
    FALSE           shift and go to state 89
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    attcond                        shift and go to state 108
    exp_assignment                 shift and go to state 86

state 66

    (40) exp_condition -> attcond NE . attcond
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    NUMBER          shift and go to state 87
    TRUE            shift and go to state 88
    FALSE           shift and go to state 89
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    attcond                        shift and go to state 109
    exp_assignment                 shift and go to state 86

state 67

    (43) exp_condition -> attcond CMP . attcond
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    NUMBER          shift and go to state 87
    TRUE            shift and go to state 88
    FALSE           shift and go to state 89
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    attcond                        shift and go to state 110
    exp_assignment                 shift and go to state 86

state 68

    (44) exp_condition -> attcond SEQ . attcond
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    NUMBER          shift and go to state 87
    TRUE            shift and go to state 88
    FALSE           shift and go to state 89
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    attcond                        shift and go to state 111
    exp_assignment                 shift and go to state 86

state 69

    (45) exp_condition -> attcond SNE . attcond
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    NUMBER          shift and go to state 87
    TRUE            shift and go to state 88
    FALSE           shift and go to state 89
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    attcond                        shift and go to state 112
    exp_assignment                 shift and go to state 86

state 70

    (46) exp_condition -> attcond SLT . attcond
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    NUMBER          shift and go to state 87
    TRUE            shift and go to state 88
    FALSE           shift and go to state 89
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    attcond                        shift and go to state 113
    exp_assignment                 shift and go to state 86

state 71

    (47) exp_condition -> attcond SGT . attcond
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    NUMBER          shift and go to state 87
    TRUE            shift and go to state 88
    FALSE           shift and go to state 89
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    attcond                        shift and go to state 114
    exp_assignment                 shift and go to state 86

state 72

    (48) exp_condition -> attcond SLE . attcond
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    NUMBER          shift and go to state 87
    TRUE            shift and go to state 88
    FALSE           shift and go to state 89
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    attcond                        shift and go to state 115
    exp_assignment                 shift and go to state 86

state 73

    (49) exp_condition -> attcond SGE . attcond
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    NUMBER          shift and go to state 87
    TRUE            shift and go to state 88
    FALSE           shift and go to state 89
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    attcond                        shift and go to state 116
    exp_assignment                 shift and go to state 86

state 74

    (64) exp -> exp PLUS . exp1
    (67) exp1 -> . exp1 TIMES exp2
    (68) exp1 -> . exp1 DIVIDE exp2
    (69) exp1 -> . exp1 MODULO exp2
    (70) exp1 -> . exp2
    (71) exp2 -> . exp3 XOR exp2
    (72) exp2 -> . exp3
    (73) exp3 -> . LPAREN arithmetic RPAREN
    (74) exp3 -> . NUMBER
    (75) exp3 -> . exp_assignment
    (76) exp3 -> . exp_condition
    (77) exp3 -> . call
    (78) exp3 -> . exp
    (79) exp3 -> . TRUE
    (80) exp3 -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (35) exp_condition -> . attcond GT attcond
    (36) exp_condition -> . attcond LT attcond
    (37) exp_condition -> . attcond EQ attcond
    (38) exp_condition -> . attcond GE attcond
    (39) exp_condition -> . attcond LE attcond
    (40) exp_condition -> . attcond NE attcond
    (41) exp_condition -> . attcond
    (42) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (43) exp_condition -> . attcond CMP attcond
    (44) exp_condition -> . attcond SEQ attcond
    (45) exp_condition -> . attcond SNE attcond
    (46) exp_condition -> . attcond SLT attcond
    (47) exp_condition -> . attcond SGT attcond
    (48) exp_condition -> . attcond SLE attcond
    (49) exp_condition -> . attcond SGE attcond
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN
    (64) exp -> . exp PLUS exp1
    (65) exp -> . exp MINUS exp1
    (66) exp -> . exp1
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE

    LPAREN          shift and go to state 41
    NUMBER          shift and go to state 91
    TRUE            shift and go to state 93
    FALSE           shift and go to state 94
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    ID              shift and go to state 6

    exp                            shift and go to state 117
    exp1                           shift and go to state 118
    exp2                           shift and go to state 39
    exp3                           shift and go to state 40
    exp_assignment                 shift and go to state 92
    exp_condition                  shift and go to state 42
    call                           shift and go to state 43
    attcond                        shift and go to state 83

state 75

    (65) exp -> exp MINUS . exp1
    (67) exp1 -> . exp1 TIMES exp2
    (68) exp1 -> . exp1 DIVIDE exp2
    (69) exp1 -> . exp1 MODULO exp2
    (70) exp1 -> . exp2
    (71) exp2 -> . exp3 XOR exp2
    (72) exp2 -> . exp3
    (73) exp3 -> . LPAREN arithmetic RPAREN
    (74) exp3 -> . NUMBER
    (75) exp3 -> . exp_assignment
    (76) exp3 -> . exp_condition
    (77) exp3 -> . call
    (78) exp3 -> . exp
    (79) exp3 -> . TRUE
    (80) exp3 -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (35) exp_condition -> . attcond GT attcond
    (36) exp_condition -> . attcond LT attcond
    (37) exp_condition -> . attcond EQ attcond
    (38) exp_condition -> . attcond GE attcond
    (39) exp_condition -> . attcond LE attcond
    (40) exp_condition -> . attcond NE attcond
    (41) exp_condition -> . attcond
    (42) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (43) exp_condition -> . attcond CMP attcond
    (44) exp_condition -> . attcond SEQ attcond
    (45) exp_condition -> . attcond SNE attcond
    (46) exp_condition -> . attcond SLT attcond
    (47) exp_condition -> . attcond SGT attcond
    (48) exp_condition -> . attcond SLE attcond
    (49) exp_condition -> . attcond SGE attcond
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN
    (64) exp -> . exp PLUS exp1
    (65) exp -> . exp MINUS exp1
    (66) exp -> . exp1
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE

    LPAREN          shift and go to state 41
    NUMBER          shift and go to state 91
    TRUE            shift and go to state 93
    FALSE           shift and go to state 94
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    ID              shift and go to state 6

    exp                            shift and go to state 117
    exp1                           shift and go to state 119
    exp2                           shift and go to state 39
    exp3                           shift and go to state 40
    exp_assignment                 shift and go to state 92
    exp_condition                  shift and go to state 42
    call                           shift and go to state 43
    attcond                        shift and go to state 83

state 76

    (67) exp1 -> exp1 TIMES . exp2
    (71) exp2 -> . exp3 XOR exp2
    (72) exp2 -> . exp3
    (73) exp3 -> . LPAREN arithmetic RPAREN
    (74) exp3 -> . NUMBER
    (75) exp3 -> . exp_assignment
    (76) exp3 -> . exp_condition
    (77) exp3 -> . call
    (78) exp3 -> . exp
    (79) exp3 -> . TRUE
    (80) exp3 -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (35) exp_condition -> . attcond GT attcond
    (36) exp_condition -> . attcond LT attcond
    (37) exp_condition -> . attcond EQ attcond
    (38) exp_condition -> . attcond GE attcond
    (39) exp_condition -> . attcond LE attcond
    (40) exp_condition -> . attcond NE attcond
    (41) exp_condition -> . attcond
    (42) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (43) exp_condition -> . attcond CMP attcond
    (44) exp_condition -> . attcond SEQ attcond
    (45) exp_condition -> . attcond SNE attcond
    (46) exp_condition -> . attcond SLT attcond
    (47) exp_condition -> . attcond SGT attcond
    (48) exp_condition -> . attcond SLE attcond
    (49) exp_condition -> . attcond SGE attcond
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN
    (64) exp -> . exp PLUS exp1
    (65) exp -> . exp MINUS exp1
    (66) exp -> . exp1
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (67) exp1 -> . exp1 TIMES exp2
    (68) exp1 -> . exp1 DIVIDE exp2
    (69) exp1 -> . exp1 MODULO exp2
    (70) exp1 -> . exp2

    LPAREN          shift and go to state 41
    NUMBER          shift and go to state 91
    TRUE            shift and go to state 93
    FALSE           shift and go to state 94
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    ID              shift and go to state 6

    exp1                           shift and go to state 38
    exp2                           shift and go to state 120
    exp3                           shift and go to state 40
    exp_assignment                 shift and go to state 92
    exp_condition                  shift and go to state 42
    call                           shift and go to state 43
    exp                            shift and go to state 117
    attcond                        shift and go to state 83

state 77

    (68) exp1 -> exp1 DIVIDE . exp2
    (71) exp2 -> . exp3 XOR exp2
    (72) exp2 -> . exp3
    (73) exp3 -> . LPAREN arithmetic RPAREN
    (74) exp3 -> . NUMBER
    (75) exp3 -> . exp_assignment
    (76) exp3 -> . exp_condition
    (77) exp3 -> . call
    (78) exp3 -> . exp
    (79) exp3 -> . TRUE
    (80) exp3 -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (35) exp_condition -> . attcond GT attcond
    (36) exp_condition -> . attcond LT attcond
    (37) exp_condition -> . attcond EQ attcond
    (38) exp_condition -> . attcond GE attcond
    (39) exp_condition -> . attcond LE attcond
    (40) exp_condition -> . attcond NE attcond
    (41) exp_condition -> . attcond
    (42) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (43) exp_condition -> . attcond CMP attcond
    (44) exp_condition -> . attcond SEQ attcond
    (45) exp_condition -> . attcond SNE attcond
    (46) exp_condition -> . attcond SLT attcond
    (47) exp_condition -> . attcond SGT attcond
    (48) exp_condition -> . attcond SLE attcond
    (49) exp_condition -> . attcond SGE attcond
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN
    (64) exp -> . exp PLUS exp1
    (65) exp -> . exp MINUS exp1
    (66) exp -> . exp1
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (67) exp1 -> . exp1 TIMES exp2
    (68) exp1 -> . exp1 DIVIDE exp2
    (69) exp1 -> . exp1 MODULO exp2
    (70) exp1 -> . exp2

    LPAREN          shift and go to state 41
    NUMBER          shift and go to state 91
    TRUE            shift and go to state 93
    FALSE           shift and go to state 94
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    ID              shift and go to state 6

    exp1                           shift and go to state 38
    exp2                           shift and go to state 121
    exp3                           shift and go to state 40
    exp_assignment                 shift and go to state 92
    exp_condition                  shift and go to state 42
    call                           shift and go to state 43
    exp                            shift and go to state 117
    attcond                        shift and go to state 83

state 78

    (69) exp1 -> exp1 MODULO . exp2
    (71) exp2 -> . exp3 XOR exp2
    (72) exp2 -> . exp3
    (73) exp3 -> . LPAREN arithmetic RPAREN
    (74) exp3 -> . NUMBER
    (75) exp3 -> . exp_assignment
    (76) exp3 -> . exp_condition
    (77) exp3 -> . call
    (78) exp3 -> . exp
    (79) exp3 -> . TRUE
    (80) exp3 -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (35) exp_condition -> . attcond GT attcond
    (36) exp_condition -> . attcond LT attcond
    (37) exp_condition -> . attcond EQ attcond
    (38) exp_condition -> . attcond GE attcond
    (39) exp_condition -> . attcond LE attcond
    (40) exp_condition -> . attcond NE attcond
    (41) exp_condition -> . attcond
    (42) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (43) exp_condition -> . attcond CMP attcond
    (44) exp_condition -> . attcond SEQ attcond
    (45) exp_condition -> . attcond SNE attcond
    (46) exp_condition -> . attcond SLT attcond
    (47) exp_condition -> . attcond SGT attcond
    (48) exp_condition -> . attcond SLE attcond
    (49) exp_condition -> . attcond SGE attcond
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN
    (64) exp -> . exp PLUS exp1
    (65) exp -> . exp MINUS exp1
    (66) exp -> . exp1
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (67) exp1 -> . exp1 TIMES exp2
    (68) exp1 -> . exp1 DIVIDE exp2
    (69) exp1 -> . exp1 MODULO exp2
    (70) exp1 -> . exp2

    LPAREN          shift and go to state 41
    NUMBER          shift and go to state 91
    TRUE            shift and go to state 93
    FALSE           shift and go to state 94
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    ID              shift and go to state 6

    exp1                           shift and go to state 38
    exp2                           shift and go to state 122
    exp3                           shift and go to state 40
    exp_assignment                 shift and go to state 92
    exp_condition                  shift and go to state 42
    call                           shift and go to state 43
    exp                            shift and go to state 117
    attcond                        shift and go to state 83

state 79

    (71) exp2 -> exp3 XOR . exp2
    (71) exp2 -> . exp3 XOR exp2
    (72) exp2 -> . exp3
    (73) exp3 -> . LPAREN arithmetic RPAREN
    (74) exp3 -> . NUMBER
    (75) exp3 -> . exp_assignment
    (76) exp3 -> . exp_condition
    (77) exp3 -> . call
    (78) exp3 -> . exp
    (79) exp3 -> . TRUE
    (80) exp3 -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (35) exp_condition -> . attcond GT attcond
    (36) exp_condition -> . attcond LT attcond
    (37) exp_condition -> . attcond EQ attcond
    (38) exp_condition -> . attcond GE attcond
    (39) exp_condition -> . attcond LE attcond
    (40) exp_condition -> . attcond NE attcond
    (41) exp_condition -> . attcond
    (42) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (43) exp_condition -> . attcond CMP attcond
    (44) exp_condition -> . attcond SEQ attcond
    (45) exp_condition -> . attcond SNE attcond
    (46) exp_condition -> . attcond SLT attcond
    (47) exp_condition -> . attcond SGT attcond
    (48) exp_condition -> . attcond SLE attcond
    (49) exp_condition -> . attcond SGE attcond
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN
    (64) exp -> . exp PLUS exp1
    (65) exp -> . exp MINUS exp1
    (66) exp -> . exp1
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (67) exp1 -> . exp1 TIMES exp2
    (68) exp1 -> . exp1 DIVIDE exp2
    (69) exp1 -> . exp1 MODULO exp2
    (70) exp1 -> . exp2

    LPAREN          shift and go to state 41
    NUMBER          shift and go to state 91
    TRUE            shift and go to state 93
    FALSE           shift and go to state 94
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    ID              shift and go to state 6

    exp3                           shift and go to state 40
    exp2                           shift and go to state 123
    exp_assignment                 shift and go to state 92
    exp_condition                  shift and go to state 42
    call                           shift and go to state 43
    exp                            shift and go to state 117
    attcond                        shift and go to state 83
    exp1                           shift and go to state 38

state 80

    (42) exp_condition -> LPAREN . exp_condition RPAREN logic exp_condition_logic
    (73) exp3 -> LPAREN . arithmetic RPAREN
    (35) exp_condition -> . attcond GT attcond
    (36) exp_condition -> . attcond LT attcond
    (37) exp_condition -> . attcond EQ attcond
    (38) exp_condition -> . attcond GE attcond
    (39) exp_condition -> . attcond LE attcond
    (40) exp_condition -> . attcond NE attcond
    (41) exp_condition -> . attcond
    (42) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (43) exp_condition -> . attcond CMP attcond
    (44) exp_condition -> . attcond SEQ attcond
    (45) exp_condition -> . attcond SNE attcond
    (46) exp_condition -> . attcond SLT attcond
    (47) exp_condition -> . attcond SGT attcond
    (48) exp_condition -> . attcond SLE attcond
    (49) exp_condition -> . attcond SGE attcond
    (63) arithmetic -> . exp
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (64) exp -> . exp PLUS exp1
    (65) exp -> . exp MINUS exp1
    (66) exp -> . exp1
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (67) exp1 -> . exp1 TIMES exp2
    (68) exp1 -> . exp1 DIVIDE exp2
    (69) exp1 -> . exp1 MODULO exp2
    (70) exp1 -> . exp2
    (71) exp2 -> . exp3 XOR exp2
    (72) exp2 -> . exp3
    (73) exp3 -> . LPAREN arithmetic RPAREN
    (74) exp3 -> . NUMBER
    (75) exp3 -> . exp_assignment
    (76) exp3 -> . exp_condition
    (77) exp3 -> . call
    (78) exp3 -> . exp
    (79) exp3 -> . TRUE
    (80) exp3 -> . FALSE
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN

    LPAREN          shift and go to state 80
    NUMBER          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    ID              shift and go to state 6

    exp_condition                  shift and go to state 82
    arithmetic                     shift and go to state 81
    attcond                        shift and go to state 83
    exp                            shift and go to state 37
    exp_assignment                 shift and go to state 33
    exp1                           shift and go to state 38
    exp2                           shift and go to state 39
    exp3                           shift and go to state 40
    call                           shift and go to state 43

state 81

    (73) exp3 -> LPAREN arithmetic . RPAREN

    RPAREN          shift and go to state 124


state 82

    (42) exp_condition -> LPAREN exp_condition . RPAREN logic exp_condition_logic
    (76) exp3 -> exp_condition .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 125
    XOR             reduce using rule 76 (exp3 -> exp_condition .)
    TIMES           reduce using rule 76 (exp3 -> exp_condition .)
    DIVIDE          reduce using rule 76 (exp3 -> exp_condition .)
    MODULO          reduce using rule 76 (exp3 -> exp_condition .)
    PLUS            reduce using rule 76 (exp3 -> exp_condition .)
    MINUS           reduce using rule 76 (exp3 -> exp_condition .)

  ! RPAREN          [ reduce using rule 76 (exp3 -> exp_condition .) ]


state 83

    (35) exp_condition -> attcond . GT attcond
    (36) exp_condition -> attcond . LT attcond
    (37) exp_condition -> attcond . EQ attcond
    (38) exp_condition -> attcond . GE attcond
    (39) exp_condition -> attcond . LE attcond
    (40) exp_condition -> attcond . NE attcond
    (41) exp_condition -> attcond .
    (43) exp_condition -> attcond . CMP attcond
    (44) exp_condition -> attcond . SEQ attcond
    (45) exp_condition -> attcond . SNE attcond
    (46) exp_condition -> attcond . SLT attcond
    (47) exp_condition -> attcond . SGT attcond
    (48) exp_condition -> attcond . SLE attcond
    (49) exp_condition -> attcond . SGE attcond

  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for CMP resolved as shift
  ! shift/reduce conflict for SEQ resolved as shift
  ! shift/reduce conflict for SNE resolved as shift
  ! shift/reduce conflict for SLT resolved as shift
  ! shift/reduce conflict for SGT resolved as shift
  ! shift/reduce conflict for SLE resolved as shift
  ! shift/reduce conflict for SGE resolved as shift
    GT              shift and go to state 61
    LT              shift and go to state 62
    EQ              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    NE              shift and go to state 66
    RPAREN          reduce using rule 41 (exp_condition -> attcond .)
    XOR             reduce using rule 41 (exp_condition -> attcond .)
    TIMES           reduce using rule 41 (exp_condition -> attcond .)
    DIVIDE          reduce using rule 41 (exp_condition -> attcond .)
    MODULO          reduce using rule 41 (exp_condition -> attcond .)
    PLUS            reduce using rule 41 (exp_condition -> attcond .)
    MINUS           reduce using rule 41 (exp_condition -> attcond .)
    RETURN          reduce using rule 41 (exp_condition -> attcond .)
    BREAK           reduce using rule 41 (exp_condition -> attcond .)
    CONTINUE        reduce using rule 41 (exp_condition -> attcond .)
    IF              reduce using rule 41 (exp_condition -> attcond .)
    ID_SC           reduce using rule 41 (exp_condition -> attcond .)
    ID_LI           reduce using rule 41 (exp_condition -> attcond .)
    INCREMENT       reduce using rule 41 (exp_condition -> attcond .)
    DECREMENT       reduce using rule 41 (exp_condition -> attcond .)
    ID              reduce using rule 41 (exp_condition -> attcond .)
    FOR             reduce using rule 41 (exp_condition -> attcond .)
    DO              reduce using rule 41 (exp_condition -> attcond .)
    WHILE           reduce using rule 41 (exp_condition -> attcond .)
    SUB             reduce using rule 41 (exp_condition -> attcond .)
    $end            reduce using rule 41 (exp_condition -> attcond .)
    RBRACE          reduce using rule 41 (exp_condition -> attcond .)
    SEMICOLON       reduce using rule 41 (exp_condition -> attcond .)
    COMMA           reduce using rule 41 (exp_condition -> attcond .)
    CMP             shift and go to state 67
    SEQ             shift and go to state 68
    SNE             shift and go to state 69
    SLT             shift and go to state 70
    SGT             shift and go to state 71
    SLE             shift and go to state 72
    SGE             shift and go to state 73

  ! GT              [ reduce using rule 41 (exp_condition -> attcond .) ]
  ! LT              [ reduce using rule 41 (exp_condition -> attcond .) ]
  ! EQ              [ reduce using rule 41 (exp_condition -> attcond .) ]
  ! GE              [ reduce using rule 41 (exp_condition -> attcond .) ]
  ! LE              [ reduce using rule 41 (exp_condition -> attcond .) ]
  ! NE              [ reduce using rule 41 (exp_condition -> attcond .) ]
  ! CMP             [ reduce using rule 41 (exp_condition -> attcond .) ]
  ! SEQ             [ reduce using rule 41 (exp_condition -> attcond .) ]
  ! SNE             [ reduce using rule 41 (exp_condition -> attcond .) ]
  ! SLT             [ reduce using rule 41 (exp_condition -> attcond .) ]
  ! SGT             [ reduce using rule 41 (exp_condition -> attcond .) ]
  ! SLE             [ reduce using rule 41 (exp_condition -> attcond .) ]
  ! SGE             [ reduce using rule 41 (exp_condition -> attcond .) ]


state 84

    (42) exp_condition -> LPAREN . exp_condition RPAREN logic exp_condition_logic
    (35) exp_condition -> . attcond GT attcond
    (36) exp_condition -> . attcond LT attcond
    (37) exp_condition -> . attcond EQ attcond
    (38) exp_condition -> . attcond GE attcond
    (39) exp_condition -> . attcond LE attcond
    (40) exp_condition -> . attcond NE attcond
    (41) exp_condition -> . attcond
    (42) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (43) exp_condition -> . attcond CMP attcond
    (44) exp_condition -> . attcond SEQ attcond
    (45) exp_condition -> . attcond SNE attcond
    (46) exp_condition -> . attcond SLT attcond
    (47) exp_condition -> . attcond SGT attcond
    (48) exp_condition -> . attcond SLE attcond
    (49) exp_condition -> . attcond SGE attcond
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    LPAREN          shift and go to state 84
    NUMBER          shift and go to state 87
    TRUE            shift and go to state 88
    FALSE           shift and go to state 89
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    exp_condition                  shift and go to state 126
    attcond                        shift and go to state 83
    exp_assignment                 shift and go to state 86

state 85

    (14) if -> IF LPAREN exp_condition . RPAREN if_statement

    RPAREN          shift and go to state 127


state 86

    (81) attcond -> exp_assignment .

    GT              reduce using rule 81 (attcond -> exp_assignment .)
    LT              reduce using rule 81 (attcond -> exp_assignment .)
    EQ              reduce using rule 81 (attcond -> exp_assignment .)
    GE              reduce using rule 81 (attcond -> exp_assignment .)
    LE              reduce using rule 81 (attcond -> exp_assignment .)
    NE              reduce using rule 81 (attcond -> exp_assignment .)
    CMP             reduce using rule 81 (attcond -> exp_assignment .)
    SEQ             reduce using rule 81 (attcond -> exp_assignment .)
    SNE             reduce using rule 81 (attcond -> exp_assignment .)
    SLT             reduce using rule 81 (attcond -> exp_assignment .)
    SGT             reduce using rule 81 (attcond -> exp_assignment .)
    SLE             reduce using rule 81 (attcond -> exp_assignment .)
    SGE             reduce using rule 81 (attcond -> exp_assignment .)
    RPAREN          reduce using rule 81 (attcond -> exp_assignment .)
    RETURN          reduce using rule 81 (attcond -> exp_assignment .)
    BREAK           reduce using rule 81 (attcond -> exp_assignment .)
    CONTINUE        reduce using rule 81 (attcond -> exp_assignment .)
    IF              reduce using rule 81 (attcond -> exp_assignment .)
    ID_SC           reduce using rule 81 (attcond -> exp_assignment .)
    ID_LI           reduce using rule 81 (attcond -> exp_assignment .)
    INCREMENT       reduce using rule 81 (attcond -> exp_assignment .)
    DECREMENT       reduce using rule 81 (attcond -> exp_assignment .)
    ID              reduce using rule 81 (attcond -> exp_assignment .)
    FOR             reduce using rule 81 (attcond -> exp_assignment .)
    DO              reduce using rule 81 (attcond -> exp_assignment .)
    WHILE           reduce using rule 81 (attcond -> exp_assignment .)
    SUB             reduce using rule 81 (attcond -> exp_assignment .)
    $end            reduce using rule 81 (attcond -> exp_assignment .)
    RBRACE          reduce using rule 81 (attcond -> exp_assignment .)
    SEMICOLON       reduce using rule 81 (attcond -> exp_assignment .)
    XOR             reduce using rule 81 (attcond -> exp_assignment .)
    TIMES           reduce using rule 81 (attcond -> exp_assignment .)
    DIVIDE          reduce using rule 81 (attcond -> exp_assignment .)
    MODULO          reduce using rule 81 (attcond -> exp_assignment .)
    PLUS            reduce using rule 81 (attcond -> exp_assignment .)
    MINUS           reduce using rule 81 (attcond -> exp_assignment .)
    COMMA           reduce using rule 81 (attcond -> exp_assignment .)


state 87

    (82) attcond -> NUMBER .

    GT              reduce using rule 82 (attcond -> NUMBER .)
    LT              reduce using rule 82 (attcond -> NUMBER .)
    EQ              reduce using rule 82 (attcond -> NUMBER .)
    GE              reduce using rule 82 (attcond -> NUMBER .)
    LE              reduce using rule 82 (attcond -> NUMBER .)
    NE              reduce using rule 82 (attcond -> NUMBER .)
    CMP             reduce using rule 82 (attcond -> NUMBER .)
    SEQ             reduce using rule 82 (attcond -> NUMBER .)
    SNE             reduce using rule 82 (attcond -> NUMBER .)
    SLT             reduce using rule 82 (attcond -> NUMBER .)
    SGT             reduce using rule 82 (attcond -> NUMBER .)
    SLE             reduce using rule 82 (attcond -> NUMBER .)
    SGE             reduce using rule 82 (attcond -> NUMBER .)
    RPAREN          reduce using rule 82 (attcond -> NUMBER .)
    RETURN          reduce using rule 82 (attcond -> NUMBER .)
    BREAK           reduce using rule 82 (attcond -> NUMBER .)
    CONTINUE        reduce using rule 82 (attcond -> NUMBER .)
    IF              reduce using rule 82 (attcond -> NUMBER .)
    ID_SC           reduce using rule 82 (attcond -> NUMBER .)
    ID_LI           reduce using rule 82 (attcond -> NUMBER .)
    INCREMENT       reduce using rule 82 (attcond -> NUMBER .)
    DECREMENT       reduce using rule 82 (attcond -> NUMBER .)
    ID              reduce using rule 82 (attcond -> NUMBER .)
    FOR             reduce using rule 82 (attcond -> NUMBER .)
    DO              reduce using rule 82 (attcond -> NUMBER .)
    WHILE           reduce using rule 82 (attcond -> NUMBER .)
    SUB             reduce using rule 82 (attcond -> NUMBER .)
    $end            reduce using rule 82 (attcond -> NUMBER .)
    RBRACE          reduce using rule 82 (attcond -> NUMBER .)
    SEMICOLON       reduce using rule 82 (attcond -> NUMBER .)
    XOR             reduce using rule 82 (attcond -> NUMBER .)
    TIMES           reduce using rule 82 (attcond -> NUMBER .)
    DIVIDE          reduce using rule 82 (attcond -> NUMBER .)
    MODULO          reduce using rule 82 (attcond -> NUMBER .)
    PLUS            reduce using rule 82 (attcond -> NUMBER .)
    MINUS           reduce using rule 82 (attcond -> NUMBER .)
    COMMA           reduce using rule 82 (attcond -> NUMBER .)


state 88

    (83) attcond -> TRUE .

    GT              reduce using rule 83 (attcond -> TRUE .)
    LT              reduce using rule 83 (attcond -> TRUE .)
    EQ              reduce using rule 83 (attcond -> TRUE .)
    GE              reduce using rule 83 (attcond -> TRUE .)
    LE              reduce using rule 83 (attcond -> TRUE .)
    NE              reduce using rule 83 (attcond -> TRUE .)
    CMP             reduce using rule 83 (attcond -> TRUE .)
    SEQ             reduce using rule 83 (attcond -> TRUE .)
    SNE             reduce using rule 83 (attcond -> TRUE .)
    SLT             reduce using rule 83 (attcond -> TRUE .)
    SGT             reduce using rule 83 (attcond -> TRUE .)
    SLE             reduce using rule 83 (attcond -> TRUE .)
    SGE             reduce using rule 83 (attcond -> TRUE .)
    RPAREN          reduce using rule 83 (attcond -> TRUE .)
    RETURN          reduce using rule 83 (attcond -> TRUE .)
    BREAK           reduce using rule 83 (attcond -> TRUE .)
    CONTINUE        reduce using rule 83 (attcond -> TRUE .)
    IF              reduce using rule 83 (attcond -> TRUE .)
    ID_SC           reduce using rule 83 (attcond -> TRUE .)
    ID_LI           reduce using rule 83 (attcond -> TRUE .)
    INCREMENT       reduce using rule 83 (attcond -> TRUE .)
    DECREMENT       reduce using rule 83 (attcond -> TRUE .)
    ID              reduce using rule 83 (attcond -> TRUE .)
    FOR             reduce using rule 83 (attcond -> TRUE .)
    DO              reduce using rule 83 (attcond -> TRUE .)
    WHILE           reduce using rule 83 (attcond -> TRUE .)
    SUB             reduce using rule 83 (attcond -> TRUE .)
    $end            reduce using rule 83 (attcond -> TRUE .)
    RBRACE          reduce using rule 83 (attcond -> TRUE .)
    SEMICOLON       reduce using rule 83 (attcond -> TRUE .)
    XOR             reduce using rule 83 (attcond -> TRUE .)
    TIMES           reduce using rule 83 (attcond -> TRUE .)
    DIVIDE          reduce using rule 83 (attcond -> TRUE .)
    MODULO          reduce using rule 83 (attcond -> TRUE .)
    PLUS            reduce using rule 83 (attcond -> TRUE .)
    MINUS           reduce using rule 83 (attcond -> TRUE .)
    COMMA           reduce using rule 83 (attcond -> TRUE .)


state 89

    (84) attcond -> FALSE .

    GT              reduce using rule 84 (attcond -> FALSE .)
    LT              reduce using rule 84 (attcond -> FALSE .)
    EQ              reduce using rule 84 (attcond -> FALSE .)
    GE              reduce using rule 84 (attcond -> FALSE .)
    LE              reduce using rule 84 (attcond -> FALSE .)
    NE              reduce using rule 84 (attcond -> FALSE .)
    CMP             reduce using rule 84 (attcond -> FALSE .)
    SEQ             reduce using rule 84 (attcond -> FALSE .)
    SNE             reduce using rule 84 (attcond -> FALSE .)
    SLT             reduce using rule 84 (attcond -> FALSE .)
    SGT             reduce using rule 84 (attcond -> FALSE .)
    SLE             reduce using rule 84 (attcond -> FALSE .)
    SGE             reduce using rule 84 (attcond -> FALSE .)
    RPAREN          reduce using rule 84 (attcond -> FALSE .)
    RETURN          reduce using rule 84 (attcond -> FALSE .)
    BREAK           reduce using rule 84 (attcond -> FALSE .)
    CONTINUE        reduce using rule 84 (attcond -> FALSE .)
    IF              reduce using rule 84 (attcond -> FALSE .)
    ID_SC           reduce using rule 84 (attcond -> FALSE .)
    ID_LI           reduce using rule 84 (attcond -> FALSE .)
    INCREMENT       reduce using rule 84 (attcond -> FALSE .)
    DECREMENT       reduce using rule 84 (attcond -> FALSE .)
    ID              reduce using rule 84 (attcond -> FALSE .)
    FOR             reduce using rule 84 (attcond -> FALSE .)
    DO              reduce using rule 84 (attcond -> FALSE .)
    WHILE           reduce using rule 84 (attcond -> FALSE .)
    SUB             reduce using rule 84 (attcond -> FALSE .)
    $end            reduce using rule 84 (attcond -> FALSE .)
    RBRACE          reduce using rule 84 (attcond -> FALSE .)
    SEMICOLON       reduce using rule 84 (attcond -> FALSE .)
    XOR             reduce using rule 84 (attcond -> FALSE .)
    TIMES           reduce using rule 84 (attcond -> FALSE .)
    DIVIDE          reduce using rule 84 (attcond -> FALSE .)
    MODULO          reduce using rule 84 (attcond -> FALSE .)
    PLUS            reduce using rule 84 (attcond -> FALSE .)
    MINUS           reduce using rule 84 (attcond -> FALSE .)
    COMMA           reduce using rule 84 (attcond -> FALSE .)


state 90

    (55) exp_assignment -> ID_SC EQUALS arithmetic .

    RETURN          reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    BREAK           reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    CONTINUE        reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    IF              reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    ID_SC           reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    ID_LI           reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    INCREMENT       reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    DECREMENT       reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    ID              reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    FOR             reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    DO              reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    WHILE           reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    SUB             reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    $end            reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    RBRACE          reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    GT              reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    LT              reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    EQ              reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    GE              reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    LE              reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    NE              reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    CMP             reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    SEQ             reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    SNE             reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    SLT             reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    SGT             reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    SLE             reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    SGE             reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    SEMICOLON       reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    XOR             reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    TIMES           reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    DIVIDE          reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    MODULO          reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    PLUS            reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    MINUS           reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    COMMA           reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)
    RPAREN          reduce using rule 55 (exp_assignment -> ID_SC EQUALS arithmetic .)


state 91

    (74) exp3 -> NUMBER .
    (82) attcond -> NUMBER .

  ! reduce/reduce conflict for RETURN resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for BREAK resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for IF resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for ID_SC resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for ID_LI resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for INCREMENT resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for DECREMENT resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for ID resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for FOR resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for DO resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for WHILE resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for SUB resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for $end resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for RBRACE resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for GT resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for LT resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for EQ resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for GE resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for LE resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for NE resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for CMP resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for SEQ resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for SNE resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for SLT resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for SGT resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for SLE resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for SGE resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for XOR resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for TIMES resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for MODULO resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for PLUS resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for MINUS resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for COMMA resolved using rule 74 (exp3 -> NUMBER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 74 (exp3 -> NUMBER .)
    RETURN          reduce using rule 74 (exp3 -> NUMBER .)
    BREAK           reduce using rule 74 (exp3 -> NUMBER .)
    CONTINUE        reduce using rule 74 (exp3 -> NUMBER .)
    IF              reduce using rule 74 (exp3 -> NUMBER .)
    ID_SC           reduce using rule 74 (exp3 -> NUMBER .)
    ID_LI           reduce using rule 74 (exp3 -> NUMBER .)
    INCREMENT       reduce using rule 74 (exp3 -> NUMBER .)
    DECREMENT       reduce using rule 74 (exp3 -> NUMBER .)
    ID              reduce using rule 74 (exp3 -> NUMBER .)
    FOR             reduce using rule 74 (exp3 -> NUMBER .)
    DO              reduce using rule 74 (exp3 -> NUMBER .)
    WHILE           reduce using rule 74 (exp3 -> NUMBER .)
    SUB             reduce using rule 74 (exp3 -> NUMBER .)
    $end            reduce using rule 74 (exp3 -> NUMBER .)
    RBRACE          reduce using rule 74 (exp3 -> NUMBER .)
    GT              reduce using rule 74 (exp3 -> NUMBER .)
    LT              reduce using rule 74 (exp3 -> NUMBER .)
    EQ              reduce using rule 74 (exp3 -> NUMBER .)
    GE              reduce using rule 74 (exp3 -> NUMBER .)
    LE              reduce using rule 74 (exp3 -> NUMBER .)
    NE              reduce using rule 74 (exp3 -> NUMBER .)
    CMP             reduce using rule 74 (exp3 -> NUMBER .)
    SEQ             reduce using rule 74 (exp3 -> NUMBER .)
    SNE             reduce using rule 74 (exp3 -> NUMBER .)
    SLT             reduce using rule 74 (exp3 -> NUMBER .)
    SGT             reduce using rule 74 (exp3 -> NUMBER .)
    SLE             reduce using rule 74 (exp3 -> NUMBER .)
    SGE             reduce using rule 74 (exp3 -> NUMBER .)
    SEMICOLON       reduce using rule 74 (exp3 -> NUMBER .)
    XOR             reduce using rule 74 (exp3 -> NUMBER .)
    TIMES           reduce using rule 74 (exp3 -> NUMBER .)
    DIVIDE          reduce using rule 74 (exp3 -> NUMBER .)
    MODULO          reduce using rule 74 (exp3 -> NUMBER .)
    PLUS            reduce using rule 74 (exp3 -> NUMBER .)
    MINUS           reduce using rule 74 (exp3 -> NUMBER .)
    COMMA           reduce using rule 74 (exp3 -> NUMBER .)
    RPAREN          reduce using rule 74 (exp3 -> NUMBER .)

  ! RETURN          [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! BREAK           [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! CONTINUE        [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! IF              [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! ID_SC           [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! ID_LI           [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! INCREMENT       [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! DECREMENT       [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! ID              [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! FOR             [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! DO              [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! WHILE           [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! SUB             [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! $end            [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! RBRACE          [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! GT              [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! LT              [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! EQ              [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! GE              [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! LE              [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! NE              [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! CMP             [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! SEQ             [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! SNE             [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! SLT             [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! SGT             [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! SLE             [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! SGE             [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! SEMICOLON       [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! XOR             [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! TIMES           [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! DIVIDE          [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! MODULO          [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! PLUS            [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! MINUS           [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! COMMA           [ reduce using rule 82 (attcond -> NUMBER .) ]
  ! RPAREN          [ reduce using rule 82 (attcond -> NUMBER .) ]


state 92

    (75) exp3 -> exp_assignment .
    (81) attcond -> exp_assignment .

  ! reduce/reduce conflict for RETURN resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for BREAK resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for IF resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for ID_SC resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for ID_LI resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for INCREMENT resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for DECREMENT resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for ID resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for FOR resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for DO resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for WHILE resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for SUB resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for $end resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for RBRACE resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for GT resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for LT resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for EQ resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for GE resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for LE resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for NE resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for CMP resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for SEQ resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for SNE resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for SLT resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for SGT resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for SLE resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for SGE resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for XOR resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for TIMES resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for MODULO resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for PLUS resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for MINUS resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for COMMA resolved using rule 75 (exp3 -> exp_assignment .)
  ! reduce/reduce conflict for RPAREN resolved using rule 75 (exp3 -> exp_assignment .)
    RETURN          reduce using rule 75 (exp3 -> exp_assignment .)
    BREAK           reduce using rule 75 (exp3 -> exp_assignment .)
    CONTINUE        reduce using rule 75 (exp3 -> exp_assignment .)
    IF              reduce using rule 75 (exp3 -> exp_assignment .)
    ID_SC           reduce using rule 75 (exp3 -> exp_assignment .)
    ID_LI           reduce using rule 75 (exp3 -> exp_assignment .)
    INCREMENT       reduce using rule 75 (exp3 -> exp_assignment .)
    DECREMENT       reduce using rule 75 (exp3 -> exp_assignment .)
    ID              reduce using rule 75 (exp3 -> exp_assignment .)
    FOR             reduce using rule 75 (exp3 -> exp_assignment .)
    DO              reduce using rule 75 (exp3 -> exp_assignment .)
    WHILE           reduce using rule 75 (exp3 -> exp_assignment .)
    SUB             reduce using rule 75 (exp3 -> exp_assignment .)
    $end            reduce using rule 75 (exp3 -> exp_assignment .)
    RBRACE          reduce using rule 75 (exp3 -> exp_assignment .)
    GT              reduce using rule 75 (exp3 -> exp_assignment .)
    LT              reduce using rule 75 (exp3 -> exp_assignment .)
    EQ              reduce using rule 75 (exp3 -> exp_assignment .)
    GE              reduce using rule 75 (exp3 -> exp_assignment .)
    LE              reduce using rule 75 (exp3 -> exp_assignment .)
    NE              reduce using rule 75 (exp3 -> exp_assignment .)
    CMP             reduce using rule 75 (exp3 -> exp_assignment .)
    SEQ             reduce using rule 75 (exp3 -> exp_assignment .)
    SNE             reduce using rule 75 (exp3 -> exp_assignment .)
    SLT             reduce using rule 75 (exp3 -> exp_assignment .)
    SGT             reduce using rule 75 (exp3 -> exp_assignment .)
    SLE             reduce using rule 75 (exp3 -> exp_assignment .)
    SGE             reduce using rule 75 (exp3 -> exp_assignment .)
    SEMICOLON       reduce using rule 75 (exp3 -> exp_assignment .)
    XOR             reduce using rule 75 (exp3 -> exp_assignment .)
    TIMES           reduce using rule 75 (exp3 -> exp_assignment .)
    DIVIDE          reduce using rule 75 (exp3 -> exp_assignment .)
    MODULO          reduce using rule 75 (exp3 -> exp_assignment .)
    PLUS            reduce using rule 75 (exp3 -> exp_assignment .)
    MINUS           reduce using rule 75 (exp3 -> exp_assignment .)
    COMMA           reduce using rule 75 (exp3 -> exp_assignment .)
    RPAREN          reduce using rule 75 (exp3 -> exp_assignment .)

  ! RETURN          [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! BREAK           [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! CONTINUE        [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! IF              [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! ID_SC           [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! ID_LI           [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! INCREMENT       [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! DECREMENT       [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! ID              [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! FOR             [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! DO              [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! WHILE           [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! SUB             [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! $end            [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! RBRACE          [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! GT              [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! LT              [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! EQ              [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! GE              [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! LE              [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! NE              [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! CMP             [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! SEQ             [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! SNE             [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! SLT             [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! SGT             [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! SLE             [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! SGE             [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! SEMICOLON       [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! XOR             [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! TIMES           [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! DIVIDE          [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! MODULO          [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! PLUS            [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! MINUS           [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! COMMA           [ reduce using rule 81 (attcond -> exp_assignment .) ]
  ! RPAREN          [ reduce using rule 81 (attcond -> exp_assignment .) ]


state 93

    (79) exp3 -> TRUE .
    (83) attcond -> TRUE .

  ! reduce/reduce conflict for RETURN resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for BREAK resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for IF resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for ID_SC resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for ID_LI resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for INCREMENT resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for DECREMENT resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for ID resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for FOR resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for DO resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for WHILE resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for SUB resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for $end resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for RBRACE resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for GT resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for LT resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for EQ resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for GE resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for LE resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for NE resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for CMP resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for SEQ resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for SNE resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for SLT resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for SGT resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for SLE resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for SGE resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for XOR resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for TIMES resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for MODULO resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for PLUS resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for MINUS resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for COMMA resolved using rule 79 (exp3 -> TRUE .)
  ! reduce/reduce conflict for RPAREN resolved using rule 79 (exp3 -> TRUE .)
    RETURN          reduce using rule 79 (exp3 -> TRUE .)
    BREAK           reduce using rule 79 (exp3 -> TRUE .)
    CONTINUE        reduce using rule 79 (exp3 -> TRUE .)
    IF              reduce using rule 79 (exp3 -> TRUE .)
    ID_SC           reduce using rule 79 (exp3 -> TRUE .)
    ID_LI           reduce using rule 79 (exp3 -> TRUE .)
    INCREMENT       reduce using rule 79 (exp3 -> TRUE .)
    DECREMENT       reduce using rule 79 (exp3 -> TRUE .)
    ID              reduce using rule 79 (exp3 -> TRUE .)
    FOR             reduce using rule 79 (exp3 -> TRUE .)
    DO              reduce using rule 79 (exp3 -> TRUE .)
    WHILE           reduce using rule 79 (exp3 -> TRUE .)
    SUB             reduce using rule 79 (exp3 -> TRUE .)
    $end            reduce using rule 79 (exp3 -> TRUE .)
    RBRACE          reduce using rule 79 (exp3 -> TRUE .)
    GT              reduce using rule 79 (exp3 -> TRUE .)
    LT              reduce using rule 79 (exp3 -> TRUE .)
    EQ              reduce using rule 79 (exp3 -> TRUE .)
    GE              reduce using rule 79 (exp3 -> TRUE .)
    LE              reduce using rule 79 (exp3 -> TRUE .)
    NE              reduce using rule 79 (exp3 -> TRUE .)
    CMP             reduce using rule 79 (exp3 -> TRUE .)
    SEQ             reduce using rule 79 (exp3 -> TRUE .)
    SNE             reduce using rule 79 (exp3 -> TRUE .)
    SLT             reduce using rule 79 (exp3 -> TRUE .)
    SGT             reduce using rule 79 (exp3 -> TRUE .)
    SLE             reduce using rule 79 (exp3 -> TRUE .)
    SGE             reduce using rule 79 (exp3 -> TRUE .)
    SEMICOLON       reduce using rule 79 (exp3 -> TRUE .)
    XOR             reduce using rule 79 (exp3 -> TRUE .)
    TIMES           reduce using rule 79 (exp3 -> TRUE .)
    DIVIDE          reduce using rule 79 (exp3 -> TRUE .)
    MODULO          reduce using rule 79 (exp3 -> TRUE .)
    PLUS            reduce using rule 79 (exp3 -> TRUE .)
    MINUS           reduce using rule 79 (exp3 -> TRUE .)
    COMMA           reduce using rule 79 (exp3 -> TRUE .)
    RPAREN          reduce using rule 79 (exp3 -> TRUE .)

  ! RETURN          [ reduce using rule 83 (attcond -> TRUE .) ]
  ! BREAK           [ reduce using rule 83 (attcond -> TRUE .) ]
  ! CONTINUE        [ reduce using rule 83 (attcond -> TRUE .) ]
  ! IF              [ reduce using rule 83 (attcond -> TRUE .) ]
  ! ID_SC           [ reduce using rule 83 (attcond -> TRUE .) ]
  ! ID_LI           [ reduce using rule 83 (attcond -> TRUE .) ]
  ! INCREMENT       [ reduce using rule 83 (attcond -> TRUE .) ]
  ! DECREMENT       [ reduce using rule 83 (attcond -> TRUE .) ]
  ! ID              [ reduce using rule 83 (attcond -> TRUE .) ]
  ! FOR             [ reduce using rule 83 (attcond -> TRUE .) ]
  ! DO              [ reduce using rule 83 (attcond -> TRUE .) ]
  ! WHILE           [ reduce using rule 83 (attcond -> TRUE .) ]
  ! SUB             [ reduce using rule 83 (attcond -> TRUE .) ]
  ! $end            [ reduce using rule 83 (attcond -> TRUE .) ]
  ! RBRACE          [ reduce using rule 83 (attcond -> TRUE .) ]
  ! GT              [ reduce using rule 83 (attcond -> TRUE .) ]
  ! LT              [ reduce using rule 83 (attcond -> TRUE .) ]
  ! EQ              [ reduce using rule 83 (attcond -> TRUE .) ]
  ! GE              [ reduce using rule 83 (attcond -> TRUE .) ]
  ! LE              [ reduce using rule 83 (attcond -> TRUE .) ]
  ! NE              [ reduce using rule 83 (attcond -> TRUE .) ]
  ! CMP             [ reduce using rule 83 (attcond -> TRUE .) ]
  ! SEQ             [ reduce using rule 83 (attcond -> TRUE .) ]
  ! SNE             [ reduce using rule 83 (attcond -> TRUE .) ]
  ! SLT             [ reduce using rule 83 (attcond -> TRUE .) ]
  ! SGT             [ reduce using rule 83 (attcond -> TRUE .) ]
  ! SLE             [ reduce using rule 83 (attcond -> TRUE .) ]
  ! SGE             [ reduce using rule 83 (attcond -> TRUE .) ]
  ! SEMICOLON       [ reduce using rule 83 (attcond -> TRUE .) ]
  ! XOR             [ reduce using rule 83 (attcond -> TRUE .) ]
  ! TIMES           [ reduce using rule 83 (attcond -> TRUE .) ]
  ! DIVIDE          [ reduce using rule 83 (attcond -> TRUE .) ]
  ! MODULO          [ reduce using rule 83 (attcond -> TRUE .) ]
  ! PLUS            [ reduce using rule 83 (attcond -> TRUE .) ]
  ! MINUS           [ reduce using rule 83 (attcond -> TRUE .) ]
  ! COMMA           [ reduce using rule 83 (attcond -> TRUE .) ]
  ! RPAREN          [ reduce using rule 83 (attcond -> TRUE .) ]


state 94

    (80) exp3 -> FALSE .
    (84) attcond -> FALSE .

  ! reduce/reduce conflict for RETURN resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for BREAK resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for IF resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for ID_SC resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for ID_LI resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for INCREMENT resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for DECREMENT resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for ID resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for FOR resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for DO resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for WHILE resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for SUB resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for $end resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for RBRACE resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for GT resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for LT resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for EQ resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for GE resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for LE resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for NE resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for CMP resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for SEQ resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for SNE resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for SLT resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for SGT resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for SLE resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for SGE resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for XOR resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for TIMES resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for MODULO resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for PLUS resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for MINUS resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for COMMA resolved using rule 80 (exp3 -> FALSE .)
  ! reduce/reduce conflict for RPAREN resolved using rule 80 (exp3 -> FALSE .)
    RETURN          reduce using rule 80 (exp3 -> FALSE .)
    BREAK           reduce using rule 80 (exp3 -> FALSE .)
    CONTINUE        reduce using rule 80 (exp3 -> FALSE .)
    IF              reduce using rule 80 (exp3 -> FALSE .)
    ID_SC           reduce using rule 80 (exp3 -> FALSE .)
    ID_LI           reduce using rule 80 (exp3 -> FALSE .)
    INCREMENT       reduce using rule 80 (exp3 -> FALSE .)
    DECREMENT       reduce using rule 80 (exp3 -> FALSE .)
    ID              reduce using rule 80 (exp3 -> FALSE .)
    FOR             reduce using rule 80 (exp3 -> FALSE .)
    DO              reduce using rule 80 (exp3 -> FALSE .)
    WHILE           reduce using rule 80 (exp3 -> FALSE .)
    SUB             reduce using rule 80 (exp3 -> FALSE .)
    $end            reduce using rule 80 (exp3 -> FALSE .)
    RBRACE          reduce using rule 80 (exp3 -> FALSE .)
    GT              reduce using rule 80 (exp3 -> FALSE .)
    LT              reduce using rule 80 (exp3 -> FALSE .)
    EQ              reduce using rule 80 (exp3 -> FALSE .)
    GE              reduce using rule 80 (exp3 -> FALSE .)
    LE              reduce using rule 80 (exp3 -> FALSE .)
    NE              reduce using rule 80 (exp3 -> FALSE .)
    CMP             reduce using rule 80 (exp3 -> FALSE .)
    SEQ             reduce using rule 80 (exp3 -> FALSE .)
    SNE             reduce using rule 80 (exp3 -> FALSE .)
    SLT             reduce using rule 80 (exp3 -> FALSE .)
    SGT             reduce using rule 80 (exp3 -> FALSE .)
    SLE             reduce using rule 80 (exp3 -> FALSE .)
    SGE             reduce using rule 80 (exp3 -> FALSE .)
    SEMICOLON       reduce using rule 80 (exp3 -> FALSE .)
    XOR             reduce using rule 80 (exp3 -> FALSE .)
    TIMES           reduce using rule 80 (exp3 -> FALSE .)
    DIVIDE          reduce using rule 80 (exp3 -> FALSE .)
    MODULO          reduce using rule 80 (exp3 -> FALSE .)
    PLUS            reduce using rule 80 (exp3 -> FALSE .)
    MINUS           reduce using rule 80 (exp3 -> FALSE .)
    COMMA           reduce using rule 80 (exp3 -> FALSE .)
    RPAREN          reduce using rule 80 (exp3 -> FALSE .)

  ! RETURN          [ reduce using rule 84 (attcond -> FALSE .) ]
  ! BREAK           [ reduce using rule 84 (attcond -> FALSE .) ]
  ! CONTINUE        [ reduce using rule 84 (attcond -> FALSE .) ]
  ! IF              [ reduce using rule 84 (attcond -> FALSE .) ]
  ! ID_SC           [ reduce using rule 84 (attcond -> FALSE .) ]
  ! ID_LI           [ reduce using rule 84 (attcond -> FALSE .) ]
  ! INCREMENT       [ reduce using rule 84 (attcond -> FALSE .) ]
  ! DECREMENT       [ reduce using rule 84 (attcond -> FALSE .) ]
  ! ID              [ reduce using rule 84 (attcond -> FALSE .) ]
  ! FOR             [ reduce using rule 84 (attcond -> FALSE .) ]
  ! DO              [ reduce using rule 84 (attcond -> FALSE .) ]
  ! WHILE           [ reduce using rule 84 (attcond -> FALSE .) ]
  ! SUB             [ reduce using rule 84 (attcond -> FALSE .) ]
  ! $end            [ reduce using rule 84 (attcond -> FALSE .) ]
  ! RBRACE          [ reduce using rule 84 (attcond -> FALSE .) ]
  ! GT              [ reduce using rule 84 (attcond -> FALSE .) ]
  ! LT              [ reduce using rule 84 (attcond -> FALSE .) ]
  ! EQ              [ reduce using rule 84 (attcond -> FALSE .) ]
  ! GE              [ reduce using rule 84 (attcond -> FALSE .) ]
  ! LE              [ reduce using rule 84 (attcond -> FALSE .) ]
  ! NE              [ reduce using rule 84 (attcond -> FALSE .) ]
  ! CMP             [ reduce using rule 84 (attcond -> FALSE .) ]
  ! SEQ             [ reduce using rule 84 (attcond -> FALSE .) ]
  ! SNE             [ reduce using rule 84 (attcond -> FALSE .) ]
  ! SLT             [ reduce using rule 84 (attcond -> FALSE .) ]
  ! SGT             [ reduce using rule 84 (attcond -> FALSE .) ]
  ! SLE             [ reduce using rule 84 (attcond -> FALSE .) ]
  ! SGE             [ reduce using rule 84 (attcond -> FALSE .) ]
  ! SEMICOLON       [ reduce using rule 84 (attcond -> FALSE .) ]
  ! XOR             [ reduce using rule 84 (attcond -> FALSE .) ]
  ! TIMES           [ reduce using rule 84 (attcond -> FALSE .) ]
  ! DIVIDE          [ reduce using rule 84 (attcond -> FALSE .) ]
  ! MODULO          [ reduce using rule 84 (attcond -> FALSE .) ]
  ! PLUS            [ reduce using rule 84 (attcond -> FALSE .) ]
  ! MINUS           [ reduce using rule 84 (attcond -> FALSE .) ]
  ! COMMA           [ reduce using rule 84 (attcond -> FALSE .) ]
  ! RPAREN          [ reduce using rule 84 (attcond -> FALSE .) ]


state 95

    (56) exp_assignment -> ID_LI EQUALS arithmetic .

    RETURN          reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    BREAK           reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    CONTINUE        reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    IF              reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    ID_SC           reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    ID_LI           reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    INCREMENT       reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    DECREMENT       reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    ID              reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    FOR             reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    DO              reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    WHILE           reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    SUB             reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    $end            reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    RBRACE          reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    GT              reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    LT              reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    EQ              reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    GE              reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    LE              reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    NE              reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    CMP             reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    SEQ             reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    SNE             reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    SLT             reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    SGT             reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    SLE             reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    SGE             reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    SEMICOLON       reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    XOR             reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    TIMES           reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    DIVIDE          reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    MODULO          reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    PLUS            reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    MINUS           reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    COMMA           reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)
    RPAREN          reduce using rule 56 (exp_assignment -> ID_LI EQUALS arithmetic .)


state 96

    (25) for -> FOR LPAREN for_assignments . SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE

    SEMICOLON       shift and go to state 128


state 97

    (26) for_assignments -> exp_assignment .
    (27) for_assignments -> exp_assignment . COMMA for_assignments

    SEMICOLON       reduce using rule 26 (for_assignments -> exp_assignment .)
    RPAREN          reduce using rule 26 (for_assignments -> exp_assignment .)
    COMMA           shift and go to state 129


state 98

    (28) dowhile -> DO LBRACE blockcode . RBRACE WHILE LPAREN exp_condition RPAREN

    RBRACE          shift and go to state 130


state 99

    (29) while -> WHILE LPAREN exp_condition . RPAREN LBRACE blockcode RBRACE
    (30) while -> WHILE LPAREN exp_condition . RPAREN LBRACE RBRACE

    RPAREN          shift and go to state 131


state 100

    (31) function -> SUB ID LPAREN RPAREN . LBRACE blockcode RBRACE

    LBRACE          shift and go to state 132


state 101

    (32) function -> SUB ID LPAREN function_assignments . RPAREN LBRACE blockcode RBRACE

    RPAREN          shift and go to state 133


state 102

    (86) call -> ID LPAREN function_assignments RPAREN .

    RETURN          reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    BREAK           reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    CONTINUE        reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    IF              reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    ID_SC           reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    ID_LI           reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    INCREMENT       reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    DECREMENT       reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    ID              reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    FOR             reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    DO              reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    WHILE           reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    SUB             reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    $end            reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    RBRACE          reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    XOR             reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    TIMES           reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    DIVIDE          reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    MODULO          reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    PLUS            reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    MINUS           reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    SEMICOLON       reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    RPAREN          reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    GT              reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    LT              reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    EQ              reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    GE              reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    LE              reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    NE              reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    CMP             reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    SEQ             reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    SNE             reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    SLT             reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    SGT             reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    SLE             reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    SGE             reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)
    COMMA           reduce using rule 86 (call -> ID LPAREN function_assignments RPAREN .)


state 103

    (34) function_assignments -> exp_assignment COMMA . function_assignments
    (33) function_assignments -> . exp_assignment
    (34) function_assignments -> . exp_assignment COMMA function_assignments
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    exp_assignment                 shift and go to state 59
    function_assignments           shift and go to state 134

state 104

    (35) exp_condition -> attcond GT attcond .

    XOR             reduce using rule 35 (exp_condition -> attcond GT attcond .)
    TIMES           reduce using rule 35 (exp_condition -> attcond GT attcond .)
    DIVIDE          reduce using rule 35 (exp_condition -> attcond GT attcond .)
    MODULO          reduce using rule 35 (exp_condition -> attcond GT attcond .)
    PLUS            reduce using rule 35 (exp_condition -> attcond GT attcond .)
    MINUS           reduce using rule 35 (exp_condition -> attcond GT attcond .)
    SEMICOLON       reduce using rule 35 (exp_condition -> attcond GT attcond .)
    RPAREN          reduce using rule 35 (exp_condition -> attcond GT attcond .)
    RETURN          reduce using rule 35 (exp_condition -> attcond GT attcond .)
    BREAK           reduce using rule 35 (exp_condition -> attcond GT attcond .)
    CONTINUE        reduce using rule 35 (exp_condition -> attcond GT attcond .)
    IF              reduce using rule 35 (exp_condition -> attcond GT attcond .)
    ID_SC           reduce using rule 35 (exp_condition -> attcond GT attcond .)
    ID_LI           reduce using rule 35 (exp_condition -> attcond GT attcond .)
    INCREMENT       reduce using rule 35 (exp_condition -> attcond GT attcond .)
    DECREMENT       reduce using rule 35 (exp_condition -> attcond GT attcond .)
    ID              reduce using rule 35 (exp_condition -> attcond GT attcond .)
    FOR             reduce using rule 35 (exp_condition -> attcond GT attcond .)
    DO              reduce using rule 35 (exp_condition -> attcond GT attcond .)
    WHILE           reduce using rule 35 (exp_condition -> attcond GT attcond .)
    SUB             reduce using rule 35 (exp_condition -> attcond GT attcond .)
    $end            reduce using rule 35 (exp_condition -> attcond GT attcond .)
    RBRACE          reduce using rule 35 (exp_condition -> attcond GT attcond .)
    GT              reduce using rule 35 (exp_condition -> attcond GT attcond .)
    LT              reduce using rule 35 (exp_condition -> attcond GT attcond .)
    EQ              reduce using rule 35 (exp_condition -> attcond GT attcond .)
    GE              reduce using rule 35 (exp_condition -> attcond GT attcond .)
    LE              reduce using rule 35 (exp_condition -> attcond GT attcond .)
    NE              reduce using rule 35 (exp_condition -> attcond GT attcond .)
    CMP             reduce using rule 35 (exp_condition -> attcond GT attcond .)
    SEQ             reduce using rule 35 (exp_condition -> attcond GT attcond .)
    SNE             reduce using rule 35 (exp_condition -> attcond GT attcond .)
    SLT             reduce using rule 35 (exp_condition -> attcond GT attcond .)
    SGT             reduce using rule 35 (exp_condition -> attcond GT attcond .)
    SLE             reduce using rule 35 (exp_condition -> attcond GT attcond .)
    SGE             reduce using rule 35 (exp_condition -> attcond GT attcond .)
    COMMA           reduce using rule 35 (exp_condition -> attcond GT attcond .)


state 105

    (36) exp_condition -> attcond LT attcond .

    XOR             reduce using rule 36 (exp_condition -> attcond LT attcond .)
    TIMES           reduce using rule 36 (exp_condition -> attcond LT attcond .)
    DIVIDE          reduce using rule 36 (exp_condition -> attcond LT attcond .)
    MODULO          reduce using rule 36 (exp_condition -> attcond LT attcond .)
    PLUS            reduce using rule 36 (exp_condition -> attcond LT attcond .)
    MINUS           reduce using rule 36 (exp_condition -> attcond LT attcond .)
    SEMICOLON       reduce using rule 36 (exp_condition -> attcond LT attcond .)
    RPAREN          reduce using rule 36 (exp_condition -> attcond LT attcond .)
    RETURN          reduce using rule 36 (exp_condition -> attcond LT attcond .)
    BREAK           reduce using rule 36 (exp_condition -> attcond LT attcond .)
    CONTINUE        reduce using rule 36 (exp_condition -> attcond LT attcond .)
    IF              reduce using rule 36 (exp_condition -> attcond LT attcond .)
    ID_SC           reduce using rule 36 (exp_condition -> attcond LT attcond .)
    ID_LI           reduce using rule 36 (exp_condition -> attcond LT attcond .)
    INCREMENT       reduce using rule 36 (exp_condition -> attcond LT attcond .)
    DECREMENT       reduce using rule 36 (exp_condition -> attcond LT attcond .)
    ID              reduce using rule 36 (exp_condition -> attcond LT attcond .)
    FOR             reduce using rule 36 (exp_condition -> attcond LT attcond .)
    DO              reduce using rule 36 (exp_condition -> attcond LT attcond .)
    WHILE           reduce using rule 36 (exp_condition -> attcond LT attcond .)
    SUB             reduce using rule 36 (exp_condition -> attcond LT attcond .)
    $end            reduce using rule 36 (exp_condition -> attcond LT attcond .)
    RBRACE          reduce using rule 36 (exp_condition -> attcond LT attcond .)
    GT              reduce using rule 36 (exp_condition -> attcond LT attcond .)
    LT              reduce using rule 36 (exp_condition -> attcond LT attcond .)
    EQ              reduce using rule 36 (exp_condition -> attcond LT attcond .)
    GE              reduce using rule 36 (exp_condition -> attcond LT attcond .)
    LE              reduce using rule 36 (exp_condition -> attcond LT attcond .)
    NE              reduce using rule 36 (exp_condition -> attcond LT attcond .)
    CMP             reduce using rule 36 (exp_condition -> attcond LT attcond .)
    SEQ             reduce using rule 36 (exp_condition -> attcond LT attcond .)
    SNE             reduce using rule 36 (exp_condition -> attcond LT attcond .)
    SLT             reduce using rule 36 (exp_condition -> attcond LT attcond .)
    SGT             reduce using rule 36 (exp_condition -> attcond LT attcond .)
    SLE             reduce using rule 36 (exp_condition -> attcond LT attcond .)
    SGE             reduce using rule 36 (exp_condition -> attcond LT attcond .)
    COMMA           reduce using rule 36 (exp_condition -> attcond LT attcond .)


state 106

    (37) exp_condition -> attcond EQ attcond .

    XOR             reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    TIMES           reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    DIVIDE          reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    MODULO          reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    PLUS            reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    MINUS           reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    SEMICOLON       reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    RPAREN          reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    RETURN          reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    BREAK           reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    CONTINUE        reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    IF              reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    ID_SC           reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    ID_LI           reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    INCREMENT       reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    DECREMENT       reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    ID              reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    FOR             reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    DO              reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    WHILE           reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    SUB             reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    $end            reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    RBRACE          reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    GT              reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    LT              reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    EQ              reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    GE              reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    LE              reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    NE              reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    CMP             reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    SEQ             reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    SNE             reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    SLT             reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    SGT             reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    SLE             reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    SGE             reduce using rule 37 (exp_condition -> attcond EQ attcond .)
    COMMA           reduce using rule 37 (exp_condition -> attcond EQ attcond .)


state 107

    (38) exp_condition -> attcond GE attcond .

    XOR             reduce using rule 38 (exp_condition -> attcond GE attcond .)
    TIMES           reduce using rule 38 (exp_condition -> attcond GE attcond .)
    DIVIDE          reduce using rule 38 (exp_condition -> attcond GE attcond .)
    MODULO          reduce using rule 38 (exp_condition -> attcond GE attcond .)
    PLUS            reduce using rule 38 (exp_condition -> attcond GE attcond .)
    MINUS           reduce using rule 38 (exp_condition -> attcond GE attcond .)
    SEMICOLON       reduce using rule 38 (exp_condition -> attcond GE attcond .)
    RPAREN          reduce using rule 38 (exp_condition -> attcond GE attcond .)
    RETURN          reduce using rule 38 (exp_condition -> attcond GE attcond .)
    BREAK           reduce using rule 38 (exp_condition -> attcond GE attcond .)
    CONTINUE        reduce using rule 38 (exp_condition -> attcond GE attcond .)
    IF              reduce using rule 38 (exp_condition -> attcond GE attcond .)
    ID_SC           reduce using rule 38 (exp_condition -> attcond GE attcond .)
    ID_LI           reduce using rule 38 (exp_condition -> attcond GE attcond .)
    INCREMENT       reduce using rule 38 (exp_condition -> attcond GE attcond .)
    DECREMENT       reduce using rule 38 (exp_condition -> attcond GE attcond .)
    ID              reduce using rule 38 (exp_condition -> attcond GE attcond .)
    FOR             reduce using rule 38 (exp_condition -> attcond GE attcond .)
    DO              reduce using rule 38 (exp_condition -> attcond GE attcond .)
    WHILE           reduce using rule 38 (exp_condition -> attcond GE attcond .)
    SUB             reduce using rule 38 (exp_condition -> attcond GE attcond .)
    $end            reduce using rule 38 (exp_condition -> attcond GE attcond .)
    RBRACE          reduce using rule 38 (exp_condition -> attcond GE attcond .)
    GT              reduce using rule 38 (exp_condition -> attcond GE attcond .)
    LT              reduce using rule 38 (exp_condition -> attcond GE attcond .)
    EQ              reduce using rule 38 (exp_condition -> attcond GE attcond .)
    GE              reduce using rule 38 (exp_condition -> attcond GE attcond .)
    LE              reduce using rule 38 (exp_condition -> attcond GE attcond .)
    NE              reduce using rule 38 (exp_condition -> attcond GE attcond .)
    CMP             reduce using rule 38 (exp_condition -> attcond GE attcond .)
    SEQ             reduce using rule 38 (exp_condition -> attcond GE attcond .)
    SNE             reduce using rule 38 (exp_condition -> attcond GE attcond .)
    SLT             reduce using rule 38 (exp_condition -> attcond GE attcond .)
    SGT             reduce using rule 38 (exp_condition -> attcond GE attcond .)
    SLE             reduce using rule 38 (exp_condition -> attcond GE attcond .)
    SGE             reduce using rule 38 (exp_condition -> attcond GE attcond .)
    COMMA           reduce using rule 38 (exp_condition -> attcond GE attcond .)


state 108

    (39) exp_condition -> attcond LE attcond .

    XOR             reduce using rule 39 (exp_condition -> attcond LE attcond .)
    TIMES           reduce using rule 39 (exp_condition -> attcond LE attcond .)
    DIVIDE          reduce using rule 39 (exp_condition -> attcond LE attcond .)
    MODULO          reduce using rule 39 (exp_condition -> attcond LE attcond .)
    PLUS            reduce using rule 39 (exp_condition -> attcond LE attcond .)
    MINUS           reduce using rule 39 (exp_condition -> attcond LE attcond .)
    SEMICOLON       reduce using rule 39 (exp_condition -> attcond LE attcond .)
    RPAREN          reduce using rule 39 (exp_condition -> attcond LE attcond .)
    RETURN          reduce using rule 39 (exp_condition -> attcond LE attcond .)
    BREAK           reduce using rule 39 (exp_condition -> attcond LE attcond .)
    CONTINUE        reduce using rule 39 (exp_condition -> attcond LE attcond .)
    IF              reduce using rule 39 (exp_condition -> attcond LE attcond .)
    ID_SC           reduce using rule 39 (exp_condition -> attcond LE attcond .)
    ID_LI           reduce using rule 39 (exp_condition -> attcond LE attcond .)
    INCREMENT       reduce using rule 39 (exp_condition -> attcond LE attcond .)
    DECREMENT       reduce using rule 39 (exp_condition -> attcond LE attcond .)
    ID              reduce using rule 39 (exp_condition -> attcond LE attcond .)
    FOR             reduce using rule 39 (exp_condition -> attcond LE attcond .)
    DO              reduce using rule 39 (exp_condition -> attcond LE attcond .)
    WHILE           reduce using rule 39 (exp_condition -> attcond LE attcond .)
    SUB             reduce using rule 39 (exp_condition -> attcond LE attcond .)
    $end            reduce using rule 39 (exp_condition -> attcond LE attcond .)
    RBRACE          reduce using rule 39 (exp_condition -> attcond LE attcond .)
    GT              reduce using rule 39 (exp_condition -> attcond LE attcond .)
    LT              reduce using rule 39 (exp_condition -> attcond LE attcond .)
    EQ              reduce using rule 39 (exp_condition -> attcond LE attcond .)
    GE              reduce using rule 39 (exp_condition -> attcond LE attcond .)
    LE              reduce using rule 39 (exp_condition -> attcond LE attcond .)
    NE              reduce using rule 39 (exp_condition -> attcond LE attcond .)
    CMP             reduce using rule 39 (exp_condition -> attcond LE attcond .)
    SEQ             reduce using rule 39 (exp_condition -> attcond LE attcond .)
    SNE             reduce using rule 39 (exp_condition -> attcond LE attcond .)
    SLT             reduce using rule 39 (exp_condition -> attcond LE attcond .)
    SGT             reduce using rule 39 (exp_condition -> attcond LE attcond .)
    SLE             reduce using rule 39 (exp_condition -> attcond LE attcond .)
    SGE             reduce using rule 39 (exp_condition -> attcond LE attcond .)
    COMMA           reduce using rule 39 (exp_condition -> attcond LE attcond .)


state 109

    (40) exp_condition -> attcond NE attcond .

    XOR             reduce using rule 40 (exp_condition -> attcond NE attcond .)
    TIMES           reduce using rule 40 (exp_condition -> attcond NE attcond .)
    DIVIDE          reduce using rule 40 (exp_condition -> attcond NE attcond .)
    MODULO          reduce using rule 40 (exp_condition -> attcond NE attcond .)
    PLUS            reduce using rule 40 (exp_condition -> attcond NE attcond .)
    MINUS           reduce using rule 40 (exp_condition -> attcond NE attcond .)
    SEMICOLON       reduce using rule 40 (exp_condition -> attcond NE attcond .)
    RPAREN          reduce using rule 40 (exp_condition -> attcond NE attcond .)
    RETURN          reduce using rule 40 (exp_condition -> attcond NE attcond .)
    BREAK           reduce using rule 40 (exp_condition -> attcond NE attcond .)
    CONTINUE        reduce using rule 40 (exp_condition -> attcond NE attcond .)
    IF              reduce using rule 40 (exp_condition -> attcond NE attcond .)
    ID_SC           reduce using rule 40 (exp_condition -> attcond NE attcond .)
    ID_LI           reduce using rule 40 (exp_condition -> attcond NE attcond .)
    INCREMENT       reduce using rule 40 (exp_condition -> attcond NE attcond .)
    DECREMENT       reduce using rule 40 (exp_condition -> attcond NE attcond .)
    ID              reduce using rule 40 (exp_condition -> attcond NE attcond .)
    FOR             reduce using rule 40 (exp_condition -> attcond NE attcond .)
    DO              reduce using rule 40 (exp_condition -> attcond NE attcond .)
    WHILE           reduce using rule 40 (exp_condition -> attcond NE attcond .)
    SUB             reduce using rule 40 (exp_condition -> attcond NE attcond .)
    $end            reduce using rule 40 (exp_condition -> attcond NE attcond .)
    RBRACE          reduce using rule 40 (exp_condition -> attcond NE attcond .)
    GT              reduce using rule 40 (exp_condition -> attcond NE attcond .)
    LT              reduce using rule 40 (exp_condition -> attcond NE attcond .)
    EQ              reduce using rule 40 (exp_condition -> attcond NE attcond .)
    GE              reduce using rule 40 (exp_condition -> attcond NE attcond .)
    LE              reduce using rule 40 (exp_condition -> attcond NE attcond .)
    NE              reduce using rule 40 (exp_condition -> attcond NE attcond .)
    CMP             reduce using rule 40 (exp_condition -> attcond NE attcond .)
    SEQ             reduce using rule 40 (exp_condition -> attcond NE attcond .)
    SNE             reduce using rule 40 (exp_condition -> attcond NE attcond .)
    SLT             reduce using rule 40 (exp_condition -> attcond NE attcond .)
    SGT             reduce using rule 40 (exp_condition -> attcond NE attcond .)
    SLE             reduce using rule 40 (exp_condition -> attcond NE attcond .)
    SGE             reduce using rule 40 (exp_condition -> attcond NE attcond .)
    COMMA           reduce using rule 40 (exp_condition -> attcond NE attcond .)


state 110

    (43) exp_condition -> attcond CMP attcond .

    XOR             reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    TIMES           reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    DIVIDE          reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    MODULO          reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    PLUS            reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    MINUS           reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    SEMICOLON       reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    RPAREN          reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    RETURN          reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    BREAK           reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    CONTINUE        reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    IF              reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    ID_SC           reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    ID_LI           reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    INCREMENT       reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    DECREMENT       reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    ID              reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    FOR             reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    DO              reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    WHILE           reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    SUB             reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    $end            reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    RBRACE          reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    GT              reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    LT              reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    EQ              reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    GE              reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    LE              reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    NE              reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    CMP             reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    SEQ             reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    SNE             reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    SLT             reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    SGT             reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    SLE             reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    SGE             reduce using rule 43 (exp_condition -> attcond CMP attcond .)
    COMMA           reduce using rule 43 (exp_condition -> attcond CMP attcond .)


state 111

    (44) exp_condition -> attcond SEQ attcond .

    XOR             reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    TIMES           reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    DIVIDE          reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    MODULO          reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    PLUS            reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    MINUS           reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    SEMICOLON       reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    RPAREN          reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    RETURN          reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    BREAK           reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    CONTINUE        reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    IF              reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    ID_SC           reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    ID_LI           reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    INCREMENT       reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    DECREMENT       reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    ID              reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    FOR             reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    DO              reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    WHILE           reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    SUB             reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    $end            reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    RBRACE          reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    GT              reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    LT              reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    EQ              reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    GE              reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    LE              reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    NE              reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    CMP             reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    SEQ             reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    SNE             reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    SLT             reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    SGT             reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    SLE             reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    SGE             reduce using rule 44 (exp_condition -> attcond SEQ attcond .)
    COMMA           reduce using rule 44 (exp_condition -> attcond SEQ attcond .)


state 112

    (45) exp_condition -> attcond SNE attcond .

    XOR             reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    TIMES           reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    DIVIDE          reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    MODULO          reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    PLUS            reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    MINUS           reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    SEMICOLON       reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    RPAREN          reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    RETURN          reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    BREAK           reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    CONTINUE        reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    IF              reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    ID_SC           reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    ID_LI           reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    INCREMENT       reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    DECREMENT       reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    ID              reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    FOR             reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    DO              reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    WHILE           reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    SUB             reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    $end            reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    RBRACE          reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    GT              reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    LT              reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    EQ              reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    GE              reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    LE              reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    NE              reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    CMP             reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    SEQ             reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    SNE             reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    SLT             reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    SGT             reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    SLE             reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    SGE             reduce using rule 45 (exp_condition -> attcond SNE attcond .)
    COMMA           reduce using rule 45 (exp_condition -> attcond SNE attcond .)


state 113

    (46) exp_condition -> attcond SLT attcond .

    XOR             reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    TIMES           reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    DIVIDE          reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    MODULO          reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    PLUS            reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    MINUS           reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    SEMICOLON       reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    RPAREN          reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    RETURN          reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    BREAK           reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    CONTINUE        reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    IF              reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    ID_SC           reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    ID_LI           reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    INCREMENT       reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    DECREMENT       reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    ID              reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    FOR             reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    DO              reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    WHILE           reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    SUB             reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    $end            reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    RBRACE          reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    GT              reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    LT              reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    EQ              reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    GE              reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    LE              reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    NE              reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    CMP             reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    SEQ             reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    SNE             reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    SLT             reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    SGT             reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    SLE             reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    SGE             reduce using rule 46 (exp_condition -> attcond SLT attcond .)
    COMMA           reduce using rule 46 (exp_condition -> attcond SLT attcond .)


state 114

    (47) exp_condition -> attcond SGT attcond .

    XOR             reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    TIMES           reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    DIVIDE          reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    MODULO          reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    PLUS            reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    MINUS           reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    SEMICOLON       reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    RPAREN          reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    RETURN          reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    BREAK           reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    CONTINUE        reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    IF              reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    ID_SC           reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    ID_LI           reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    INCREMENT       reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    DECREMENT       reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    ID              reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    FOR             reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    DO              reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    WHILE           reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    SUB             reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    $end            reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    RBRACE          reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    GT              reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    LT              reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    EQ              reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    GE              reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    LE              reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    NE              reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    CMP             reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    SEQ             reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    SNE             reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    SLT             reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    SGT             reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    SLE             reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    SGE             reduce using rule 47 (exp_condition -> attcond SGT attcond .)
    COMMA           reduce using rule 47 (exp_condition -> attcond SGT attcond .)


state 115

    (48) exp_condition -> attcond SLE attcond .

    XOR             reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    TIMES           reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    DIVIDE          reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    MODULO          reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    PLUS            reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    MINUS           reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    SEMICOLON       reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    RPAREN          reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    RETURN          reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    BREAK           reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    CONTINUE        reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    IF              reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    ID_SC           reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    ID_LI           reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    INCREMENT       reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    DECREMENT       reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    ID              reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    FOR             reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    DO              reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    WHILE           reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    SUB             reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    $end            reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    RBRACE          reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    GT              reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    LT              reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    EQ              reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    GE              reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    LE              reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    NE              reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    CMP             reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    SEQ             reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    SNE             reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    SLT             reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    SGT             reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    SLE             reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    SGE             reduce using rule 48 (exp_condition -> attcond SLE attcond .)
    COMMA           reduce using rule 48 (exp_condition -> attcond SLE attcond .)


state 116

    (49) exp_condition -> attcond SGE attcond .

    XOR             reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    TIMES           reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    DIVIDE          reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    MODULO          reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    PLUS            reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    MINUS           reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    SEMICOLON       reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    RPAREN          reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    RETURN          reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    BREAK           reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    CONTINUE        reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    IF              reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    ID_SC           reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    ID_LI           reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    INCREMENT       reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    DECREMENT       reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    ID              reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    FOR             reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    DO              reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    WHILE           reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    SUB             reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    $end            reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    RBRACE          reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    GT              reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    LT              reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    EQ              reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    GE              reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    LE              reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    NE              reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    CMP             reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    SEQ             reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    SNE             reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    SLT             reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    SGT             reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    SLE             reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    SGE             reduce using rule 49 (exp_condition -> attcond SGE attcond .)
    COMMA           reduce using rule 49 (exp_condition -> attcond SGE attcond .)


state 117

    (78) exp3 -> exp .
    (64) exp -> exp . PLUS exp1
    (65) exp -> exp . MINUS exp1

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RETURN          reduce using rule 78 (exp3 -> exp .)
    BREAK           reduce using rule 78 (exp3 -> exp .)
    CONTINUE        reduce using rule 78 (exp3 -> exp .)
    IF              reduce using rule 78 (exp3 -> exp .)
    ID_SC           reduce using rule 78 (exp3 -> exp .)
    ID_LI           reduce using rule 78 (exp3 -> exp .)
    INCREMENT       reduce using rule 78 (exp3 -> exp .)
    DECREMENT       reduce using rule 78 (exp3 -> exp .)
    ID              reduce using rule 78 (exp3 -> exp .)
    FOR             reduce using rule 78 (exp3 -> exp .)
    DO              reduce using rule 78 (exp3 -> exp .)
    WHILE           reduce using rule 78 (exp3 -> exp .)
    SUB             reduce using rule 78 (exp3 -> exp .)
    $end            reduce using rule 78 (exp3 -> exp .)
    RBRACE          reduce using rule 78 (exp3 -> exp .)
    GT              reduce using rule 78 (exp3 -> exp .)
    LT              reduce using rule 78 (exp3 -> exp .)
    EQ              reduce using rule 78 (exp3 -> exp .)
    GE              reduce using rule 78 (exp3 -> exp .)
    LE              reduce using rule 78 (exp3 -> exp .)
    NE              reduce using rule 78 (exp3 -> exp .)
    CMP             reduce using rule 78 (exp3 -> exp .)
    SEQ             reduce using rule 78 (exp3 -> exp .)
    SNE             reduce using rule 78 (exp3 -> exp .)
    SLT             reduce using rule 78 (exp3 -> exp .)
    SGT             reduce using rule 78 (exp3 -> exp .)
    SLE             reduce using rule 78 (exp3 -> exp .)
    SGE             reduce using rule 78 (exp3 -> exp .)
    SEMICOLON       reduce using rule 78 (exp3 -> exp .)
    XOR             reduce using rule 78 (exp3 -> exp .)
    TIMES           reduce using rule 78 (exp3 -> exp .)
    DIVIDE          reduce using rule 78 (exp3 -> exp .)
    MODULO          reduce using rule 78 (exp3 -> exp .)
    COMMA           reduce using rule 78 (exp3 -> exp .)
    RPAREN          reduce using rule 78 (exp3 -> exp .)
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75

  ! PLUS            [ reduce using rule 78 (exp3 -> exp .) ]
  ! MINUS           [ reduce using rule 78 (exp3 -> exp .) ]


state 118

    (64) exp -> exp PLUS exp1 .
    (67) exp1 -> exp1 . TIMES exp2
    (68) exp1 -> exp1 . DIVIDE exp2
    (69) exp1 -> exp1 . MODULO exp2
    (66) exp -> exp1 .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! reduce/reduce conflict for RETURN resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for BREAK resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for IF resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for ID_SC resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for ID_LI resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for INCREMENT resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for DECREMENT resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for ID resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for FOR resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for DO resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for WHILE resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for SUB resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for $end resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for RBRACE resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for GT resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for LT resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for EQ resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for GE resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for LE resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for NE resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for CMP resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for SEQ resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for SNE resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for SLT resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for SGT resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for SLE resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for SGE resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for XOR resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for MINUS resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for COMMA resolved using rule 64 (exp -> exp PLUS exp1 .)
  ! reduce/reduce conflict for RPAREN resolved using rule 64 (exp -> exp PLUS exp1 .)
    XOR             reduce using rule 64 (exp -> exp PLUS exp1 .)
    PLUS            reduce using rule 64 (exp -> exp PLUS exp1 .)
    MINUS           reduce using rule 64 (exp -> exp PLUS exp1 .)
    SEMICOLON       reduce using rule 64 (exp -> exp PLUS exp1 .)
    RPAREN          reduce using rule 64 (exp -> exp PLUS exp1 .)
    RETURN          reduce using rule 64 (exp -> exp PLUS exp1 .)
    BREAK           reduce using rule 64 (exp -> exp PLUS exp1 .)
    CONTINUE        reduce using rule 64 (exp -> exp PLUS exp1 .)
    IF              reduce using rule 64 (exp -> exp PLUS exp1 .)
    ID_SC           reduce using rule 64 (exp -> exp PLUS exp1 .)
    ID_LI           reduce using rule 64 (exp -> exp PLUS exp1 .)
    INCREMENT       reduce using rule 64 (exp -> exp PLUS exp1 .)
    DECREMENT       reduce using rule 64 (exp -> exp PLUS exp1 .)
    ID              reduce using rule 64 (exp -> exp PLUS exp1 .)
    FOR             reduce using rule 64 (exp -> exp PLUS exp1 .)
    DO              reduce using rule 64 (exp -> exp PLUS exp1 .)
    WHILE           reduce using rule 64 (exp -> exp PLUS exp1 .)
    SUB             reduce using rule 64 (exp -> exp PLUS exp1 .)
    $end            reduce using rule 64 (exp -> exp PLUS exp1 .)
    RBRACE          reduce using rule 64 (exp -> exp PLUS exp1 .)
    GT              reduce using rule 64 (exp -> exp PLUS exp1 .)
    LT              reduce using rule 64 (exp -> exp PLUS exp1 .)
    EQ              reduce using rule 64 (exp -> exp PLUS exp1 .)
    GE              reduce using rule 64 (exp -> exp PLUS exp1 .)
    LE              reduce using rule 64 (exp -> exp PLUS exp1 .)
    NE              reduce using rule 64 (exp -> exp PLUS exp1 .)
    CMP             reduce using rule 64 (exp -> exp PLUS exp1 .)
    SEQ             reduce using rule 64 (exp -> exp PLUS exp1 .)
    SNE             reduce using rule 64 (exp -> exp PLUS exp1 .)
    SLT             reduce using rule 64 (exp -> exp PLUS exp1 .)
    SGT             reduce using rule 64 (exp -> exp PLUS exp1 .)
    SLE             reduce using rule 64 (exp -> exp PLUS exp1 .)
    SGE             reduce using rule 64 (exp -> exp PLUS exp1 .)
    COMMA           reduce using rule 64 (exp -> exp PLUS exp1 .)
    TIMES           shift and go to state 76
    DIVIDE          shift and go to state 77
    MODULO          shift and go to state 78

  ! TIMES           [ reduce using rule 64 (exp -> exp PLUS exp1 .) ]
  ! DIVIDE          [ reduce using rule 64 (exp -> exp PLUS exp1 .) ]
  ! MODULO          [ reduce using rule 64 (exp -> exp PLUS exp1 .) ]
  ! RETURN          [ reduce using rule 66 (exp -> exp1 .) ]
  ! BREAK           [ reduce using rule 66 (exp -> exp1 .) ]
  ! CONTINUE        [ reduce using rule 66 (exp -> exp1 .) ]
  ! IF              [ reduce using rule 66 (exp -> exp1 .) ]
  ! ID_SC           [ reduce using rule 66 (exp -> exp1 .) ]
  ! ID_LI           [ reduce using rule 66 (exp -> exp1 .) ]
  ! INCREMENT       [ reduce using rule 66 (exp -> exp1 .) ]
  ! DECREMENT       [ reduce using rule 66 (exp -> exp1 .) ]
  ! ID              [ reduce using rule 66 (exp -> exp1 .) ]
  ! FOR             [ reduce using rule 66 (exp -> exp1 .) ]
  ! DO              [ reduce using rule 66 (exp -> exp1 .) ]
  ! WHILE           [ reduce using rule 66 (exp -> exp1 .) ]
  ! SUB             [ reduce using rule 66 (exp -> exp1 .) ]
  ! $end            [ reduce using rule 66 (exp -> exp1 .) ]
  ! RBRACE          [ reduce using rule 66 (exp -> exp1 .) ]
  ! GT              [ reduce using rule 66 (exp -> exp1 .) ]
  ! LT              [ reduce using rule 66 (exp -> exp1 .) ]
  ! EQ              [ reduce using rule 66 (exp -> exp1 .) ]
  ! GE              [ reduce using rule 66 (exp -> exp1 .) ]
  ! LE              [ reduce using rule 66 (exp -> exp1 .) ]
  ! NE              [ reduce using rule 66 (exp -> exp1 .) ]
  ! CMP             [ reduce using rule 66 (exp -> exp1 .) ]
  ! SEQ             [ reduce using rule 66 (exp -> exp1 .) ]
  ! SNE             [ reduce using rule 66 (exp -> exp1 .) ]
  ! SLT             [ reduce using rule 66 (exp -> exp1 .) ]
  ! SGT             [ reduce using rule 66 (exp -> exp1 .) ]
  ! SLE             [ reduce using rule 66 (exp -> exp1 .) ]
  ! SGE             [ reduce using rule 66 (exp -> exp1 .) ]
  ! SEMICOLON       [ reduce using rule 66 (exp -> exp1 .) ]
  ! XOR             [ reduce using rule 66 (exp -> exp1 .) ]
  ! TIMES           [ reduce using rule 66 (exp -> exp1 .) ]
  ! DIVIDE          [ reduce using rule 66 (exp -> exp1 .) ]
  ! MODULO          [ reduce using rule 66 (exp -> exp1 .) ]
  ! PLUS            [ reduce using rule 66 (exp -> exp1 .) ]
  ! MINUS           [ reduce using rule 66 (exp -> exp1 .) ]
  ! COMMA           [ reduce using rule 66 (exp -> exp1 .) ]
  ! RPAREN          [ reduce using rule 66 (exp -> exp1 .) ]


state 119

    (65) exp -> exp MINUS exp1 .
    (67) exp1 -> exp1 . TIMES exp2
    (68) exp1 -> exp1 . DIVIDE exp2
    (69) exp1 -> exp1 . MODULO exp2
    (66) exp -> exp1 .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! reduce/reduce conflict for RETURN resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for BREAK resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for IF resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for ID_SC resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for ID_LI resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for INCREMENT resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for DECREMENT resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for ID resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for FOR resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for DO resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for WHILE resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for SUB resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for $end resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for RBRACE resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for GT resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for LT resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for EQ resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for GE resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for LE resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for NE resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for CMP resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for SEQ resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for SNE resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for SLT resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for SGT resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for SLE resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for SGE resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for XOR resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for MINUS resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for COMMA resolved using rule 65 (exp -> exp MINUS exp1 .)
  ! reduce/reduce conflict for RPAREN resolved using rule 65 (exp -> exp MINUS exp1 .)
    XOR             reduce using rule 65 (exp -> exp MINUS exp1 .)
    PLUS            reduce using rule 65 (exp -> exp MINUS exp1 .)
    MINUS           reduce using rule 65 (exp -> exp MINUS exp1 .)
    SEMICOLON       reduce using rule 65 (exp -> exp MINUS exp1 .)
    RPAREN          reduce using rule 65 (exp -> exp MINUS exp1 .)
    RETURN          reduce using rule 65 (exp -> exp MINUS exp1 .)
    BREAK           reduce using rule 65 (exp -> exp MINUS exp1 .)
    CONTINUE        reduce using rule 65 (exp -> exp MINUS exp1 .)
    IF              reduce using rule 65 (exp -> exp MINUS exp1 .)
    ID_SC           reduce using rule 65 (exp -> exp MINUS exp1 .)
    ID_LI           reduce using rule 65 (exp -> exp MINUS exp1 .)
    INCREMENT       reduce using rule 65 (exp -> exp MINUS exp1 .)
    DECREMENT       reduce using rule 65 (exp -> exp MINUS exp1 .)
    ID              reduce using rule 65 (exp -> exp MINUS exp1 .)
    FOR             reduce using rule 65 (exp -> exp MINUS exp1 .)
    DO              reduce using rule 65 (exp -> exp MINUS exp1 .)
    WHILE           reduce using rule 65 (exp -> exp MINUS exp1 .)
    SUB             reduce using rule 65 (exp -> exp MINUS exp1 .)
    $end            reduce using rule 65 (exp -> exp MINUS exp1 .)
    RBRACE          reduce using rule 65 (exp -> exp MINUS exp1 .)
    GT              reduce using rule 65 (exp -> exp MINUS exp1 .)
    LT              reduce using rule 65 (exp -> exp MINUS exp1 .)
    EQ              reduce using rule 65 (exp -> exp MINUS exp1 .)
    GE              reduce using rule 65 (exp -> exp MINUS exp1 .)
    LE              reduce using rule 65 (exp -> exp MINUS exp1 .)
    NE              reduce using rule 65 (exp -> exp MINUS exp1 .)
    CMP             reduce using rule 65 (exp -> exp MINUS exp1 .)
    SEQ             reduce using rule 65 (exp -> exp MINUS exp1 .)
    SNE             reduce using rule 65 (exp -> exp MINUS exp1 .)
    SLT             reduce using rule 65 (exp -> exp MINUS exp1 .)
    SGT             reduce using rule 65 (exp -> exp MINUS exp1 .)
    SLE             reduce using rule 65 (exp -> exp MINUS exp1 .)
    SGE             reduce using rule 65 (exp -> exp MINUS exp1 .)
    COMMA           reduce using rule 65 (exp -> exp MINUS exp1 .)
    TIMES           shift and go to state 76
    DIVIDE          shift and go to state 77
    MODULO          shift and go to state 78

  ! TIMES           [ reduce using rule 65 (exp -> exp MINUS exp1 .) ]
  ! DIVIDE          [ reduce using rule 65 (exp -> exp MINUS exp1 .) ]
  ! MODULO          [ reduce using rule 65 (exp -> exp MINUS exp1 .) ]
  ! RETURN          [ reduce using rule 66 (exp -> exp1 .) ]
  ! BREAK           [ reduce using rule 66 (exp -> exp1 .) ]
  ! CONTINUE        [ reduce using rule 66 (exp -> exp1 .) ]
  ! IF              [ reduce using rule 66 (exp -> exp1 .) ]
  ! ID_SC           [ reduce using rule 66 (exp -> exp1 .) ]
  ! ID_LI           [ reduce using rule 66 (exp -> exp1 .) ]
  ! INCREMENT       [ reduce using rule 66 (exp -> exp1 .) ]
  ! DECREMENT       [ reduce using rule 66 (exp -> exp1 .) ]
  ! ID              [ reduce using rule 66 (exp -> exp1 .) ]
  ! FOR             [ reduce using rule 66 (exp -> exp1 .) ]
  ! DO              [ reduce using rule 66 (exp -> exp1 .) ]
  ! WHILE           [ reduce using rule 66 (exp -> exp1 .) ]
  ! SUB             [ reduce using rule 66 (exp -> exp1 .) ]
  ! $end            [ reduce using rule 66 (exp -> exp1 .) ]
  ! RBRACE          [ reduce using rule 66 (exp -> exp1 .) ]
  ! GT              [ reduce using rule 66 (exp -> exp1 .) ]
  ! LT              [ reduce using rule 66 (exp -> exp1 .) ]
  ! EQ              [ reduce using rule 66 (exp -> exp1 .) ]
  ! GE              [ reduce using rule 66 (exp -> exp1 .) ]
  ! LE              [ reduce using rule 66 (exp -> exp1 .) ]
  ! NE              [ reduce using rule 66 (exp -> exp1 .) ]
  ! CMP             [ reduce using rule 66 (exp -> exp1 .) ]
  ! SEQ             [ reduce using rule 66 (exp -> exp1 .) ]
  ! SNE             [ reduce using rule 66 (exp -> exp1 .) ]
  ! SLT             [ reduce using rule 66 (exp -> exp1 .) ]
  ! SGT             [ reduce using rule 66 (exp -> exp1 .) ]
  ! SLE             [ reduce using rule 66 (exp -> exp1 .) ]
  ! SGE             [ reduce using rule 66 (exp -> exp1 .) ]
  ! SEMICOLON       [ reduce using rule 66 (exp -> exp1 .) ]
  ! XOR             [ reduce using rule 66 (exp -> exp1 .) ]
  ! TIMES           [ reduce using rule 66 (exp -> exp1 .) ]
  ! DIVIDE          [ reduce using rule 66 (exp -> exp1 .) ]
  ! MODULO          [ reduce using rule 66 (exp -> exp1 .) ]
  ! PLUS            [ reduce using rule 66 (exp -> exp1 .) ]
  ! MINUS           [ reduce using rule 66 (exp -> exp1 .) ]
  ! COMMA           [ reduce using rule 66 (exp -> exp1 .) ]
  ! RPAREN          [ reduce using rule 66 (exp -> exp1 .) ]


state 120

    (67) exp1 -> exp1 TIMES exp2 .
    (70) exp1 -> exp2 .

  ! reduce/reduce conflict for RETURN resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for BREAK resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for IF resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for ID_SC resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for ID_LI resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for INCREMENT resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for DECREMENT resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for ID resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for FOR resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for DO resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for WHILE resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for SUB resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for $end resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for RBRACE resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for GT resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for LT resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for EQ resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for GE resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for LE resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for NE resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for CMP resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for SEQ resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for SNE resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for SLT resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for SGT resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for SLE resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for SGE resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for XOR resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for TIMES resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for MODULO resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for PLUS resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for MINUS resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for COMMA resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
  ! reduce/reduce conflict for RPAREN resolved using rule 67 (exp1 -> exp1 TIMES exp2 .)
    XOR             reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    TIMES           reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    DIVIDE          reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    MODULO          reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    PLUS            reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    MINUS           reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    SEMICOLON       reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    RPAREN          reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    RETURN          reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    BREAK           reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    CONTINUE        reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    IF              reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    ID_SC           reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    ID_LI           reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    INCREMENT       reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    DECREMENT       reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    ID              reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    FOR             reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    DO              reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    WHILE           reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    SUB             reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    $end            reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    RBRACE          reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    GT              reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    LT              reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    EQ              reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    GE              reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    LE              reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    NE              reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    CMP             reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    SEQ             reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    SNE             reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    SLT             reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    SGT             reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    SLE             reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    SGE             reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)
    COMMA           reduce using rule 67 (exp1 -> exp1 TIMES exp2 .)

  ! RETURN          [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! BREAK           [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! CONTINUE        [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! IF              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! ID_SC           [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! ID_LI           [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! INCREMENT       [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! DECREMENT       [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! ID              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! FOR             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! DO              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! WHILE           [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SUB             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! $end            [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! RBRACE          [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! GT              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! LT              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! EQ              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! GE              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! LE              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! NE              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! CMP             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SEQ             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SNE             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SLT             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SGT             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SLE             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SGE             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SEMICOLON       [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! XOR             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! TIMES           [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! DIVIDE          [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! MODULO          [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! PLUS            [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! MINUS           [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! COMMA           [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! RPAREN          [ reduce using rule 70 (exp1 -> exp2 .) ]


state 121

    (68) exp1 -> exp1 DIVIDE exp2 .
    (70) exp1 -> exp2 .

  ! reduce/reduce conflict for RETURN resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for BREAK resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for IF resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for ID_SC resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for ID_LI resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for INCREMENT resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for DECREMENT resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for ID resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for FOR resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for DO resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for WHILE resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for SUB resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for $end resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for RBRACE resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for GT resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for LT resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for EQ resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for GE resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for LE resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for NE resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for CMP resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for SEQ resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for SNE resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for SLT resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for SGT resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for SLE resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for SGE resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for XOR resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for TIMES resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for MODULO resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for PLUS resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for MINUS resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for COMMA resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
  ! reduce/reduce conflict for RPAREN resolved using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    XOR             reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    TIMES           reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    DIVIDE          reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    MODULO          reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    PLUS            reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    MINUS           reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    SEMICOLON       reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    RPAREN          reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    RETURN          reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    BREAK           reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    CONTINUE        reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    IF              reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    ID_SC           reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    ID_LI           reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    INCREMENT       reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    DECREMENT       reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    ID              reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    FOR             reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    DO              reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    WHILE           reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    SUB             reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    $end            reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    RBRACE          reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    GT              reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    LT              reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    EQ              reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    GE              reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    LE              reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    NE              reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    CMP             reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    SEQ             reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    SNE             reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    SLT             reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    SGT             reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    SLE             reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    SGE             reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)
    COMMA           reduce using rule 68 (exp1 -> exp1 DIVIDE exp2 .)

  ! RETURN          [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! BREAK           [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! CONTINUE        [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! IF              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! ID_SC           [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! ID_LI           [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! INCREMENT       [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! DECREMENT       [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! ID              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! FOR             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! DO              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! WHILE           [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SUB             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! $end            [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! RBRACE          [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! GT              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! LT              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! EQ              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! GE              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! LE              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! NE              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! CMP             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SEQ             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SNE             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SLT             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SGT             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SLE             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SGE             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SEMICOLON       [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! XOR             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! TIMES           [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! DIVIDE          [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! MODULO          [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! PLUS            [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! MINUS           [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! COMMA           [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! RPAREN          [ reduce using rule 70 (exp1 -> exp2 .) ]


state 122

    (69) exp1 -> exp1 MODULO exp2 .
    (70) exp1 -> exp2 .

  ! reduce/reduce conflict for RETURN resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for BREAK resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for IF resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for ID_SC resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for ID_LI resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for INCREMENT resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for DECREMENT resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for ID resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for FOR resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for DO resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for WHILE resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for SUB resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for $end resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for RBRACE resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for GT resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for LT resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for EQ resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for GE resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for LE resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for NE resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for CMP resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for SEQ resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for SNE resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for SLT resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for SGT resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for SLE resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for SGE resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for XOR resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for TIMES resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for MODULO resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for PLUS resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for MINUS resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for COMMA resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
  ! reduce/reduce conflict for RPAREN resolved using rule 69 (exp1 -> exp1 MODULO exp2 .)
    XOR             reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    TIMES           reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    DIVIDE          reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    MODULO          reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    PLUS            reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    MINUS           reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    SEMICOLON       reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    RPAREN          reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    RETURN          reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    BREAK           reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    CONTINUE        reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    IF              reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    ID_SC           reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    ID_LI           reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    INCREMENT       reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    DECREMENT       reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    ID              reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    FOR             reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    DO              reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    WHILE           reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    SUB             reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    $end            reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    RBRACE          reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    GT              reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    LT              reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    EQ              reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    GE              reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    LE              reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    NE              reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    CMP             reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    SEQ             reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    SNE             reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    SLT             reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    SGT             reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    SLE             reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    SGE             reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)
    COMMA           reduce using rule 69 (exp1 -> exp1 MODULO exp2 .)

  ! RETURN          [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! BREAK           [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! CONTINUE        [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! IF              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! ID_SC           [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! ID_LI           [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! INCREMENT       [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! DECREMENT       [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! ID              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! FOR             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! DO              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! WHILE           [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SUB             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! $end            [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! RBRACE          [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! GT              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! LT              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! EQ              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! GE              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! LE              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! NE              [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! CMP             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SEQ             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SNE             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SLT             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SGT             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SLE             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SGE             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! SEMICOLON       [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! XOR             [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! TIMES           [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! DIVIDE          [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! MODULO          [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! PLUS            [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! MINUS           [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! COMMA           [ reduce using rule 70 (exp1 -> exp2 .) ]
  ! RPAREN          [ reduce using rule 70 (exp1 -> exp2 .) ]


state 123

    (71) exp2 -> exp3 XOR exp2 .
    (70) exp1 -> exp2 .

  ! reduce/reduce conflict for RETURN resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for BREAK resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for IF resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for ID_SC resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for ID_LI resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for INCREMENT resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for DECREMENT resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for ID resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for FOR resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for DO resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for WHILE resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for SUB resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for $end resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for RBRACE resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for GT resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for LT resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for EQ resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for GE resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for LE resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for NE resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for CMP resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for SEQ resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for SNE resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for SLT resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for SGT resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for SLE resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for SGE resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for XOR resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for TIMES resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for MODULO resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for PLUS resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for MINUS resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for COMMA resolved using rule 70 (exp1 -> exp2 .)
  ! reduce/reduce conflict for RPAREN resolved using rule 70 (exp1 -> exp2 .)
    RETURN          reduce using rule 70 (exp1 -> exp2 .)
    BREAK           reduce using rule 70 (exp1 -> exp2 .)
    CONTINUE        reduce using rule 70 (exp1 -> exp2 .)
    IF              reduce using rule 70 (exp1 -> exp2 .)
    ID_SC           reduce using rule 70 (exp1 -> exp2 .)
    ID_LI           reduce using rule 70 (exp1 -> exp2 .)
    INCREMENT       reduce using rule 70 (exp1 -> exp2 .)
    DECREMENT       reduce using rule 70 (exp1 -> exp2 .)
    ID              reduce using rule 70 (exp1 -> exp2 .)
    FOR             reduce using rule 70 (exp1 -> exp2 .)
    DO              reduce using rule 70 (exp1 -> exp2 .)
    WHILE           reduce using rule 70 (exp1 -> exp2 .)
    SUB             reduce using rule 70 (exp1 -> exp2 .)
    $end            reduce using rule 70 (exp1 -> exp2 .)
    RBRACE          reduce using rule 70 (exp1 -> exp2 .)
    GT              reduce using rule 70 (exp1 -> exp2 .)
    LT              reduce using rule 70 (exp1 -> exp2 .)
    EQ              reduce using rule 70 (exp1 -> exp2 .)
    GE              reduce using rule 70 (exp1 -> exp2 .)
    LE              reduce using rule 70 (exp1 -> exp2 .)
    NE              reduce using rule 70 (exp1 -> exp2 .)
    CMP             reduce using rule 70 (exp1 -> exp2 .)
    SEQ             reduce using rule 70 (exp1 -> exp2 .)
    SNE             reduce using rule 70 (exp1 -> exp2 .)
    SLT             reduce using rule 70 (exp1 -> exp2 .)
    SGT             reduce using rule 70 (exp1 -> exp2 .)
    SLE             reduce using rule 70 (exp1 -> exp2 .)
    SGE             reduce using rule 70 (exp1 -> exp2 .)
    SEMICOLON       reduce using rule 70 (exp1 -> exp2 .)
    XOR             reduce using rule 70 (exp1 -> exp2 .)
    TIMES           reduce using rule 70 (exp1 -> exp2 .)
    DIVIDE          reduce using rule 70 (exp1 -> exp2 .)
    MODULO          reduce using rule 70 (exp1 -> exp2 .)
    PLUS            reduce using rule 70 (exp1 -> exp2 .)
    MINUS           reduce using rule 70 (exp1 -> exp2 .)
    COMMA           reduce using rule 70 (exp1 -> exp2 .)
    RPAREN          reduce using rule 70 (exp1 -> exp2 .)

  ! XOR             [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! TIMES           [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! DIVIDE          [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! MODULO          [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! PLUS            [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! MINUS           [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! SEMICOLON       [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! RPAREN          [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! RETURN          [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! BREAK           [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! CONTINUE        [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! IF              [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! ID_SC           [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! ID_LI           [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! INCREMENT       [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! DECREMENT       [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! ID              [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! FOR             [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! DO              [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! WHILE           [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! SUB             [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! $end            [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! RBRACE          [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! GT              [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! LT              [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! EQ              [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! GE              [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! LE              [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! NE              [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! CMP             [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! SEQ             [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! SNE             [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! SLT             [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! SGT             [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! SLE             [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! SGE             [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]
  ! COMMA           [ reduce using rule 71 (exp2 -> exp3 XOR exp2 .) ]


state 124

    (73) exp3 -> LPAREN arithmetic RPAREN .

    XOR             reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    TIMES           reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    DIVIDE          reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    MODULO          reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    PLUS            reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    MINUS           reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    SEMICOLON       reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    RPAREN          reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    RETURN          reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    BREAK           reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    CONTINUE        reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    IF              reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    ID_SC           reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    ID_LI           reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    INCREMENT       reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    DECREMENT       reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    ID              reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    FOR             reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    DO              reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    WHILE           reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    SUB             reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    $end            reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    RBRACE          reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    GT              reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    LT              reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    EQ              reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    GE              reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    LE              reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    NE              reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    CMP             reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    SEQ             reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    SNE             reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    SLT             reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    SGT             reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    SLE             reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    SGE             reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)
    COMMA           reduce using rule 73 (exp3 -> LPAREN arithmetic RPAREN .)


state 125

    (42) exp_condition -> LPAREN exp_condition RPAREN . logic exp_condition_logic
    (52) logic -> . LAND
    (53) logic -> . LOR
    (54) logic -> . LNOT

    LAND            shift and go to state 136
    LOR             shift and go to state 137
    LNOT            shift and go to state 138

    logic                          shift and go to state 135

state 126

    (42) exp_condition -> LPAREN exp_condition . RPAREN logic exp_condition_logic

    RPAREN          shift and go to state 125


state 127

    (14) if -> IF LPAREN exp_condition RPAREN . if_statement
    (15) if_statement -> . LBRACE blockcode RBRACE
    (16) if_statement -> . LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if_statement -> . LBRACE blockcode RBRACE elsif

    LBRACE          shift and go to state 140

    if_statement                   shift and go to state 139

state 128

    (25) for -> FOR LPAREN for_assignments SEMICOLON . exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (35) exp_condition -> . attcond GT attcond
    (36) exp_condition -> . attcond LT attcond
    (37) exp_condition -> . attcond EQ attcond
    (38) exp_condition -> . attcond GE attcond
    (39) exp_condition -> . attcond LE attcond
    (40) exp_condition -> . attcond NE attcond
    (41) exp_condition -> . attcond
    (42) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (43) exp_condition -> . attcond CMP attcond
    (44) exp_condition -> . attcond SEQ attcond
    (45) exp_condition -> . attcond SNE attcond
    (46) exp_condition -> . attcond SLT attcond
    (47) exp_condition -> . attcond SGT attcond
    (48) exp_condition -> . attcond SLE attcond
    (49) exp_condition -> . attcond SGE attcond
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    LPAREN          shift and go to state 84
    NUMBER          shift and go to state 87
    TRUE            shift and go to state 88
    FALSE           shift and go to state 89
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    exp_condition                  shift and go to state 141
    attcond                        shift and go to state 83
    exp_assignment                 shift and go to state 86

state 129

    (27) for_assignments -> exp_assignment COMMA . for_assignments
    (26) for_assignments -> . exp_assignment
    (27) for_assignments -> . exp_assignment COMMA for_assignments
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    exp_assignment                 shift and go to state 97
    for_assignments                shift and go to state 142

state 130

    (28) dowhile -> DO LBRACE blockcode RBRACE . WHILE LPAREN exp_condition RPAREN

    WHILE           shift and go to state 143


state 131

    (29) while -> WHILE LPAREN exp_condition RPAREN . LBRACE blockcode RBRACE
    (30) while -> WHILE LPAREN exp_condition RPAREN . LBRACE RBRACE

    LBRACE          shift and go to state 144


state 132

    (31) function -> SUB ID LPAREN RPAREN LBRACE . blockcode RBRACE
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN if_statement
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (30) while -> . WHILE LPAREN exp_condition RPAREN LBRACE RBRACE

    RETURN          shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    IF              shift and go to state 17
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    ID              shift and go to state 6
    FOR             shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24

    blockcode                      shift and go to state 145
    command                        shift and go to state 4
    interations                    shift and go to state 7
    if                             shift and go to state 8
    exp_assignment                 shift and go to state 9
    call                           shift and go to state 10
    for                            shift and go to state 14
    dowhile                        shift and go to state 15
    while                          shift and go to state 16

state 133

    (32) function -> SUB ID LPAREN function_assignments RPAREN . LBRACE blockcode RBRACE

    LBRACE          shift and go to state 146


state 134

    (34) function_assignments -> exp_assignment COMMA function_assignments .

    RPAREN          reduce using rule 34 (function_assignments -> exp_assignment COMMA function_assignments .)


state 135

    (42) exp_condition -> LPAREN exp_condition RPAREN logic . exp_condition_logic
    (50) exp_condition_logic -> . LPAREN exp_condition RPAREN
    (51) exp_condition_logic -> . LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN

    LPAREN          shift and go to state 147

    exp_condition_logic            shift and go to state 148

state 136

    (52) logic -> LAND .

    LPAREN          reduce using rule 52 (logic -> LAND .)


state 137

    (53) logic -> LOR .

    LPAREN          reduce using rule 53 (logic -> LOR .)


state 138

    (54) logic -> LNOT .

    LPAREN          reduce using rule 54 (logic -> LNOT .)


state 139

    (14) if -> IF LPAREN exp_condition RPAREN if_statement .

    RETURN          reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN if_statement .)
    BREAK           reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN if_statement .)
    CONTINUE        reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN if_statement .)
    IF              reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN if_statement .)
    ID_SC           reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN if_statement .)
    ID_LI           reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN if_statement .)
    INCREMENT       reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN if_statement .)
    DECREMENT       reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN if_statement .)
    ID              reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN if_statement .)
    FOR             reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN if_statement .)
    DO              reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN if_statement .)
    WHILE           reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN if_statement .)
    SUB             reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN if_statement .)
    $end            reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN if_statement .)
    RBRACE          reduce using rule 14 (if -> IF LPAREN exp_condition RPAREN if_statement .)


state 140

    (15) if_statement -> LBRACE . blockcode RBRACE
    (16) if_statement -> LBRACE . blockcode RBRACE ELSE LBRACE blockcode RBRACE
    (17) if_statement -> LBRACE . blockcode RBRACE elsif
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN if_statement
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (30) while -> . WHILE LPAREN exp_condition RPAREN LBRACE RBRACE

    RETURN          shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    IF              shift and go to state 17
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    ID              shift and go to state 6
    FOR             shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24

    blockcode                      shift and go to state 149
    command                        shift and go to state 4
    interations                    shift and go to state 7
    if                             shift and go to state 8
    exp_assignment                 shift and go to state 9
    call                           shift and go to state 10
    for                            shift and go to state 14
    dowhile                        shift and go to state 15
    while                          shift and go to state 16

state 141

    (25) for -> FOR LPAREN for_assignments SEMICOLON exp_condition . SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE

    SEMICOLON       shift and go to state 150


state 142

    (27) for_assignments -> exp_assignment COMMA for_assignments .

    SEMICOLON       reduce using rule 27 (for_assignments -> exp_assignment COMMA for_assignments .)
    RPAREN          reduce using rule 27 (for_assignments -> exp_assignment COMMA for_assignments .)


state 143

    (28) dowhile -> DO LBRACE blockcode RBRACE WHILE . LPAREN exp_condition RPAREN

    LPAREN          shift and go to state 151


state 144

    (29) while -> WHILE LPAREN exp_condition RPAREN LBRACE . blockcode RBRACE
    (30) while -> WHILE LPAREN exp_condition RPAREN LBRACE . RBRACE
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN if_statement
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (30) while -> . WHILE LPAREN exp_condition RPAREN LBRACE RBRACE

    RBRACE          shift and go to state 153
    RETURN          shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    IF              shift and go to state 17
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    ID              shift and go to state 6
    FOR             shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24

    blockcode                      shift and go to state 152
    command                        shift and go to state 4
    interations                    shift and go to state 7
    if                             shift and go to state 8
    exp_assignment                 shift and go to state 9
    call                           shift and go to state 10
    for                            shift and go to state 14
    dowhile                        shift and go to state 15
    while                          shift and go to state 16

state 145

    (31) function -> SUB ID LPAREN RPAREN LBRACE blockcode . RBRACE

    RBRACE          shift and go to state 154


state 146

    (32) function -> SUB ID LPAREN function_assignments RPAREN LBRACE . blockcode RBRACE
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN if_statement
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (30) while -> . WHILE LPAREN exp_condition RPAREN LBRACE RBRACE

    RETURN          shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    IF              shift and go to state 17
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    ID              shift and go to state 6
    FOR             shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24

    blockcode                      shift and go to state 155
    command                        shift and go to state 4
    interations                    shift and go to state 7
    if                             shift and go to state 8
    exp_assignment                 shift and go to state 9
    call                           shift and go to state 10
    for                            shift and go to state 14
    dowhile                        shift and go to state 15
    while                          shift and go to state 16

state 147

    (50) exp_condition_logic -> LPAREN . exp_condition RPAREN
    (51) exp_condition_logic -> LPAREN . exp_condition RPAREN logic LPAREN exp_condition RPAREN
    (35) exp_condition -> . attcond GT attcond
    (36) exp_condition -> . attcond LT attcond
    (37) exp_condition -> . attcond EQ attcond
    (38) exp_condition -> . attcond GE attcond
    (39) exp_condition -> . attcond LE attcond
    (40) exp_condition -> . attcond NE attcond
    (41) exp_condition -> . attcond
    (42) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (43) exp_condition -> . attcond CMP attcond
    (44) exp_condition -> . attcond SEQ attcond
    (45) exp_condition -> . attcond SNE attcond
    (46) exp_condition -> . attcond SLT attcond
    (47) exp_condition -> . attcond SGT attcond
    (48) exp_condition -> . attcond SLE attcond
    (49) exp_condition -> . attcond SGE attcond
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    LPAREN          shift and go to state 84
    NUMBER          shift and go to state 87
    TRUE            shift and go to state 88
    FALSE           shift and go to state 89
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    exp_condition                  shift and go to state 156
    attcond                        shift and go to state 83
    exp_assignment                 shift and go to state 86

state 148

    (42) exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .

    XOR             reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    TIMES           reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    DIVIDE          reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    MODULO          reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    PLUS            reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    MINUS           reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    SEMICOLON       reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    RPAREN          reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    RETURN          reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    BREAK           reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    CONTINUE        reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    IF              reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    ID_SC           reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    ID_LI           reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    INCREMENT       reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    DECREMENT       reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    ID              reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    FOR             reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    DO              reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    WHILE           reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    SUB             reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    $end            reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    RBRACE          reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    GT              reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    LT              reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    EQ              reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    GE              reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    LE              reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    NE              reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    CMP             reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    SEQ             reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    SNE             reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    SLT             reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    SGT             reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    SLE             reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    SGE             reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)
    COMMA           reduce using rule 42 (exp_condition -> LPAREN exp_condition RPAREN logic exp_condition_logic .)


state 149

    (15) if_statement -> LBRACE blockcode . RBRACE
    (16) if_statement -> LBRACE blockcode . RBRACE ELSE LBRACE blockcode RBRACE
    (17) if_statement -> LBRACE blockcode . RBRACE elsif

    RBRACE          shift and go to state 157


state 150

    (25) for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON . for_assignments RPAREN LBRACE blockcode RBRACE
    (26) for_assignments -> . exp_assignment
    (27) for_assignments -> . exp_assignment COMMA for_assignments
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    for_assignments                shift and go to state 158
    exp_assignment                 shift and go to state 97

state 151

    (28) dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN . exp_condition RPAREN
    (35) exp_condition -> . attcond GT attcond
    (36) exp_condition -> . attcond LT attcond
    (37) exp_condition -> . attcond EQ attcond
    (38) exp_condition -> . attcond GE attcond
    (39) exp_condition -> . attcond LE attcond
    (40) exp_condition -> . attcond NE attcond
    (41) exp_condition -> . attcond
    (42) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (43) exp_condition -> . attcond CMP attcond
    (44) exp_condition -> . attcond SEQ attcond
    (45) exp_condition -> . attcond SNE attcond
    (46) exp_condition -> . attcond SLT attcond
    (47) exp_condition -> . attcond SGT attcond
    (48) exp_condition -> . attcond SLE attcond
    (49) exp_condition -> . attcond SGE attcond
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    LPAREN          shift and go to state 84
    NUMBER          shift and go to state 87
    TRUE            shift and go to state 88
    FALSE           shift and go to state 89
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    exp_condition                  shift and go to state 159
    attcond                        shift and go to state 83
    exp_assignment                 shift and go to state 86

state 152

    (29) while -> WHILE LPAREN exp_condition RPAREN LBRACE blockcode . RBRACE

    RBRACE          shift and go to state 160


state 153

    (30) while -> WHILE LPAREN exp_condition RPAREN LBRACE RBRACE .

    RETURN          reduce using rule 30 (while -> WHILE LPAREN exp_condition RPAREN LBRACE RBRACE .)
    BREAK           reduce using rule 30 (while -> WHILE LPAREN exp_condition RPAREN LBRACE RBRACE .)
    CONTINUE        reduce using rule 30 (while -> WHILE LPAREN exp_condition RPAREN LBRACE RBRACE .)
    IF              reduce using rule 30 (while -> WHILE LPAREN exp_condition RPAREN LBRACE RBRACE .)
    ID_SC           reduce using rule 30 (while -> WHILE LPAREN exp_condition RPAREN LBRACE RBRACE .)
    ID_LI           reduce using rule 30 (while -> WHILE LPAREN exp_condition RPAREN LBRACE RBRACE .)
    INCREMENT       reduce using rule 30 (while -> WHILE LPAREN exp_condition RPAREN LBRACE RBRACE .)
    DECREMENT       reduce using rule 30 (while -> WHILE LPAREN exp_condition RPAREN LBRACE RBRACE .)
    ID              reduce using rule 30 (while -> WHILE LPAREN exp_condition RPAREN LBRACE RBRACE .)
    FOR             reduce using rule 30 (while -> WHILE LPAREN exp_condition RPAREN LBRACE RBRACE .)
    DO              reduce using rule 30 (while -> WHILE LPAREN exp_condition RPAREN LBRACE RBRACE .)
    WHILE           reduce using rule 30 (while -> WHILE LPAREN exp_condition RPAREN LBRACE RBRACE .)
    SUB             reduce using rule 30 (while -> WHILE LPAREN exp_condition RPAREN LBRACE RBRACE .)
    $end            reduce using rule 30 (while -> WHILE LPAREN exp_condition RPAREN LBRACE RBRACE .)
    RBRACE          reduce using rule 30 (while -> WHILE LPAREN exp_condition RPAREN LBRACE RBRACE .)


state 154

    (31) function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .

    SUB             reduce using rule 31 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    RETURN          reduce using rule 31 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    BREAK           reduce using rule 31 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    CONTINUE        reduce using rule 31 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    IF              reduce using rule 31 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    ID_SC           reduce using rule 31 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    ID_LI           reduce using rule 31 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    INCREMENT       reduce using rule 31 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    DECREMENT       reduce using rule 31 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    ID              reduce using rule 31 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    FOR             reduce using rule 31 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    DO              reduce using rule 31 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    WHILE           reduce using rule 31 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)
    $end            reduce using rule 31 (function -> SUB ID LPAREN RPAREN LBRACE blockcode RBRACE .)


state 155

    (32) function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode . RBRACE

    RBRACE          shift and go to state 161


state 156

    (50) exp_condition_logic -> LPAREN exp_condition . RPAREN
    (51) exp_condition_logic -> LPAREN exp_condition . RPAREN logic LPAREN exp_condition RPAREN

    RPAREN          shift and go to state 162


state 157

    (15) if_statement -> LBRACE blockcode RBRACE .
    (16) if_statement -> LBRACE blockcode RBRACE . ELSE LBRACE blockcode RBRACE
    (17) if_statement -> LBRACE blockcode RBRACE . elsif
    (18) elsif -> . ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (19) elsif -> . ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2

    RETURN          reduce using rule 15 (if_statement -> LBRACE blockcode RBRACE .)
    BREAK           reduce using rule 15 (if_statement -> LBRACE blockcode RBRACE .)
    CONTINUE        reduce using rule 15 (if_statement -> LBRACE blockcode RBRACE .)
    IF              reduce using rule 15 (if_statement -> LBRACE blockcode RBRACE .)
    ID_SC           reduce using rule 15 (if_statement -> LBRACE blockcode RBRACE .)
    ID_LI           reduce using rule 15 (if_statement -> LBRACE blockcode RBRACE .)
    INCREMENT       reduce using rule 15 (if_statement -> LBRACE blockcode RBRACE .)
    DECREMENT       reduce using rule 15 (if_statement -> LBRACE blockcode RBRACE .)
    ID              reduce using rule 15 (if_statement -> LBRACE blockcode RBRACE .)
    FOR             reduce using rule 15 (if_statement -> LBRACE blockcode RBRACE .)
    DO              reduce using rule 15 (if_statement -> LBRACE blockcode RBRACE .)
    WHILE           reduce using rule 15 (if_statement -> LBRACE blockcode RBRACE .)
    SUB             reduce using rule 15 (if_statement -> LBRACE blockcode RBRACE .)
    $end            reduce using rule 15 (if_statement -> LBRACE blockcode RBRACE .)
    RBRACE          reduce using rule 15 (if_statement -> LBRACE blockcode RBRACE .)
    ELSE            shift and go to state 163
    ELSIF           shift and go to state 165

    elsif                          shift and go to state 164

state 158

    (25) for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments . RPAREN LBRACE blockcode RBRACE

    RPAREN          shift and go to state 166


state 159

    (28) dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition . RPAREN

    RPAREN          shift and go to state 167


state 160

    (29) while -> WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .

    RETURN          reduce using rule 29 (while -> WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    BREAK           reduce using rule 29 (while -> WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    CONTINUE        reduce using rule 29 (while -> WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    IF              reduce using rule 29 (while -> WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    ID_SC           reduce using rule 29 (while -> WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    ID_LI           reduce using rule 29 (while -> WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    INCREMENT       reduce using rule 29 (while -> WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    DECREMENT       reduce using rule 29 (while -> WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    ID              reduce using rule 29 (while -> WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    FOR             reduce using rule 29 (while -> WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    DO              reduce using rule 29 (while -> WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    WHILE           reduce using rule 29 (while -> WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    SUB             reduce using rule 29 (while -> WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    $end            reduce using rule 29 (while -> WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    RBRACE          reduce using rule 29 (while -> WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)


state 161

    (32) function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .

    SUB             reduce using rule 32 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    RETURN          reduce using rule 32 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    BREAK           reduce using rule 32 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    CONTINUE        reduce using rule 32 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    IF              reduce using rule 32 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    ID_SC           reduce using rule 32 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    ID_LI           reduce using rule 32 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    INCREMENT       reduce using rule 32 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    DECREMENT       reduce using rule 32 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    ID              reduce using rule 32 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    FOR             reduce using rule 32 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    DO              reduce using rule 32 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    WHILE           reduce using rule 32 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)
    $end            reduce using rule 32 (function -> SUB ID LPAREN function_assignments RPAREN LBRACE blockcode RBRACE .)


state 162

    (50) exp_condition_logic -> LPAREN exp_condition RPAREN .
    (51) exp_condition_logic -> LPAREN exp_condition RPAREN . logic LPAREN exp_condition RPAREN
    (52) logic -> . LAND
    (53) logic -> . LOR
    (54) logic -> . LNOT

    XOR             reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    TIMES           reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    DIVIDE          reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    MODULO          reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    PLUS            reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    MINUS           reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    SEMICOLON       reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    RPAREN          reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    RETURN          reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    BREAK           reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    CONTINUE        reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    IF              reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    ID_SC           reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    ID_LI           reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    INCREMENT       reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    DECREMENT       reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    ID              reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    FOR             reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    DO              reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    WHILE           reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    SUB             reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    $end            reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    RBRACE          reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    GT              reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    LT              reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    EQ              reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    GE              reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    LE              reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    NE              reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    CMP             reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    SEQ             reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    SNE             reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    SLT             reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    SGT             reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    SLE             reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    SGE             reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    COMMA           reduce using rule 50 (exp_condition_logic -> LPAREN exp_condition RPAREN .)
    LAND            shift and go to state 136
    LOR             shift and go to state 137
    LNOT            shift and go to state 138

    logic                          shift and go to state 168

state 163

    (16) if_statement -> LBRACE blockcode RBRACE ELSE . LBRACE blockcode RBRACE

    LBRACE          shift and go to state 169


state 164

    (17) if_statement -> LBRACE blockcode RBRACE elsif .

    RETURN          reduce using rule 17 (if_statement -> LBRACE blockcode RBRACE elsif .)
    BREAK           reduce using rule 17 (if_statement -> LBRACE blockcode RBRACE elsif .)
    CONTINUE        reduce using rule 17 (if_statement -> LBRACE blockcode RBRACE elsif .)
    IF              reduce using rule 17 (if_statement -> LBRACE blockcode RBRACE elsif .)
    ID_SC           reduce using rule 17 (if_statement -> LBRACE blockcode RBRACE elsif .)
    ID_LI           reduce using rule 17 (if_statement -> LBRACE blockcode RBRACE elsif .)
    INCREMENT       reduce using rule 17 (if_statement -> LBRACE blockcode RBRACE elsif .)
    DECREMENT       reduce using rule 17 (if_statement -> LBRACE blockcode RBRACE elsif .)
    ID              reduce using rule 17 (if_statement -> LBRACE blockcode RBRACE elsif .)
    FOR             reduce using rule 17 (if_statement -> LBRACE blockcode RBRACE elsif .)
    DO              reduce using rule 17 (if_statement -> LBRACE blockcode RBRACE elsif .)
    WHILE           reduce using rule 17 (if_statement -> LBRACE blockcode RBRACE elsif .)
    SUB             reduce using rule 17 (if_statement -> LBRACE blockcode RBRACE elsif .)
    $end            reduce using rule 17 (if_statement -> LBRACE blockcode RBRACE elsif .)
    RBRACE          reduce using rule 17 (if_statement -> LBRACE blockcode RBRACE elsif .)


state 165

    (18) elsif -> ELSIF . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (19) elsif -> ELSIF . LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2

    LPAREN          shift and go to state 170


state 166

    (25) for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN . LBRACE blockcode RBRACE

    LBRACE          shift and go to state 171


state 167

    (28) dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .

    RETURN          reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    BREAK           reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    CONTINUE        reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    IF              reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    ID_SC           reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    ID_LI           reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    INCREMENT       reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    DECREMENT       reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    ID              reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    FOR             reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    DO              reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    WHILE           reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    SUB             reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    $end            reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)
    RBRACE          reduce using rule 28 (dowhile -> DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN .)


state 168

    (51) exp_condition_logic -> LPAREN exp_condition RPAREN logic . LPAREN exp_condition RPAREN

    LPAREN          shift and go to state 172


state 169

    (16) if_statement -> LBRACE blockcode RBRACE ELSE LBRACE . blockcode RBRACE
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN if_statement
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (30) while -> . WHILE LPAREN exp_condition RPAREN LBRACE RBRACE

    RETURN          shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    IF              shift and go to state 17
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    ID              shift and go to state 6
    FOR             shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24

    blockcode                      shift and go to state 173
    command                        shift and go to state 4
    interations                    shift and go to state 7
    if                             shift and go to state 8
    exp_assignment                 shift and go to state 9
    call                           shift and go to state 10
    for                            shift and go to state 14
    dowhile                        shift and go to state 15
    while                          shift and go to state 16

state 170

    (18) elsif -> ELSIF LPAREN . exp_condition RPAREN LBRACE blockcode RBRACE
    (19) elsif -> ELSIF LPAREN . exp_condition RPAREN LBRACE blockcode RBRACE elsif2
    (35) exp_condition -> . attcond GT attcond
    (36) exp_condition -> . attcond LT attcond
    (37) exp_condition -> . attcond EQ attcond
    (38) exp_condition -> . attcond GE attcond
    (39) exp_condition -> . attcond LE attcond
    (40) exp_condition -> . attcond NE attcond
    (41) exp_condition -> . attcond
    (42) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (43) exp_condition -> . attcond CMP attcond
    (44) exp_condition -> . attcond SEQ attcond
    (45) exp_condition -> . attcond SNE attcond
    (46) exp_condition -> . attcond SLT attcond
    (47) exp_condition -> . attcond SGT attcond
    (48) exp_condition -> . attcond SLE attcond
    (49) exp_condition -> . attcond SGE attcond
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    LPAREN          shift and go to state 84
    NUMBER          shift and go to state 87
    TRUE            shift and go to state 88
    FALSE           shift and go to state 89
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    exp_condition                  shift and go to state 174
    attcond                        shift and go to state 83
    exp_assignment                 shift and go to state 86

state 171

    (25) for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE . blockcode RBRACE
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN if_statement
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (30) while -> . WHILE LPAREN exp_condition RPAREN LBRACE RBRACE

    RETURN          shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    IF              shift and go to state 17
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    ID              shift and go to state 6
    FOR             shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24

    blockcode                      shift and go to state 175
    command                        shift and go to state 4
    interations                    shift and go to state 7
    if                             shift and go to state 8
    exp_assignment                 shift and go to state 9
    call                           shift and go to state 10
    for                            shift and go to state 14
    dowhile                        shift and go to state 15
    while                          shift and go to state 16

state 172

    (51) exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN . exp_condition RPAREN
    (35) exp_condition -> . attcond GT attcond
    (36) exp_condition -> . attcond LT attcond
    (37) exp_condition -> . attcond EQ attcond
    (38) exp_condition -> . attcond GE attcond
    (39) exp_condition -> . attcond LE attcond
    (40) exp_condition -> . attcond NE attcond
    (41) exp_condition -> . attcond
    (42) exp_condition -> . LPAREN exp_condition RPAREN logic exp_condition_logic
    (43) exp_condition -> . attcond CMP attcond
    (44) exp_condition -> . attcond SEQ attcond
    (45) exp_condition -> . attcond SNE attcond
    (46) exp_condition -> . attcond SLT attcond
    (47) exp_condition -> . attcond SGT attcond
    (48) exp_condition -> . attcond SLE attcond
    (49) exp_condition -> . attcond SGE attcond
    (81) attcond -> . exp_assignment
    (82) attcond -> . NUMBER
    (83) attcond -> . TRUE
    (84) attcond -> . FALSE
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT

    LPAREN          shift and go to state 84
    NUMBER          shift and go to state 87
    TRUE            shift and go to state 88
    FALSE           shift and go to state 89
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21

    exp_condition                  shift and go to state 176
    attcond                        shift and go to state 83
    exp_assignment                 shift and go to state 86

state 173

    (16) if_statement -> LBRACE blockcode RBRACE ELSE LBRACE blockcode . RBRACE

    RBRACE          shift and go to state 177


state 174

    (18) elsif -> ELSIF LPAREN exp_condition . RPAREN LBRACE blockcode RBRACE
    (19) elsif -> ELSIF LPAREN exp_condition . RPAREN LBRACE blockcode RBRACE elsif2

    RPAREN          shift and go to state 178


state 175

    (25) for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode . RBRACE

    RBRACE          shift and go to state 179


state 176

    (51) exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition . RPAREN

    RPAREN          shift and go to state 180


state 177

    (16) if_statement -> LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .

    RETURN          reduce using rule 16 (if_statement -> LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    BREAK           reduce using rule 16 (if_statement -> LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    CONTINUE        reduce using rule 16 (if_statement -> LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    IF              reduce using rule 16 (if_statement -> LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    ID_SC           reduce using rule 16 (if_statement -> LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    ID_LI           reduce using rule 16 (if_statement -> LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    INCREMENT       reduce using rule 16 (if_statement -> LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    DECREMENT       reduce using rule 16 (if_statement -> LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    ID              reduce using rule 16 (if_statement -> LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    FOR             reduce using rule 16 (if_statement -> LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    DO              reduce using rule 16 (if_statement -> LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    WHILE           reduce using rule 16 (if_statement -> LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    SUB             reduce using rule 16 (if_statement -> LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    $end            reduce using rule 16 (if_statement -> LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)
    RBRACE          reduce using rule 16 (if_statement -> LBRACE blockcode RBRACE ELSE LBRACE blockcode RBRACE .)


state 178

    (18) elsif -> ELSIF LPAREN exp_condition RPAREN . LBRACE blockcode RBRACE
    (19) elsif -> ELSIF LPAREN exp_condition RPAREN . LBRACE blockcode RBRACE elsif2

    LBRACE          shift and go to state 181


state 179

    (25) for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .

    RETURN          reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    BREAK           reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    CONTINUE        reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    IF              reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    ID_SC           reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    ID_LI           reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    INCREMENT       reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    DECREMENT       reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    ID              reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    FOR             reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    DO              reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    WHILE           reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    SUB             reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    $end            reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)
    RBRACE          reduce using rule 25 (for -> FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE .)


state 180

    (51) exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .

    XOR             reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    TIMES           reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    DIVIDE          reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    MODULO          reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    PLUS            reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    MINUS           reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    SEMICOLON       reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    RPAREN          reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    RETURN          reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    BREAK           reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    CONTINUE        reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    IF              reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    ID_SC           reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    ID_LI           reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    INCREMENT       reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    DECREMENT       reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    ID              reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    FOR             reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    DO              reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    WHILE           reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    SUB             reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    $end            reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    RBRACE          reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    GT              reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    LT              reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    EQ              reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    GE              reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    LE              reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    NE              reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    CMP             reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    SEQ             reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    SNE             reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    SLT             reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    SGT             reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    SLE             reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    SGE             reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)
    COMMA           reduce using rule 51 (exp_condition_logic -> LPAREN exp_condition RPAREN logic LPAREN exp_condition RPAREN .)


state 181

    (18) elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE . blockcode RBRACE
    (19) elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE . blockcode RBRACE elsif2
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN if_statement
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (30) while -> . WHILE LPAREN exp_condition RPAREN LBRACE RBRACE

    RETURN          shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    IF              shift and go to state 17
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    ID              shift and go to state 6
    FOR             shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24

    blockcode                      shift and go to state 182
    command                        shift and go to state 4
    interations                    shift and go to state 7
    if                             shift and go to state 8
    exp_assignment                 shift and go to state 9
    call                           shift and go to state 10
    for                            shift and go to state 14
    dowhile                        shift and go to state 15
    while                          shift and go to state 16

state 182

    (18) elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode . RBRACE
    (19) elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode . RBRACE elsif2

    RBRACE          shift and go to state 183


state 183

    (18) elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .
    (19) elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE . elsif2
    (20) elsif2 -> . elsif
    (21) elsif2 -> . ELSE LBRACE blockcode RBRACE
    (18) elsif -> . ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (19) elsif -> . ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2

    RETURN          reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    BREAK           reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    CONTINUE        reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    IF              reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    ID_SC           reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    ID_LI           reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    INCREMENT       reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    DECREMENT       reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    ID              reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    FOR             reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    DO              reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    WHILE           reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    SUB             reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    $end            reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    RBRACE          reduce using rule 18 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE .)
    ELSE            shift and go to state 186
    ELSIF           shift and go to state 165

    elsif2                         shift and go to state 184
    elsif                          shift and go to state 185

state 184

    (19) elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .

    RETURN          reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    BREAK           reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    CONTINUE        reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    IF              reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    ID_SC           reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    ID_LI           reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    INCREMENT       reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    DECREMENT       reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    ID              reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    FOR             reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    DO              reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    WHILE           reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    SUB             reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    $end            reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)
    RBRACE          reduce using rule 19 (elsif -> ELSIF LPAREN exp_condition RPAREN LBRACE blockcode RBRACE elsif2 .)


state 185

    (20) elsif2 -> elsif .

    RETURN          reduce using rule 20 (elsif2 -> elsif .)
    BREAK           reduce using rule 20 (elsif2 -> elsif .)
    CONTINUE        reduce using rule 20 (elsif2 -> elsif .)
    IF              reduce using rule 20 (elsif2 -> elsif .)
    ID_SC           reduce using rule 20 (elsif2 -> elsif .)
    ID_LI           reduce using rule 20 (elsif2 -> elsif .)
    INCREMENT       reduce using rule 20 (elsif2 -> elsif .)
    DECREMENT       reduce using rule 20 (elsif2 -> elsif .)
    ID              reduce using rule 20 (elsif2 -> elsif .)
    FOR             reduce using rule 20 (elsif2 -> elsif .)
    DO              reduce using rule 20 (elsif2 -> elsif .)
    WHILE           reduce using rule 20 (elsif2 -> elsif .)
    SUB             reduce using rule 20 (elsif2 -> elsif .)
    $end            reduce using rule 20 (elsif2 -> elsif .)
    RBRACE          reduce using rule 20 (elsif2 -> elsif .)


state 186

    (21) elsif2 -> ELSE . LBRACE blockcode RBRACE

    LBRACE          shift and go to state 187


state 187

    (21) elsif2 -> ELSE LBRACE . blockcode RBRACE
    (5) blockcode -> . command
    (6) blockcode -> . command blockcode
    (7) command -> . interations
    (8) command -> . if
    (9) command -> . exp_assignment
    (10) command -> . call
    (11) command -> . RETURN return SEMICOLON
    (12) command -> . BREAK SEMICOLON
    (13) command -> . CONTINUE SEMICOLON
    (22) interations -> . for
    (23) interations -> . dowhile
    (24) interations -> . while
    (14) if -> . IF LPAREN exp_condition RPAREN if_statement
    (55) exp_assignment -> . ID_SC EQUALS arithmetic
    (56) exp_assignment -> . ID_LI EQUALS arithmetic
    (57) exp_assignment -> . ID_SC
    (58) exp_assignment -> . ID_LI
    (59) exp_assignment -> . INCREMENT ID_SC
    (60) exp_assignment -> . DECREMENT ID_SC
    (61) exp_assignment -> . ID_SC INCREMENT
    (62) exp_assignment -> . ID_SC DECREMENT
    (85) call -> . ID LPAREN RPAREN
    (86) call -> . ID LPAREN function_assignments RPAREN
    (25) for -> . FOR LPAREN for_assignments SEMICOLON exp_condition SEMICOLON for_assignments RPAREN LBRACE blockcode RBRACE
    (28) dowhile -> . DO LBRACE blockcode RBRACE WHILE LPAREN exp_condition RPAREN
    (29) while -> . WHILE LPAREN exp_condition RPAREN LBRACE blockcode RBRACE
    (30) while -> . WHILE LPAREN exp_condition RPAREN LBRACE RBRACE

    RETURN          shift and go to state 11
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    IF              shift and go to state 17
    ID_SC           shift and go to state 18
    ID_LI           shift and go to state 19
    INCREMENT       shift and go to state 20
    DECREMENT       shift and go to state 21
    ID              shift and go to state 6
    FOR             shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24

    blockcode                      shift and go to state 188
    command                        shift and go to state 4
    interations                    shift and go to state 7
    if                             shift and go to state 8
    exp_assignment                 shift and go to state 9
    call                           shift and go to state 10
    for                            shift and go to state 14
    dowhile                        shift and go to state 15
    while                          shift and go to state 16

state 188

    (21) elsif2 -> ELSE LBRACE blockcode . RBRACE

    RBRACE          shift and go to state 189


state 189

    (21) elsif2 -> ELSE LBRACE blockcode RBRACE .

    RETURN          reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    BREAK           reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    CONTINUE        reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    IF              reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    ID_SC           reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    ID_LI           reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    INCREMENT       reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    DECREMENT       reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    ID              reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    FOR             reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    DO              reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    WHILE           reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    SUB             reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    $end            reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)
    RBRACE          reduce using rule 21 (elsif2 -> ELSE LBRACE blockcode RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RETURN in state 4 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 4 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 4 resolved as shift
WARNING: shift/reduce conflict for IF in state 4 resolved as shift
WARNING: shift/reduce conflict for ID_SC in state 4 resolved as shift
WARNING: shift/reduce conflict for ID_LI in state 4 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 4 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 4 resolved as shift
WARNING: shift/reduce conflict for ID in state 4 resolved as shift
WARNING: shift/reduce conflict for FOR in state 4 resolved as shift
WARNING: shift/reduce conflict for DO in state 4 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 4 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 18 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 18 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 37 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 37 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 37 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 37 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 38 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 38 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 38 resolved as shift
WARNING: shift/reduce conflict for XOR in state 40 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 82 resolved as shift
WARNING: shift/reduce conflict for GT in state 83 resolved as shift
WARNING: shift/reduce conflict for LT in state 83 resolved as shift
WARNING: shift/reduce conflict for EQ in state 83 resolved as shift
WARNING: shift/reduce conflict for GE in state 83 resolved as shift
WARNING: shift/reduce conflict for LE in state 83 resolved as shift
WARNING: shift/reduce conflict for NE in state 83 resolved as shift
WARNING: shift/reduce conflict for CMP in state 83 resolved as shift
WARNING: shift/reduce conflict for SEQ in state 83 resolved as shift
WARNING: shift/reduce conflict for SNE in state 83 resolved as shift
WARNING: shift/reduce conflict for SLT in state 83 resolved as shift
WARNING: shift/reduce conflict for SGT in state 83 resolved as shift
WARNING: shift/reduce conflict for SLE in state 83 resolved as shift
WARNING: shift/reduce conflict for SGE in state 83 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 117 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 117 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 118 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 118 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 118 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 118 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 118 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 118 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 119 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 119 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 119 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 119 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 119 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 119 resolved as shift
WARNING: reduce/reduce conflict in state 31 resolved using rule (exp_condition -> attcond)
WARNING: rejected rule (return -> attcond) in state 31
WARNING: reduce/reduce conflict in state 33 resolved using rule (exp3 -> exp_assignment)
WARNING: rejected rule (attcond -> exp_assignment) in state 33
WARNING: reduce/reduce conflict in state 34 resolved using rule (exp3 -> NUMBER)
WARNING: rejected rule (attcond -> NUMBER) in state 34
WARNING: reduce/reduce conflict in state 35 resolved using rule (exp3 -> TRUE)
WARNING: rejected rule (attcond -> TRUE) in state 35
WARNING: reduce/reduce conflict in state 36 resolved using rule (exp3 -> FALSE)
WARNING: rejected rule (attcond -> FALSE) in state 36
WARNING: reduce/reduce conflict in state 37 resolved using rule (arithmetic -> exp)
WARNING: rejected rule (exp3 -> exp) in state 37
WARNING: reduce/reduce conflict in state 91 resolved using rule (exp3 -> NUMBER)
WARNING: rejected rule (attcond -> NUMBER) in state 91
WARNING: reduce/reduce conflict in state 92 resolved using rule (exp3 -> exp_assignment)
WARNING: rejected rule (attcond -> exp_assignment) in state 92
WARNING: reduce/reduce conflict in state 93 resolved using rule (exp3 -> TRUE)
WARNING: rejected rule (attcond -> TRUE) in state 93
WARNING: reduce/reduce conflict in state 94 resolved using rule (exp3 -> FALSE)
WARNING: rejected rule (attcond -> FALSE) in state 94
WARNING: reduce/reduce conflict in state 118 resolved using rule (exp -> exp PLUS exp1)
WARNING: rejected rule (exp -> exp1) in state 118
WARNING: reduce/reduce conflict in state 119 resolved using rule (exp -> exp MINUS exp1)
WARNING: rejected rule (exp -> exp1) in state 119
WARNING: reduce/reduce conflict in state 120 resolved using rule (exp1 -> exp1 TIMES exp2)
WARNING: rejected rule (exp1 -> exp2) in state 120
WARNING: reduce/reduce conflict in state 121 resolved using rule (exp1 -> exp1 DIVIDE exp2)
WARNING: rejected rule (exp1 -> exp2) in state 121
WARNING: reduce/reduce conflict in state 122 resolved using rule (exp1 -> exp1 MODULO exp2)
WARNING: rejected rule (exp1 -> exp2) in state 122
WARNING: reduce/reduce conflict in state 123 resolved using rule (exp1 -> exp2)
WARNING: rejected rule (exp2 -> exp3 XOR exp2) in state 123
WARNING: Rule (return -> attcond) is never reduced
WARNING: Rule (exp2 -> exp3 XOR exp2) is never reduced
